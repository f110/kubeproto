// Generated by: gen-go-to-protobuf
syntax = "proto3";
package github.com.prometheus_operator.prometheus_operator.apis.monitoringv1;
option  go_package              = "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1";
option (dev.f110.kubeproto.k8s) = {
  domain: "monitor",
  sub_group: "coreos.com",
  version: "v1",
};

import "kube.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";

enum PrometheusConditionStatus {
  PROMETHEUS_CONDITION_STATUS_TRUE     = 0;
  PROMETHEUS_CONDITION_STATUS_DEGRADED = 1;
  PROMETHEUS_CONDITION_STATUS_FALSE    = 2;
  PROMETHEUS_CONDITION_STATUS_UNKNOWN  = 3;
}

enum PrometheusConditionType {
  PROMETHEUS_CONDITION_TYPE_AVAILABLE  = 0;
  PROMETHEUS_CONDITION_TYPE_RECONCILED = 1;
}

message APIServerConfig {
  // Host of apiserver.
  // A valid string consisting of a hostname or IP followed by an optional port number
  string host = 1 [(dev.f110.kubeproto.field) = { go_name: "Host", api_field_name: "host", inline: false }];
  // BasicAuth allow an endpoint to authenticate over basic authentication
  optional BasicAuth basic_auth = 2 [(dev.f110.kubeproto.field) = { go_name: "BasicAuth", api_field_name: "basicAuth", inline: false }];
  // Bearer token for accessing apiserver.
  optional string bearer_token = 3 [(dev.f110.kubeproto.field) = { go_name: "BearerToken", api_field_name: "bearerToken", inline: false }];
  // File to read bearer token for accessing apiserver.
  optional string bearer_token_file = 4 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenFile", api_field_name: "bearerTokenFile", inline: false }];
  // TLS Config to use for accessing apiserver.
  optional TLSConfig tls_config = 5 [(dev.f110.kubeproto.field) = { go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false }];
  // Authorization section for accessing apiserver
  optional Authorization authorization = 6 [(dev.f110.kubeproto.field) = { go_name: "Authorization", api_field_name: "authorization", inline: false }];
}

message AlertingSpec {
  // AlertmanagerEndpoints Prometheus should fire alerts against.
  repeated AlertmanagerEndpoints alertmanagers = 1 [(dev.f110.kubeproto.field) = { go_name: "Alertmanagers", api_field_name: "alertmanagers", inline: false }];
}

message Alertmanager {
  // Specification of the desired behavior of the Alertmanager cluster. More info:
  // https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  AlertmanagerSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Most recent observed status of the Alertmanager cluster. Read-only. Not
  // included when requesting from the apiserver, only from the Prometheus
  // Operator API itself. More info:
  // https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional AlertmanagerStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message AlertmanagerConfiguration {
  // The name of the AlertmanagerConfig resource which is used to generate the Alertmanager configuration.
  // It must be defined in the same namespace as the Alertmanager object.
  // The operator will not enforce a `namespace` label for routes and inhibition rules.
  optional string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Defines the global parameters of the Alertmanager configuration.
  optional AlertmanagerGlobalConfig global = 2 [(dev.f110.kubeproto.field) = { go_name: "Global", api_field_name: "global", inline: false }];
}

message AlertmanagerEndpoints {
  // Namespace of Endpoints object.
  string namespace = 1 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
  // Name of Endpoints object in Namespace.
  string name = 2 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Port the Alertmanager API is exposed on.
  .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 3 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // Scheme to use when firing alerts.
  optional string scheme = 4 [(dev.f110.kubeproto.field) = { go_name: "Scheme", api_field_name: "scheme", inline: false }];
  // Prefix for the HTTP path alerts are pushed to.
  optional string path_prefix = 5 [(dev.f110.kubeproto.field) = { go_name: "PathPrefix", api_field_name: "pathPrefix", inline: false }];
  // TLS Config to use for alertmanager connection.
  optional TLSConfig tls_config = 6 [(dev.f110.kubeproto.field) = { go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false }];
  // BearerTokenFile to read from filesystem to use when authenticating to
  // Alertmanager.
  optional string bearer_token_file = 7 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenFile", api_field_name: "bearerTokenFile", inline: false }];
  // Authorization section for this alertmanager endpoint
  optional SafeAuthorization authorization = 8 [(dev.f110.kubeproto.field) = { go_name: "Authorization", api_field_name: "authorization", inline: false }];
  // Version of the Alertmanager API that Prometheus uses to send alerts. It
  // can be "v1" or "v2".
  optional string api_version = 9 [(dev.f110.kubeproto.field) = { go_name: "APIVersion", api_field_name: "apiVersion", inline: false }];
  // Timeout is a per-target Alertmanager timeout when pushing alerts.
  string timeout = 10 [(dev.f110.kubeproto.field) = { go_name: "Timeout", api_field_name: "timeout", inline: false }];
}

message AlertmanagerGlobalConfig {
  // ResolveTimeout is the default value used by alertmanager if the alert does
  // not include EndsAt, after this time passes it can declare the alert as resolved if it has not been updated.
  // This has no impact on alerts from Prometheus, as they always include EndsAt.
  string resolve_timeout = 1 [(dev.f110.kubeproto.field) = { go_name: "ResolveTimeout", api_field_name: "resolveTimeout", inline: false }];
  // HTTP client configuration.
  optional HTTPConfig http_config = 2 [(dev.f110.kubeproto.field) = { go_name: "HTTPConfig", api_field_name: "httpConfig", inline: false }];
}

message AlertmanagerList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of Alertmanagers
  repeated Alertmanager items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message AlertmanagerSpec {
  // PodMetadata configures Labels and Annotations which are propagated to the alertmanager pods.
  optional EmbeddedObjectMetadata pod_metadata = 1 [(dev.f110.kubeproto.field) = { go_name: "PodMetadata", api_field_name: "podMetadata", inline: false }];
  // Image if specified has precedence over baseImage, tag and sha
  // combinations. Specifying the version is still necessary to ensure the
  // Prometheus Operator knows what version of Alertmanager is being
  // configured.
  optional string image = 2 [(dev.f110.kubeproto.field) = { go_name: "Image", api_field_name: "image", inline: false }];
  // Version the cluster should be on.
  optional string version = 3 [(dev.f110.kubeproto.field) = { go_name: "Version", api_field_name: "version", inline: false }];
  // Tag of Alertmanager container image to be deployed. Defaults to the value of `version`.
  // Version is ignored if Tag is set.
  // Deprecated: use 'image' instead.  The image tag can be specified
  // as part of the image URL.
  optional string tag = 4 [(dev.f110.kubeproto.field) = { go_name: "Tag", api_field_name: "tag", inline: false }];
  // SHA of Alertmanager container image to be deployed. Defaults to the value of `version`.
  // Similar to a tag, but the SHA explicitly deploys an immutable container image.
  // Version and Tag are ignored if SHA is set.
  // Deprecated: use 'image' instead.  The image digest can be specified
  // as part of the image URL.
  optional string s_h_a = 5 [(dev.f110.kubeproto.field) = { go_name: "SHA", api_field_name: "sha", inline: false }];
  // Base image that is used to deploy pods, without tag.
  // Deprecated: use 'image' instead
  optional string base_image = 6 [(dev.f110.kubeproto.field) = { go_name: "BaseImage", api_field_name: "baseImage", inline: false }];
  // An optional list of references to secrets in the same namespace
  // to use for pulling prometheus and alertmanager images from registries
  // see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
  repeated .k8s.io.api.core.v1.LocalObjectReference image_pull_secrets = 7 [(dev.f110.kubeproto.field) = { go_name: "ImagePullSecrets", api_field_name: "imagePullSecrets", inline: false }];
  // Secrets is a list of Secrets in the same namespace as the Alertmanager
  // object, which shall be mounted into the Alertmanager Pods.
  // The Secrets are mounted into /etc/alertmanager/secrets/<secret-name>.
  repeated string secrets = 8 [(dev.f110.kubeproto.field) = { go_name: "Secrets", api_field_name: "secrets", inline: false }];
  // ConfigMaps is a list of ConfigMaps in the same namespace as the Alertmanager
  // object, which shall be mounted into the Alertmanager Pods.
  // The ConfigMaps are mounted into /etc/alertmanager/configmaps/<configmap-name>.
  repeated string config_maps = 9 [(dev.f110.kubeproto.field) = { go_name: "ConfigMaps", api_field_name: "configMaps", inline: false }];
  // ConfigSecret is the name of a Kubernetes Secret in the same namespace as the
  // Alertmanager object, which contains the configuration for this Alertmanager
  // instance. If empty, it defaults to 'alertmanager-<alertmanager-name>'.
  // The Alertmanager configuration should be available under the
  // `alertmanager.yaml` key. Additional keys from the original secret are
  // copied to the generated secret.
  // If either the secret or the `alertmanager.yaml` key is missing, the
  // operator provisions an Alertmanager configuration with one empty
  // receiver (effectively dropping alert notifications).
  optional string config_secret = 10 [(dev.f110.kubeproto.field) = { go_name: "ConfigSecret", api_field_name: "configSecret", inline: false }];
  // Log level for Alertmanager to be configured with.
  optional string log_level = 11 [(dev.f110.kubeproto.field) = { go_name: "LogLevel", api_field_name: "logLevel", inline: false }];
  // Log format for Alertmanager to be configured with.
  optional string log_format = 12 [(dev.f110.kubeproto.field) = { go_name: "LogFormat", api_field_name: "logFormat", inline: false }];
  // Size is the expected size of the alertmanager cluster. The controller will
  // eventually make the size of the running cluster equal to the expected
  // size.
  optional int32 replicas = 13 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // Time duration Alertmanager shall retain data for. Default is '120h',
  // and must match the regular expression `[0-9]+(ms|s|m|h)` (milliseconds seconds minutes hours).
  string retention = 14 [(dev.f110.kubeproto.field) = { go_name: "Retention", api_field_name: "retention", inline: false }];
  // Storage is the definition of how storage will be used by the Alertmanager
  // instances.
  optional StorageSpec storage = 15 [(dev.f110.kubeproto.field) = { go_name: "Storage", api_field_name: "storage", inline: false }];
  // Volumes allows configuration of additional volumes on the output StatefulSet definition.
  // Volumes specified will be appended to other volumes that are generated as a result of
  // StorageSpec objects.
  repeated .k8s.io.api.core.v1.Volume volumes = 16 [(dev.f110.kubeproto.field) = { go_name: "Volumes", api_field_name: "volumes", inline: false }];
  // VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition.
  // VolumeMounts specified will be appended to other VolumeMounts in the alertmanager container,
  // that are generated as a result of StorageSpec objects.
  repeated .k8s.io.api.core.v1.VolumeMount volume_mounts = 17 [(dev.f110.kubeproto.field) = { go_name: "VolumeMounts", api_field_name: "volumeMounts", inline: false }];
  // The external URL the Alertmanager instances will be available under. This is
  // necessary to generate correct URLs. This is necessary if Alertmanager is not
  // served from root of a DNS name.
  optional string external_url = 18 [(dev.f110.kubeproto.field) = { go_name: "ExternalURL", api_field_name: "externalUrl", inline: false }];
  // The route prefix Alertmanager registers HTTP handlers for. This is useful,
  // if using ExternalURL and a proxy is rewriting HTTP routes of a request,
  // and the actual ExternalURL is still true, but the server serves requests
  // under a different route prefix. For example for use with `kubectl proxy`.
  optional string route_prefix = 19 [(dev.f110.kubeproto.field) = { go_name: "RoutePrefix", api_field_name: "routePrefix", inline: false }];
  // If set to true all actions on the underlying managed objects are not
  // goint to be performed, except for delete actions.
  optional bool paused = 20 [(dev.f110.kubeproto.field) = { go_name: "Paused", api_field_name: "paused", inline: false }];
  // Define which Nodes the Pods are scheduled on.
  map<string, string> node_selector = 21 [(dev.f110.kubeproto.field) = { go_name: "NodeSelector", api_field_name: "nodeSelector", inline: false }];
  // Define resources requests and limits for single Pods.
  optional .k8s.io.api.core.v1.ResourceRequirements resources = 22 [(dev.f110.kubeproto.field) = { go_name: "Resources", api_field_name: "resources", inline: false }];
  // If specified, the pod's scheduling constraints.
  optional .k8s.io.api.core.v1.Affinity affinity = 23 [(dev.f110.kubeproto.field) = { go_name: "Affinity", api_field_name: "affinity", inline: false }];
  // If specified, the pod's tolerations.
  repeated .k8s.io.api.core.v1.Toleration tolerations = 24 [(dev.f110.kubeproto.field) = { go_name: "Tolerations", api_field_name: "tolerations", inline: false }];
  // If specified, the pod's topology spread constraints.
  repeated .k8s.io.api.core.v1.TopologySpreadConstraint topology_spread_constraints = 25 [(dev.f110.kubeproto.field) = { go_name: "TopologySpreadConstraints", api_field_name: "topologySpreadConstraints", inline: false }];
  // SecurityContext holds pod-level security attributes and common container settings.
  // This defaults to the default PodSecurityContext.
  optional .k8s.io.api.core.v1.PodSecurityContext security_context = 26 [(dev.f110.kubeproto.field) = { go_name: "SecurityContext", api_field_name: "securityContext", inline: false }];
  // ServiceAccountName is the name of the ServiceAccount to use to run the
  // Prometheus Pods.
  optional string service_account_name = 27 [(dev.f110.kubeproto.field) = { go_name: "ServiceAccountName", api_field_name: "serviceAccountName", inline: false }];
  // ListenLocal makes the Alertmanager server listen on loopback, so that it
  // does not bind against the Pod IP. Note this is only for the Alertmanager
  // UI, not the gossip communication.
  optional bool listen_local = 28 [(dev.f110.kubeproto.field) = { go_name: "ListenLocal", api_field_name: "listenLocal", inline: false }];
  // Containers allows injecting additional containers. This is meant to
  // allow adding an authentication proxy to an Alertmanager pod.
  // Containers described here modify an operator generated container if they
  // share the same name and modifications are done via a strategic merge
  // patch. The current container names are: `alertmanager` and
  // `config-reloader`. Overriding containers is entirely outside the scope
  // of what the maintainers will support and by doing so, you accept that
  // this behaviour may break at any time without notice.
  repeated .k8s.io.api.core.v1.Container containers = 29 [(dev.f110.kubeproto.field) = { go_name: "Containers", api_field_name: "containers", inline: false }];
  // InitContainers allows adding initContainers to the pod definition. Those can be used to e.g.
  // fetch secrets for injection into the Alertmanager configuration from external sources. Any
  // errors during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  // Using initContainers for any use case other then secret fetching is entirely outside the scope
  // of what the maintainers will support and by doing so, you accept that this behaviour may break
  // at any time without notice.
  repeated .k8s.io.api.core.v1.Container init_containers = 30 [(dev.f110.kubeproto.field) = { go_name: "InitContainers", api_field_name: "initContainers", inline: false }];
  // Priority class assigned to the Pods
  optional string priority_class_name = 31 [(dev.f110.kubeproto.field) = { go_name: "PriorityClassName", api_field_name: "priorityClassName", inline: false }];
  // AdditionalPeers allows injecting a set of additional Alertmanagers to peer with to form a highly available cluster.
  repeated string additional_peers = 32 [(dev.f110.kubeproto.field) = { go_name: "AdditionalPeers", api_field_name: "additionalPeers", inline: false }];
  // ClusterAdvertiseAddress is the explicit address to advertise in cluster.
  // Needs to be provided for non RFC1918 [1] (public) addresses.
  // [1] RFC1918: https://tools.ietf.org/html/rfc1918
  optional string cluster_advertise_address = 33 [(dev.f110.kubeproto.field) = { go_name: "ClusterAdvertiseAddress", api_field_name: "clusterAdvertiseAddress", inline: false }];
  // Interval between gossip attempts.
  string cluster_gossip_interval = 34 [(dev.f110.kubeproto.field) = { go_name: "ClusterGossipInterval", api_field_name: "clusterGossipInterval", inline: false }];
  // Interval between pushpull attempts.
  string cluster_pushpull_interval = 35 [(dev.f110.kubeproto.field) = { go_name: "ClusterPushpullInterval", api_field_name: "clusterPushpullInterval", inline: false }];
  // Timeout for cluster peering.
  string cluster_peer_timeout = 36 [(dev.f110.kubeproto.field) = { go_name: "ClusterPeerTimeout", api_field_name: "clusterPeerTimeout", inline: false }];
  // Port name used for the pods and governing service.
  // This defaults to web
  optional string port_name = 37 [(dev.f110.kubeproto.field) = { go_name: "PortName", api_field_name: "portName", inline: false }];
  // ForceEnableClusterMode ensures Alertmanager does not deactivate the cluster mode when running with a single replica.
  // Use case is e.g. spanning an Alertmanager cluster across Kubernetes clusters with a single replica in each.
  optional bool force_enable_cluster_mode = 38 [(dev.f110.kubeproto.field) = { go_name: "ForceEnableClusterMode", api_field_name: "forceEnableClusterMode", inline: false }];
  // AlertmanagerConfigs to be selected for to merge and configure Alertmanager with.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector alertmanager_config_selector = 39 [(dev.f110.kubeproto.field) = { go_name: "AlertmanagerConfigSelector", api_field_name: "alertmanagerConfigSelector", inline: false }];
  // Namespaces to be selected for AlertmanagerConfig discovery. If nil, only
  // check own namespace.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector alertmanager_config_namespace_selector = 40 [(dev.f110.kubeproto.field) = { go_name: "AlertmanagerConfigNamespaceSelector", api_field_name: "alertmanagerConfigNamespaceSelector", inline: false }];
  // Minimum number of seconds for which a newly created pod should be ready
  // without any of its container crashing for it to be considered available.
  // Defaults to 0 (pod will be considered available as soon as it is ready)
  // This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate.
  optional uint32 min_ready_seconds = 41 [(dev.f110.kubeproto.field) = { go_name: "MinReadySeconds", api_field_name: "minReadySeconds", inline: false }];
  // Pods' hostAliases configuration
  repeated HostAlias host_aliases = 42 [(dev.f110.kubeproto.field) = { go_name: "HostAliases", api_field_name: "hostAliases", inline: false }];
  // Defines the web command line flags when starting Alertmanager.
  optional AlertmanagerWebSpec web = 43 [(dev.f110.kubeproto.field) = { go_name: "Web", api_field_name: "web", inline: false }];
  // EXPERIMENTAL: alertmanagerConfiguration specifies the configuration of Alertmanager.
  // If defined, it takes precedence over the `configSecret` field.
  // This field may change in future releases.
  optional AlertmanagerConfiguration alertmanager_configuration = 44 [(dev.f110.kubeproto.field) = { go_name: "AlertmanagerConfiguration", api_field_name: "alertmanagerConfiguration", inline: false }];
}

message AlertmanagerStatus {
  // Represents whether any actions on the underlying managed objects are
  // being performed. Only delete actions will be performed.
  bool paused = 1 [(dev.f110.kubeproto.field) = { go_name: "Paused", api_field_name: "paused", inline: false }];
  // Total number of non-terminated pods targeted by this Alertmanager
  // cluster (their labels match the selector).
  int32 replicas = 2 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // Total number of non-terminated pods targeted by this Alertmanager
  // cluster that have the desired version spec.
  int32 updated_replicas = 3 [(dev.f110.kubeproto.field) = { go_name: "UpdatedReplicas", api_field_name: "updatedReplicas", inline: false }];
  // Total number of available pods (ready for at least minReadySeconds)
  // targeted by this Alertmanager cluster.
  int32 available_replicas = 4 [(dev.f110.kubeproto.field) = { go_name: "AvailableReplicas", api_field_name: "availableReplicas", inline: false }];
  // Total number of unavailable pods targeted by this Alertmanager cluster.
  int32 unavailable_replicas = 5 [(dev.f110.kubeproto.field) = { go_name: "UnavailableReplicas", api_field_name: "unavailableReplicas", inline: false }];
}

message AlertmanagerWebSpec {
  WebConfigFileFields web_config_file_fields = 1 [(dev.f110.kubeproto.field) = { go_name: "WebConfigFileFields", inline: true }];
}

message ArbitraryFSAccessThroughSMsConfig {
  optional bool deny = 1 [(dev.f110.kubeproto.field) = { go_name: "Deny", api_field_name: "deny", inline: false }];
}

message Argument {
  // Name of the argument, e.g. "scrape.discovery-reload-interval".
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Argument value, e.g. 30s. Can be empty for name-only arguments (e.g. --storage.tsdb.no-lockfile)
  optional string value = 2 [(dev.f110.kubeproto.field) = { go_name: "Value", api_field_name: "value", inline: false }];
}

message AttachMetadata {
  // When set to true, Prometheus must have permissions to get Nodes.
  optional bool node = 1 [(dev.f110.kubeproto.field) = { go_name: "Node", api_field_name: "node", inline: false }];
}

message Authorization {
  SafeAuthorization safe_authorization = 1 [(dev.f110.kubeproto.field) = { go_name: "SafeAuthorization", inline: true }];
  // File to read a secret from, mutually exclusive with Credentials (from SafeAuthorization)
  optional string credentials_file = 2 [(dev.f110.kubeproto.field) = { go_name: "CredentialsFile", api_field_name: "credentialsFile", inline: false }];
}

message AuthorizationValidationError {
}

message BasicAuth {
  // The secret in the service monitor namespace that contains the username
  // for authentication.
  optional .k8s.io.api.core.v1.SecretKeySelector username = 1 [(dev.f110.kubeproto.field) = { go_name: "Username", api_field_name: "username", inline: false }];
  // The secret in the service monitor namespace that contains the password
  // for authentication.
  optional .k8s.io.api.core.v1.SecretKeySelector password = 2 [(dev.f110.kubeproto.field) = { go_name: "Password", api_field_name: "password", inline: false }];
}

message CommonPrometheusFields {
  // PodMetadata configures Labels and Annotations which are propagated to the prometheus pods.
  optional EmbeddedObjectMetadata pod_metadata = 1 [(dev.f110.kubeproto.field) = { go_name: "PodMetadata", api_field_name: "podMetadata", inline: false }];
  // ServiceMonitors to be selected for target discovery. *Deprecated:* if
  // neither this nor podMonitorSelector are specified, configuration is
  // unmanaged.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector service_monitor_selector = 2 [(dev.f110.kubeproto.field) = { go_name: "ServiceMonitorSelector", api_field_name: "serviceMonitorSelector", inline: false }];
  // Namespace's labels to match for ServiceMonitor discovery. If nil, only
  // check own namespace.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector service_monitor_namespace_selector = 3 [(dev.f110.kubeproto.field) = { go_name: "ServiceMonitorNamespaceSelector", api_field_name: "serviceMonitorNamespaceSelector", inline: false }];
  // *Experimental* PodMonitors to be selected for target discovery.
  // *Deprecated:* if neither this nor serviceMonitorSelector are specified,
  // configuration is unmanaged.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector pod_monitor_selector = 4 [(dev.f110.kubeproto.field) = { go_name: "PodMonitorSelector", api_field_name: "podMonitorSelector", inline: false }];
  // Namespace's labels to match for PodMonitor discovery. If nil, only
  // check own namespace.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector pod_monitor_namespace_selector = 5 [(dev.f110.kubeproto.field) = { go_name: "PodMonitorNamespaceSelector", api_field_name: "podMonitorNamespaceSelector", inline: false }];
  // *Experimental* Probes to be selected for target discovery.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector probe_selector = 6 [(dev.f110.kubeproto.field) = { go_name: "ProbeSelector", api_field_name: "probeSelector", inline: false }];
  // *Experimental* Namespaces to be selected for Probe discovery. If nil, only check own namespace.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector probe_namespace_selector = 7 [(dev.f110.kubeproto.field) = { go_name: "ProbeNamespaceSelector", api_field_name: "probeNamespaceSelector", inline: false }];
  // Version of Prometheus to be deployed.
  optional string version = 8 [(dev.f110.kubeproto.field) = { go_name: "Version", api_field_name: "version", inline: false }];
  // When a Prometheus deployment is paused, no actions except for deletion
  // will be performed on the underlying objects.
  optional bool paused = 9 [(dev.f110.kubeproto.field) = { go_name: "Paused", api_field_name: "paused", inline: false }];
  // Image if specified has precedence over baseImage, tag and sha
  // combinations. Specifying the version is still necessary to ensure the
  // Prometheus Operator knows what version of Prometheus is being
  // configured.
  optional string image = 10 [(dev.f110.kubeproto.field) = { go_name: "Image", api_field_name: "image", inline: false }];
  // An optional list of references to secrets in the same namespace
  // to use for pulling prometheus and alertmanager images from registries
  // see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
  repeated .k8s.io.api.core.v1.LocalObjectReference image_pull_secrets = 11 [(dev.f110.kubeproto.field) = { go_name: "ImagePullSecrets", api_field_name: "imagePullSecrets", inline: false }];
  // Number of replicas of each shard to deploy for a Prometheus deployment.
  // Number of replicas multiplied by shards is the total number of Pods
  // created.
  optional int32 replicas = 12 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // EXPERIMENTAL: Number of shards to distribute targets onto. Number of
  // replicas multiplied by shards is the total number of Pods created. Note
  // that scaling down shards will not reshard data onto remaining instances,
  // it must be manually moved. Increasing shards will not reshard data
  // either but it will continue to be available from the same instances. To
  // query globally use Thanos sidecar and Thanos querier or remote write
  // data to a central location. Sharding is done on the content of the
  // `__address__` target meta-label.
  optional int32 shards = 13 [(dev.f110.kubeproto.field) = { go_name: "Shards", api_field_name: "shards", inline: false }];
  // Name of Prometheus external label used to denote replica name.
  // Defaults to the value of `prometheus_replica`. External label will
  // _not_ be added when value is set to empty string (`""`).
  optional string replica_external_label_name = 14 [(dev.f110.kubeproto.field) = { go_name: "ReplicaExternalLabelName", api_field_name: "replicaExternalLabelName", inline: false }];
  // Name of Prometheus external label used to denote Prometheus instance
  // name. Defaults to the value of `prometheus`. External label will
  // _not_ be added when value is set to empty string (`""`).
  optional string prometheus_external_label_name = 15 [(dev.f110.kubeproto.field) = { go_name: "PrometheusExternalLabelName", api_field_name: "prometheusExternalLabelName", inline: false }];
  // Log level for Prometheus to be configured with.
  optional string log_level = 16 [(dev.f110.kubeproto.field) = { go_name: "LogLevel", api_field_name: "logLevel", inline: false }];
  // Log format for Prometheus to be configured with.
  optional string log_format = 17 [(dev.f110.kubeproto.field) = { go_name: "LogFormat", api_field_name: "logFormat", inline: false }];
  // Interval between consecutive scrapes. Default: `30s`
  string scrape_interval = 18 [(dev.f110.kubeproto.field) = { go_name: "ScrapeInterval", api_field_name: "scrapeInterval", inline: false }];
  // Number of seconds to wait for target to respond before erroring.
  string scrape_timeout = 19 [(dev.f110.kubeproto.field) = { go_name: "ScrapeTimeout", api_field_name: "scrapeTimeout", inline: false }];
  // The labels to add to any time series or alerts when communicating with
  // external systems (federation, remote storage, Alertmanager).
  map<string, string> external_labels = 20 [(dev.f110.kubeproto.field) = { go_name: "ExternalLabels", api_field_name: "externalLabels", inline: false }];
  // Enable Prometheus to be used as a receiver for the Prometheus remote write protocol. Defaults to the value of `false`.
  // WARNING: This is not considered an efficient way of ingesting samples.
  // Use it with caution for specific low-volume use cases.
  // It is not suitable for replacing the ingestion via scraping and turning
  // Prometheus into a push-based metrics collection system.
  // For more information see https://prometheus.io/docs/prometheus/latest/querying/api/#remote-write-receiver
  // Only valid in Prometheus versions 2.33.0 and newer.
  optional bool enable_remote_write_receiver = 21 [(dev.f110.kubeproto.field) = { go_name: "EnableRemoteWriteReceiver", api_field_name: "enableRemoteWriteReceiver", inline: false }];
  // Enable access to Prometheus disabled features. By default, no features are enabled.
  // Enabling disabled features is entirely outside the scope of what the maintainers will
  // support and by doing so, you accept that this behaviour may break at any
  // time without notice.
  // For more information see https://prometheus.io/docs/prometheus/latest/disabled_features/
  repeated string enable_features = 22 [(dev.f110.kubeproto.field) = { go_name: "EnableFeatures", api_field_name: "enableFeatures", inline: false }];
  // The external URL the Prometheus instances will be available under. This is
  // necessary to generate correct URLs. This is necessary if Prometheus is not
  // served from root of a DNS name.
  optional string external_url = 23 [(dev.f110.kubeproto.field) = { go_name: "ExternalURL", api_field_name: "externalUrl", inline: false }];
  // The route prefix Prometheus registers HTTP handlers for. This is useful,
  // if using ExternalURL and a proxy is rewriting HTTP routes of a request,
  // and the actual ExternalURL is still true, but the server serves requests
  // under a different route prefix. For example for use with `kubectl proxy`.
  optional string route_prefix = 24 [(dev.f110.kubeproto.field) = { go_name: "RoutePrefix", api_field_name: "routePrefix", inline: false }];
  // Storage spec to specify how storage shall be used.
  optional StorageSpec storage = 25 [(dev.f110.kubeproto.field) = { go_name: "Storage", api_field_name: "storage", inline: false }];
  // Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will
  // be appended to other volumes that are generated as a result of StorageSpec objects.
  repeated .k8s.io.api.core.v1.Volume volumes = 26 [(dev.f110.kubeproto.field) = { go_name: "Volumes", api_field_name: "volumes", inline: false }];
  // VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition.
  // VolumeMounts specified will be appended to other VolumeMounts in the prometheus container,
  // that are generated as a result of StorageSpec objects.
  repeated .k8s.io.api.core.v1.VolumeMount volume_mounts = 27 [(dev.f110.kubeproto.field) = { go_name: "VolumeMounts", api_field_name: "volumeMounts", inline: false }];
  // Defines the web command line flags when starting Prometheus.
  optional PrometheusWebSpec web = 28 [(dev.f110.kubeproto.field) = { go_name: "Web", api_field_name: "web", inline: false }];
  // Define resources requests and limits for single Pods.
  optional .k8s.io.api.core.v1.ResourceRequirements resources = 29 [(dev.f110.kubeproto.field) = { go_name: "Resources", api_field_name: "resources", inline: false }];
  // Define which Nodes the Pods are scheduled on.
  map<string, string> node_selector = 30 [(dev.f110.kubeproto.field) = { go_name: "NodeSelector", api_field_name: "nodeSelector", inline: false }];
  // ServiceAccountName is the name of the ServiceAccount to use to run the
  // Prometheus Pods.
  optional string service_account_name = 31 [(dev.f110.kubeproto.field) = { go_name: "ServiceAccountName", api_field_name: "serviceAccountName", inline: false }];
  // Secrets is a list of Secrets in the same namespace as the Prometheus
  // object, which shall be mounted into the Prometheus Pods.
  // The Secrets are mounted into /etc/prometheus/secrets/<secret-name>.
  repeated string secrets = 32 [(dev.f110.kubeproto.field) = { go_name: "Secrets", api_field_name: "secrets", inline: false }];
  // ConfigMaps is a list of ConfigMaps in the same namespace as the Prometheus
  // object, which shall be mounted into the Prometheus Pods.
  // The ConfigMaps are mounted into /etc/prometheus/configmaps/<configmap-name>.
  repeated string config_maps = 33 [(dev.f110.kubeproto.field) = { go_name: "ConfigMaps", api_field_name: "configMaps", inline: false }];
  // If specified, the pod's scheduling constraints.
  optional .k8s.io.api.core.v1.Affinity affinity = 34 [(dev.f110.kubeproto.field) = { go_name: "Affinity", api_field_name: "affinity", inline: false }];
  // If specified, the pod's tolerations.
  repeated .k8s.io.api.core.v1.Toleration tolerations = 35 [(dev.f110.kubeproto.field) = { go_name: "Tolerations", api_field_name: "tolerations", inline: false }];
  // If specified, the pod's topology spread constraints.
  repeated .k8s.io.api.core.v1.TopologySpreadConstraint topology_spread_constraints = 36 [(dev.f110.kubeproto.field) = { go_name: "TopologySpreadConstraints", api_field_name: "topologySpreadConstraints", inline: false }];
  // remoteWrite is the list of remote write configurations.
  repeated RemoteWriteSpec remote_write = 37 [(dev.f110.kubeproto.field) = { go_name: "RemoteWrite", api_field_name: "remoteWrite", inline: false }];
  // SecurityContext holds pod-level security attributes and common container settings.
  // This defaults to the default PodSecurityContext.
  optional .k8s.io.api.core.v1.PodSecurityContext security_context = 38 [(dev.f110.kubeproto.field) = { go_name: "SecurityContext", api_field_name: "securityContext", inline: false }];
  // ListenLocal makes the Prometheus server listen on loopback, so that it
  // does not bind against the Pod IP.
  optional bool listen_local = 39 [(dev.f110.kubeproto.field) = { go_name: "ListenLocal", api_field_name: "listenLocal", inline: false }];
  // Containers allows injecting additional containers or modifying operator
  // generated containers. This can be used to allow adding an authentication
  // proxy to a Prometheus pod or to change the behavior of an operator
  // generated container. Containers described here modify an operator
  // generated container if they share the same name and modifications are
  // done via a strategic merge patch. The current container names are:
  // `prometheus`, `config-reloader`, and `thanos-sidecar`. Overriding
  // containers is entirely outside the scope of what the maintainers will
  // support and by doing so, you accept that this behaviour may break at any
  // time without notice.
  repeated .k8s.io.api.core.v1.Container containers = 40 [(dev.f110.kubeproto.field) = { go_name: "Containers", api_field_name: "containers", inline: false }];
  // InitContainers allows adding initContainers to the pod definition. Those can be used to e.g.
  // fetch secrets for injection into the Prometheus configuration from external sources. Any errors
  // during the execution of an initContainer will lead to a restart of the Pod. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  // InitContainers described here modify an operator
  // generated init containers if they share the same name and modifications are
  // done via a strategic merge patch. The current init container name is:
  // `init-config-reloader`. Overriding init containers is entirely outside the
  // scope of what the maintainers will support and by doing so, you accept that
  // this behaviour may break at any time without notice.
  repeated .k8s.io.api.core.v1.Container init_containers = 41 [(dev.f110.kubeproto.field) = { go_name: "InitContainers", api_field_name: "initContainers", inline: false }];
  // AdditionalScrapeConfigs allows specifying a key of a Secret containing
  // additional Prometheus scrape configurations. Scrape configurations
  // specified are appended to the configurations generated by the Prometheus
  // Operator. Job configurations specified must have the form as specified
  // in the official Prometheus documentation:
  // https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config.
  // As scrape configs are appended, the user is responsible to make sure it
  // is valid. Note that using this feature may expose the possibility to
  // break upgrades of Prometheus. It is advised to review Prometheus release
  // notes to ensure that no incompatible scrape configs are going to break
  // Prometheus after the upgrade.
  optional .k8s.io.api.core.v1.SecretKeySelector additional_scrape_configs = 42 [(dev.f110.kubeproto.field) = { go_name: "AdditionalScrapeConfigs", api_field_name: "additionalScrapeConfigs", inline: false }];
  // APIServerConfig allows specifying a host and auth methods to access apiserver.
  // If left empty, Prometheus is assumed to run inside of the cluster
  // and will discover API servers automatically and use the pod's CA certificate
  // and bearer token file at /var/run/secrets/kubernetes.io/serviceaccount/.
  optional APIServerConfig api_server_config = 43 [(dev.f110.kubeproto.field) = { go_name: "APIServerConfig", api_field_name: "apiserverConfig", inline: false }];
  // Priority class assigned to the Pods
  optional string priority_class_name = 44 [(dev.f110.kubeproto.field) = { go_name: "PriorityClassName", api_field_name: "priorityClassName", inline: false }];
  // Port name used for the pods and governing service.
  // This defaults to web
  optional string port_name = 45 [(dev.f110.kubeproto.field) = { go_name: "PortName", api_field_name: "portName", inline: false }];
  // ArbitraryFSAccessThroughSMs configures whether configuration
  // based on a service monitor can access arbitrary files on the file system
  // of the Prometheus container e.g. bearer token files.
  optional ArbitraryFSAccessThroughSMsConfig arbitrary_fs_access_through_s_ms = 46 [(dev.f110.kubeproto.field) = { go_name: "ArbitraryFSAccessThroughSMs", api_field_name: "arbitraryFSAccessThroughSMs", inline: false }];
  // When true, Prometheus resolves label conflicts by renaming the labels in
  // the scraped data to "exported_<label value>" for all targets created
  // from service and pod monitors.
  // Otherwise the HonorLabels field of the service or pod monitor applies.
  optional bool override_honor_labels = 47 [(dev.f110.kubeproto.field) = { go_name: "OverrideHonorLabels", api_field_name: "overrideHonorLabels", inline: false }];
  // When true, Prometheus ignores the timestamps for all the targets created
  // from service and pod monitors.
  // Otherwise the HonorTimestamps field of the service or pod monitor applies.
  optional bool override_honor_timestamps = 48 [(dev.f110.kubeproto.field) = { go_name: "OverrideHonorTimestamps", api_field_name: "overrideHonorTimestamps", inline: false }];
  // IgnoreNamespaceSelectors if set to true will ignore NamespaceSelector
  // settings from all PodMonitor, ServiceMonitor and Probe objects. They will
  // only discover endpoints within the namespace of the PodMonitor,
  // ServiceMonitor and Probe objects.
  // Defaults to false.
  optional bool ignore_namespace_selectors = 49 [(dev.f110.kubeproto.field) = { go_name: "IgnoreNamespaceSelectors", api_field_name: "ignoreNamespaceSelectors", inline: false }];
  // EnforcedNamespaceLabel If set, a label will be added to
  // 1. all user-metrics (created by `ServiceMonitor`, `PodMonitor` and `Probe` objects) and
  // 2. in all `PrometheusRule` objects (except the ones excluded in `prometheusRulesExcludedFromEnforce`) to
  //    * alerting & recording rules and
  //    * the metrics used in their expressions (`expr`).
  // Label name is this field's value.
  // Label value is the namespace of the created object (mentioned above).
  optional string enforced_namespace_label = 50 [(dev.f110.kubeproto.field) = { go_name: "EnforcedNamespaceLabel", api_field_name: "enforcedNamespaceLabel", inline: false }];
  // EnforcedSampleLimit defines global limit on number of scraped samples
  // that will be accepted. This overrides any SampleLimit set per
  // ServiceMonitor or/and PodMonitor. It is meant to be used by admins to
  // enforce the SampleLimit to keep overall number of samples/series under
  // the desired limit.
  // Note that if SampleLimit is lower that value will be taken instead.
  optional uint64 enforced_sample_limit = 51 [(dev.f110.kubeproto.field) = { go_name: "EnforcedSampleLimit", api_field_name: "enforcedSampleLimit", inline: false }];
  // EnforcedTargetLimit defines a global limit on the number of scraped
  // targets.  This overrides any TargetLimit set per ServiceMonitor or/and
  // PodMonitor.  It is meant to be used by admins to enforce the TargetLimit
  // to keep the overall number of targets under the desired limit.
  // Note that if TargetLimit is lower, that value will be taken instead,
  // except if either value is zero, in which case the non-zero value will be
  // used.  If both values are zero, no limit is enforced.
  optional uint64 enforced_target_limit = 52 [(dev.f110.kubeproto.field) = { go_name: "EnforcedTargetLimit", api_field_name: "enforcedTargetLimit", inline: false }];
  // Per-scrape limit on number of labels that will be accepted for a sample. If
  // more than this number of labels are present post metric-relabeling, the
  // entire scrape will be treated as failed. 0 means no limit.
  // Only valid in Prometheus versions 2.27.0 and newer.
  optional uint64 enforced_label_limit = 53 [(dev.f110.kubeproto.field) = { go_name: "EnforcedLabelLimit", api_field_name: "enforcedLabelLimit", inline: false }];
  // Per-scrape limit on length of labels name that will be accepted for a sample.
  // If a label name is longer than this number post metric-relabeling, the entire
  // scrape will be treated as failed. 0 means no limit.
  // Only valid in Prometheus versions 2.27.0 and newer.
  optional uint64 enforced_label_name_length_limit = 54 [(dev.f110.kubeproto.field) = { go_name: "EnforcedLabelNameLengthLimit", api_field_name: "enforcedLabelNameLengthLimit", inline: false }];
  // Per-scrape limit on length of labels value that will be accepted for a sample.
  // If a label value is longer than this number post metric-relabeling, the
  // entire scrape will be treated as failed. 0 means no limit.
  // Only valid in Prometheus versions 2.27.0 and newer.
  optional uint64 enforced_label_value_length_limit = 55 [(dev.f110.kubeproto.field) = { go_name: "EnforcedLabelValueLengthLimit", api_field_name: "enforcedLabelValueLengthLimit", inline: false }];
  // EnforcedBodySizeLimit defines the maximum size of uncompressed response body
  // that will be accepted by Prometheus. Targets responding with a body larger than this many bytes
  // will cause the scrape to fail. Example: 100MB.
  // If defined, the limit will apply to all service/pod monitors and probes.
  // This is an experimental feature, this behaviour could
  // change or be removed in the future.
  // Only valid in Prometheus versions 2.28.0 and newer.
  string enforced_body_size_limit = 56 [(dev.f110.kubeproto.field) = { go_name: "EnforcedBodySizeLimit", api_field_name: "enforcedBodySizeLimit", inline: false }];
  // Minimum number of seconds for which a newly created pod should be ready
  // without any of its container crashing for it to be considered available.
  // Defaults to 0 (pod will be considered available as soon as it is ready)
  // This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate.
  optional uint32 min_ready_seconds = 57 [(dev.f110.kubeproto.field) = { go_name: "MinReadySeconds", api_field_name: "minReadySeconds", inline: false }];
  // Pods' hostAliases configuration
  repeated HostAlias host_aliases = 58 [(dev.f110.kubeproto.field) = { go_name: "HostAliases", api_field_name: "hostAliases", inline: false }];
  // AdditionalArgs allows setting additional arguments for the Prometheus container.
  // It is intended for e.g. activating hidden flags which are not supported by
  // the dedicated configuration options yet. The arguments are passed as-is to the
  // Prometheus container which may cause issues if they are invalid or not supporeted
  // by the given Prometheus version.
  // In case of an argument conflict (e.g. an argument which is already set by the
  // operator itself) or when providing an invalid argument the reconciliation will
  // fail and an error will be logged.
  repeated Argument additional_args = 59 [(dev.f110.kubeproto.field) = { go_name: "AdditionalArgs", api_field_name: "additionalArgs", inline: false }];
  // Enable compression of the write-ahead log using Snappy. This flag is
  // only available in versions of Prometheus >= 2.11.0.
  optional bool w_a_l_compression = 60 [(dev.f110.kubeproto.field) = { go_name: "WALCompression", api_field_name: "walCompression", inline: false }];
  // List of references to PodMonitor, ServiceMonitor, Probe and PrometheusRule objects
  // to be excluded from enforcing a namespace label of origin.
  // Applies only if enforcedNamespaceLabel set to true.
  repeated ObjectReference excluded_from_enforcement = 61 [(dev.f110.kubeproto.field) = { go_name: "ExcludedFromEnforcement", api_field_name: "excludedFromEnforcement", inline: false }];
}

message EmbeddedObjectMetadata {
  // Name must be unique within a namespace. Is required when creating resources, although
  // some resources may allow a client to request the generation of an appropriate name
  // automatically. Name is primarily intended for creation idempotence and configuration
  // definition.
  // Cannot be updated.
  // More info: http://kubernetes.io/docs/user-guide/identifiers#names
  optional string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Map of string keys and values that can be used to organize and categorize
  // (scope and select) objects. May match selectors of replication controllers
  // and services.
  // More info: http://kubernetes.io/docs/user-guide/labels
  map<string, string> labels = 2 [(dev.f110.kubeproto.field) = { go_name: "Labels", api_field_name: "labels", inline: false }];
  // Annotations is an unstructured key value map stored with a resource that may be
  // set by external tools to store and retrieve arbitrary metadata. They are not
  // queryable and should be preserved when modifying objects.
  // More info: http://kubernetes.io/docs/user-guide/annotations
  map<string, string> annotations = 3 [(dev.f110.kubeproto.field) = { go_name: "Annotations", api_field_name: "annotations", inline: false }];
}

message EmbeddedPersistentVolumeClaim {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // EmbeddedMetadata contains metadata relevant to an EmbeddedResource.
  optional EmbeddedObjectMetadata embedded_object_metadata = 2 [(dev.f110.kubeproto.field) = { go_name: "EmbeddedObjectMetadata", api_field_name: "metadata", inline: false }];
  // Spec defines the desired characteristics of a volume requested by a pod author.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  optional .k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status represents the current information/status of a persistent volume claim.
  // Read-only.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  optional .k8s.io.api.core.v1.PersistentVolumeClaimStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
}

message Endpoint {
  // Name of the service port this endpoint refers to. Mutually exclusive with targetPort.
  optional string port = 1 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // Name or number of the target port of the Pod behind the Service, the port must be specified with container port property. Mutually exclusive with port.
  optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString target_port = 2 [(dev.f110.kubeproto.field) = { go_name: "TargetPort", api_field_name: "targetPort", inline: false }];
  // HTTP path to scrape for metrics.
  // If empty, Prometheus uses the default value (e.g. `/metrics`).
  optional string path = 3 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // HTTP scheme to use for scraping.
  optional string scheme = 4 [(dev.f110.kubeproto.field) = { go_name: "Scheme", api_field_name: "scheme", inline: false }];
  // Optional HTTP URL parameters
  // This field can not be represented by protobuf.
  // map<string, > params = 5 [(dev.f110.kubeproto.field) = {go_name: "Params", api_field_name: "params", inline: false}];
  // Interval at which metrics should be scraped
  // If not specified Prometheus' global scrape interval is used.
  string interval = 6 [(dev.f110.kubeproto.field) = { go_name: "Interval", api_field_name: "interval", inline: false }];
  // Timeout after which the scrape is ended
  // If not specified, the Prometheus global scrape timeout is used unless it is less than `Interval` in which the latter is used.
  string scrape_timeout = 7 [(dev.f110.kubeproto.field) = { go_name: "ScrapeTimeout", api_field_name: "scrapeTimeout", inline: false }];
  // TLS configuration to use when scraping the endpoint
  optional TLSConfig tls_config = 8 [(dev.f110.kubeproto.field) = { go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false }];
  // File to read bearer token for scraping targets.
  optional string bearer_token_file = 9 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenFile", api_field_name: "bearerTokenFile", inline: false }];
  // Secret to mount to read bearer token for scraping targets. The secret
  // needs to be in the same namespace as the service monitor and accessible by
  // the Prometheus Operator.
  optional .k8s.io.api.core.v1.SecretKeySelector bearer_token_secret = 10 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenSecret", api_field_name: "bearerTokenSecret", inline: false }];
  // Authorization section for this endpoint
  optional SafeAuthorization authorization = 11 [(dev.f110.kubeproto.field) = { go_name: "Authorization", api_field_name: "authorization", inline: false }];
  // HonorLabels chooses the metric's labels on collisions with target labels.
  optional bool honor_labels = 12 [(dev.f110.kubeproto.field) = { go_name: "HonorLabels", api_field_name: "honorLabels", inline: false }];
  // HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
  optional bool honor_timestamps = 13 [(dev.f110.kubeproto.field) = { go_name: "HonorTimestamps", api_field_name: "honorTimestamps", inline: false }];
  // BasicAuth allow an endpoint to authenticate over basic authentication
  // More info: https://prometheus.io/docs/operating/configuration/#endpoints
  optional BasicAuth basic_auth = 14 [(dev.f110.kubeproto.field) = { go_name: "BasicAuth", api_field_name: "basicAuth", inline: false }];
  // OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
  optional OAuth2 o_auth2 = 15 [(dev.f110.kubeproto.field) = { go_name: "OAuth2", api_field_name: "oauth2", inline: false }];
  // MetricRelabelConfigs to apply to samples before ingestion.
  repeated RelabelConfig metric_relabel_configs = 16 [(dev.f110.kubeproto.field) = { go_name: "MetricRelabelConfigs", api_field_name: "metricRelabelings", inline: false }];
  // RelabelConfigs to apply to samples before scraping.
  // Prometheus Operator automatically adds relabelings for a few standard Kubernetes fields.
  // The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
  // More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
  repeated RelabelConfig relabel_configs = 17 [(dev.f110.kubeproto.field) = { go_name: "RelabelConfigs", api_field_name: "relabelings", inline: false }];
  // ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
  optional string proxy_url = 18 [(dev.f110.kubeproto.field) = { go_name: "ProxyURL", api_field_name: "proxyUrl", inline: false }];
  // FollowRedirects configures whether scrape requests follow HTTP 3xx redirects.
  optional bool follow_redirects = 19 [(dev.f110.kubeproto.field) = { go_name: "FollowRedirects", api_field_name: "followRedirects", inline: false }];
  // Whether to enable HTTP2.
  optional bool enable_http2 = 20 [(dev.f110.kubeproto.field) = { go_name: "EnableHttp2", api_field_name: "enableHttp2", inline: false }];
}

message Exemplars {
  // Maximum number of exemplars stored in memory for all series.
  // If not set, Prometheus uses its default value.
  // A value of zero or less than zero disables the storage.
  optional int64 max_size = 1 [(dev.f110.kubeproto.field) = { go_name: "MaxSize", api_field_name: "maxSize", inline: false }];
}

message HTTPConfig {
  // Authorization header configuration for the client.
  // This is mutually exclusive with BasicAuth and is only available starting from Alertmanager v0.22+.
  optional SafeAuthorization authorization = 1 [(dev.f110.kubeproto.field) = { go_name: "Authorization", api_field_name: "authorization", inline: false }];
  // BasicAuth for the client.
  // This is mutually exclusive with Authorization. If both are defined, BasicAuth takes precedence.
  optional BasicAuth basic_auth = 2 [(dev.f110.kubeproto.field) = { go_name: "BasicAuth", api_field_name: "basicAuth", inline: false }];
  // OAuth2 client credentials used to fetch a token for the targets.
  optional OAuth2 o_auth2 = 3 [(dev.f110.kubeproto.field) = { go_name: "OAuth2", api_field_name: "oauth2", inline: false }];
  // The secret's key that contains the bearer token to be used by the client
  // for authentication.
  // The secret needs to be in the same namespace as the Alertmanager
  // object and accessible by the Prometheus Operator.
  optional .k8s.io.api.core.v1.SecretKeySelector bearer_token_secret = 4 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenSecret", api_field_name: "bearerTokenSecret", inline: false }];
  // TLS configuration for the client.
  optional SafeTLSConfig tls_config = 5 [(dev.f110.kubeproto.field) = { go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false }];
  // Optional proxy URL.
  optional string proxy_url = 6 [(dev.f110.kubeproto.field) = { go_name: "ProxyURL", api_field_name: "proxyURL", inline: false }];
  // FollowRedirects specifies whether the client should follow HTTP 3xx redirects.
  optional bool follow_redirects = 7 [(dev.f110.kubeproto.field) = { go_name: "FollowRedirects", api_field_name: "followRedirects", inline: false }];
}

message HostAlias {
  // IP address of the host file entry.
  string ip = 1 [(dev.f110.kubeproto.field) = { go_name: "IP", api_field_name: "ip", inline: false }];
  // Hostnames for the above IP address.
  repeated string hostnames = 2 [(dev.f110.kubeproto.field) = { go_name: "Hostnames", api_field_name: "hostnames", inline: false }];
}

message MetadataConfig {
  // Whether metric metadata is sent to the remote storage or not.
  optional bool send = 1 [(dev.f110.kubeproto.field) = { go_name: "Send", api_field_name: "send", inline: false }];
  // How frequently metric metadata is sent to the remote storage.
  string send_interval = 2 [(dev.f110.kubeproto.field) = { go_name: "SendInterval", api_field_name: "sendInterval", inline: false }];
}

message NamespaceSelector {
  // Boolean describing whether all namespaces are selected in contrast to a
  // list restricting them.
  optional bool any = 1 [(dev.f110.kubeproto.field) = { go_name: "Any", api_field_name: "any", inline: false }];
  // List of namespace names to select from.
  repeated string match_names = 2 [(dev.f110.kubeproto.field) = { go_name: "MatchNames", api_field_name: "matchNames", inline: false }];
}

message OAuth2 {
  // The secret or configmap containing the OAuth2 client id
  SecretOrConfigMap client_id = 1 [(dev.f110.kubeproto.field) = { go_name: "ClientID", api_field_name: "clientId", inline: false }];
  // The secret containing the OAuth2 client secret
  .k8s.io.api.core.v1.SecretKeySelector client_secret = 2 [(dev.f110.kubeproto.field) = { go_name: "ClientSecret", api_field_name: "clientSecret", inline: false }];
  // The URL to fetch the token from
  string token_url = 3 [(dev.f110.kubeproto.field) = { go_name: "TokenURL", api_field_name: "tokenUrl", inline: false }];
  // OAuth2 scopes used for the token request
  repeated string scopes = 4 [(dev.f110.kubeproto.field) = { go_name: "Scopes", api_field_name: "scopes", inline: false }];
  // Parameters to append to the token URL
  map<string, string> endpoint_params = 5 [(dev.f110.kubeproto.field) = { go_name: "EndpointParams", api_field_name: "endpointParams", inline: false }];
}

message OAuth2ValidationError {
}

message ObjectReference {
  // Group of the referent. When not specified, it defaults to `monitoring.coreos.com`
  string group = 1 [(dev.f110.kubeproto.field) = { go_name: "Group", api_field_name: "group", inline: false }];
  // Resource of the referent.
  string resource = 2 [(dev.f110.kubeproto.field) = { go_name: "Resource", api_field_name: "resource", inline: false }];
  // Namespace of the referent.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  string namespace = 3 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
  // Name of the referent. When not set, all resources are matched.
  optional string name = 4 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
}

message PodMetricsEndpoint {
  // Name of the pod port this endpoint refers to. Mutually exclusive with targetPort.
  optional string port = 1 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // Deprecated: Use 'port' instead.
  optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString target_port = 2 [(dev.f110.kubeproto.field) = { go_name: "TargetPort", api_field_name: "targetPort", inline: false }];
  // HTTP path to scrape for metrics.
  // If empty, Prometheus uses the default value (e.g. `/metrics`).
  optional string path = 3 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // HTTP scheme to use for scraping.
  optional string scheme = 4 [(dev.f110.kubeproto.field) = { go_name: "Scheme", api_field_name: "scheme", inline: false }];
  // Optional HTTP URL parameters
  // This field can not be represented by protobuf.
  // map<string, > params = 5 [(dev.f110.kubeproto.field) = {go_name: "Params", api_field_name: "params", inline: false}];
  // Interval at which metrics should be scraped
  // If not specified Prometheus' global scrape interval is used.
  string interval = 6 [(dev.f110.kubeproto.field) = { go_name: "Interval", api_field_name: "interval", inline: false }];
  // Timeout after which the scrape is ended
  // If not specified, the Prometheus global scrape interval is used.
  string scrape_timeout = 7 [(dev.f110.kubeproto.field) = { go_name: "ScrapeTimeout", api_field_name: "scrapeTimeout", inline: false }];
  // TLS configuration to use when scraping the endpoint.
  optional PodMetricsEndpointTLSConfig tls_config = 8 [(dev.f110.kubeproto.field) = { go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false }];
  // Secret to mount to read bearer token for scraping targets. The secret
  // needs to be in the same namespace as the pod monitor and accessible by
  // the Prometheus Operator.
  optional .k8s.io.api.core.v1.SecretKeySelector bearer_token_secret = 9 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenSecret", api_field_name: "bearerTokenSecret", inline: false }];
  // HonorLabels chooses the metric's labels on collisions with target labels.
  optional bool honor_labels = 10 [(dev.f110.kubeproto.field) = { go_name: "HonorLabels", api_field_name: "honorLabels", inline: false }];
  // HonorTimestamps controls whether Prometheus respects the timestamps present in scraped data.
  optional bool honor_timestamps = 11 [(dev.f110.kubeproto.field) = { go_name: "HonorTimestamps", api_field_name: "honorTimestamps", inline: false }];
  // BasicAuth allow an endpoint to authenticate over basic authentication.
  // More info: https://prometheus.io/docs/operating/configuration/#endpoint
  optional BasicAuth basic_auth = 12 [(dev.f110.kubeproto.field) = { go_name: "BasicAuth", api_field_name: "basicAuth", inline: false }];
  // OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
  optional OAuth2 o_auth2 = 13 [(dev.f110.kubeproto.field) = { go_name: "OAuth2", api_field_name: "oauth2", inline: false }];
  // Authorization section for this endpoint
  optional SafeAuthorization authorization = 14 [(dev.f110.kubeproto.field) = { go_name: "Authorization", api_field_name: "authorization", inline: false }];
  // MetricRelabelConfigs to apply to samples before ingestion.
  repeated RelabelConfig metric_relabel_configs = 15 [(dev.f110.kubeproto.field) = { go_name: "MetricRelabelConfigs", api_field_name: "metricRelabelings", inline: false }];
  // RelabelConfigs to apply to samples before scraping.
  // Prometheus Operator automatically adds relabelings for a few standard Kubernetes fields.
  // The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
  // More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
  repeated RelabelConfig relabel_configs = 16 [(dev.f110.kubeproto.field) = { go_name: "RelabelConfigs", api_field_name: "relabelings", inline: false }];
  // ProxyURL eg http://proxyserver:2195 Directs scrapes to proxy through this endpoint.
  optional string proxy_url = 17 [(dev.f110.kubeproto.field) = { go_name: "ProxyURL", api_field_name: "proxyUrl", inline: false }];
  // FollowRedirects configures whether scrape requests follow HTTP 3xx redirects.
  optional bool follow_redirects = 18 [(dev.f110.kubeproto.field) = { go_name: "FollowRedirects", api_field_name: "followRedirects", inline: false }];
  // Whether to enable HTTP2.
  optional bool enable_http2 = 19 [(dev.f110.kubeproto.field) = { go_name: "EnableHttp2", api_field_name: "enableHttp2", inline: false }];
}

message PodMetricsEndpointTLSConfig {
  SafeTLSConfig safe_tls_config = 1 [(dev.f110.kubeproto.field) = { go_name: "SafeTLSConfig", inline: true }];
}

message PodMonitor {
  // Specification of desired Pod selection for target discovery by Prometheus.
  PodMonitorSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message PodMonitorList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of PodMonitors
  repeated PodMonitor items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message PodMonitorSpec {
  // The label to use to retrieve the job name from.
  optional string job_label = 1 [(dev.f110.kubeproto.field) = { go_name: "JobLabel", api_field_name: "jobLabel", inline: false }];
  // PodTargetLabels transfers labels on the Kubernetes Pod onto the target.
  repeated string pod_target_labels = 2 [(dev.f110.kubeproto.field) = { go_name: "PodTargetLabels", api_field_name: "podTargetLabels", inline: false }];
  // A list of endpoints allowed as part of this PodMonitor.
  repeated PodMetricsEndpoint pod_metrics_endpoints = 3 [(dev.f110.kubeproto.field) = { go_name: "PodMetricsEndpoints", api_field_name: "podMetricsEndpoints", inline: false }];
  // Selector to select Pod objects.
  .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // Selector to select which namespaces the Endpoints objects are discovered from.
  optional NamespaceSelector namespace_selector = 5 [(dev.f110.kubeproto.field) = { go_name: "NamespaceSelector", api_field_name: "namespaceSelector", inline: false }];
  // SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
  optional uint64 sample_limit = 6 [(dev.f110.kubeproto.field) = { go_name: "SampleLimit", api_field_name: "sampleLimit", inline: false }];
  // TargetLimit defines a limit on the number of scraped targets that will be accepted.
  optional uint64 target_limit = 7 [(dev.f110.kubeproto.field) = { go_name: "TargetLimit", api_field_name: "targetLimit", inline: false }];
  // Per-scrape limit on number of labels that will be accepted for a sample.
  // Only valid in Prometheus versions 2.27.0 and newer.
  optional uint64 label_limit = 8 [(dev.f110.kubeproto.field) = { go_name: "LabelLimit", api_field_name: "labelLimit", inline: false }];
  // Per-scrape limit on length of labels name that will be accepted for a sample.
  // Only valid in Prometheus versions 2.27.0 and newer.
  optional uint64 label_name_length_limit = 9 [(dev.f110.kubeproto.field) = { go_name: "LabelNameLengthLimit", api_field_name: "labelNameLengthLimit", inline: false }];
  // Per-scrape limit on length of labels value that will be accepted for a sample.
  // Only valid in Prometheus versions 2.27.0 and newer.
  optional uint64 label_value_length_limit = 10 [(dev.f110.kubeproto.field) = { go_name: "LabelValueLengthLimit", api_field_name: "labelValueLengthLimit", inline: false }];
  // Attaches node metadata to discovered targets. Only valid for role: pod.
  // Only valid in Prometheus versions 2.35.0 and newer.
  optional AttachMetadata attach_metadata = 11 [(dev.f110.kubeproto.field) = { go_name: "AttachMetadata", api_field_name: "attachMetadata", inline: false }];
}

message Probe {
  // Specification of desired Ingress selection for target discovery by Prometheus.
  ProbeSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ProbeList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of Probes
  repeated Probe items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ProbeSpec {
  // The job name assigned to scraped metrics by default.
  optional string job_name = 1 [(dev.f110.kubeproto.field) = { go_name: "JobName", api_field_name: "jobName", inline: false }];
  // Specification for the prober to use for probing targets.
  // The prober.URL parameter is required. Targets cannot be probed if left empty.
  optional ProberSpec prober_spec = 2 [(dev.f110.kubeproto.field) = { go_name: "ProberSpec", api_field_name: "prober", inline: false }];
  // The module to use for probing specifying how to probe the target.
  // Example module configuring in the blackbox exporter:
  // https://github.com/prometheus/blackbox_exporter/blob/master/example.yml
  optional string module = 3 [(dev.f110.kubeproto.field) = { go_name: "Module", api_field_name: "module", inline: false }];
  // Targets defines a set of static or dynamically discovered targets to probe.
  optional ProbeTargets targets = 4 [(dev.f110.kubeproto.field) = { go_name: "Targets", api_field_name: "targets", inline: false }];
  // Interval at which targets are probed using the configured prober.
  // If not specified Prometheus' global scrape interval is used.
  string interval = 5 [(dev.f110.kubeproto.field) = { go_name: "Interval", api_field_name: "interval", inline: false }];
  // Timeout for scraping metrics from the Prometheus exporter.
  // If not specified, the Prometheus global scrape interval is used.
  string scrape_timeout = 6 [(dev.f110.kubeproto.field) = { go_name: "ScrapeTimeout", api_field_name: "scrapeTimeout", inline: false }];
  // TLS configuration to use when scraping the endpoint.
  optional ProbeTLSConfig tls_config = 7 [(dev.f110.kubeproto.field) = { go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false }];
  // Secret to mount to read bearer token for scraping targets. The secret
  // needs to be in the same namespace as the probe and accessible by
  // the Prometheus Operator.
  optional .k8s.io.api.core.v1.SecretKeySelector bearer_token_secret = 8 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenSecret", api_field_name: "bearerTokenSecret", inline: false }];
  // BasicAuth allow an endpoint to authenticate over basic authentication.
  // More info: https://prometheus.io/docs/operating/configuration/#endpoint
  optional BasicAuth basic_auth = 9 [(dev.f110.kubeproto.field) = { go_name: "BasicAuth", api_field_name: "basicAuth", inline: false }];
  // OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
  optional OAuth2 o_auth2 = 10 [(dev.f110.kubeproto.field) = { go_name: "OAuth2", api_field_name: "oauth2", inline: false }];
  // MetricRelabelConfigs to apply to samples before ingestion.
  repeated RelabelConfig metric_relabel_configs = 11 [(dev.f110.kubeproto.field) = { go_name: "MetricRelabelConfigs", api_field_name: "metricRelabelings", inline: false }];
  // Authorization section for this endpoint
  optional SafeAuthorization authorization = 12 [(dev.f110.kubeproto.field) = { go_name: "Authorization", api_field_name: "authorization", inline: false }];
  // SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
  optional uint64 sample_limit = 13 [(dev.f110.kubeproto.field) = { go_name: "SampleLimit", api_field_name: "sampleLimit", inline: false }];
  // TargetLimit defines a limit on the number of scraped targets that will be accepted.
  optional uint64 target_limit = 14 [(dev.f110.kubeproto.field) = { go_name: "TargetLimit", api_field_name: "targetLimit", inline: false }];
  // Per-scrape limit on number of labels that will be accepted for a sample.
  // Only valid in Prometheus versions 2.27.0 and newer.
  optional uint64 label_limit = 15 [(dev.f110.kubeproto.field) = { go_name: "LabelLimit", api_field_name: "labelLimit", inline: false }];
  // Per-scrape limit on length of labels name that will be accepted for a sample.
  // Only valid in Prometheus versions 2.27.0 and newer.
  optional uint64 label_name_length_limit = 16 [(dev.f110.kubeproto.field) = { go_name: "LabelNameLengthLimit", api_field_name: "labelNameLengthLimit", inline: false }];
  // Per-scrape limit on length of labels value that will be accepted for a sample.
  // Only valid in Prometheus versions 2.27.0 and newer.
  optional uint64 label_value_length_limit = 17 [(dev.f110.kubeproto.field) = { go_name: "LabelValueLengthLimit", api_field_name: "labelValueLengthLimit", inline: false }];
}

message ProbeTLSConfig {
  SafeTLSConfig safe_tls_config = 1 [(dev.f110.kubeproto.field) = { go_name: "SafeTLSConfig", inline: true }];
}

message ProbeTargetIngress {
  // Selector to select the Ingress objects.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // From which namespaces to select Ingress objects.
  optional NamespaceSelector namespace_selector = 2 [(dev.f110.kubeproto.field) = { go_name: "NamespaceSelector", api_field_name: "namespaceSelector", inline: false }];
  // RelabelConfigs to apply to the label set of the target before it gets
  // scraped.
  // The original ingress address is available via the
  // `__tmp_prometheus_ingress_address` label. It can be used to customize the
  // probed URL.
  // The original scrape job's name is available via the `__tmp_prometheus_job_name` label.
  // More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
  repeated RelabelConfig relabel_configs = 3 [(dev.f110.kubeproto.field) = { go_name: "RelabelConfigs", api_field_name: "relabelingConfigs", inline: false }];
}

message ProbeTargetStaticConfig {
  // The list of hosts to probe.
  repeated string targets = 1 [(dev.f110.kubeproto.field) = { go_name: "Targets", api_field_name: "static", inline: false }];
  // Labels assigned to all metrics scraped from the targets.
  map<string, string> labels = 2 [(dev.f110.kubeproto.field) = { go_name: "Labels", api_field_name: "labels", inline: false }];
  // RelabelConfigs to apply to the label set of the targets before it gets
  // scraped.
  // More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
  repeated RelabelConfig relabel_configs = 3 [(dev.f110.kubeproto.field) = { go_name: "RelabelConfigs", api_field_name: "relabelingConfigs", inline: false }];
}

message ProbeTargets {
  // staticConfig defines the static list of targets to probe and the
  // relabeling configuration.
  // If `ingress` is also defined, `staticConfig` takes precedence.
  // More info: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#static_config.
  optional ProbeTargetStaticConfig static_config = 1 [(dev.f110.kubeproto.field) = { go_name: "StaticConfig", api_field_name: "staticConfig", inline: false }];
  // ingress defines the Ingress objects to probe and the relabeling
  // configuration.
  // If `staticConfig` is also defined, `staticConfig` takes precedence.
  optional ProbeTargetIngress ingress = 2 [(dev.f110.kubeproto.field) = { go_name: "Ingress", api_field_name: "ingress", inline: false }];
}

message ProbeTargetsValidationError {
}

message ProberSpec {
  // Mandatory URL of the prober.
  string url = 1 [(dev.f110.kubeproto.field) = { go_name: "URL", api_field_name: "url", inline: false }];
  // HTTP scheme to use for scraping.
  // Defaults to `http`.
  optional string scheme = 2 [(dev.f110.kubeproto.field) = { go_name: "Scheme", api_field_name: "scheme", inline: false }];
  // Path to collect metrics from.
  // Defaults to `/probe`.
  optional string path = 3 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // Optional ProxyURL.
  optional string proxy_url = 4 [(dev.f110.kubeproto.field) = { go_name: "ProxyURL", api_field_name: "proxyUrl", inline: false }];
}

message Prometheus {
  // Specification of the desired behavior of the Prometheus cluster. More info:
  // https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  PrometheusSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Most recent observed status of the Prometheus cluster. Read-only.
  // More info:
  // https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional PrometheusStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message PrometheusCondition {
  // Type of the condition being reported.
  PrometheusConditionType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // status of the condition.
  PrometheusConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // lastTransitionTime is the time of the last update to the current status property.
  .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
  // Reason for the condition's last transition.
  optional string reason = 4 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // Human-readable message indicating details for the condition's last transition.
  optional string message = 5 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message PrometheusList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of Prometheuses
  repeated Prometheus items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message PrometheusRule {
  // Specification of desired alerting rule definitions for Prometheus.
  PrometheusRuleSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message PrometheusRuleExcludeConfig {
  // RuleNamespace - namespace of excluded rule
  string rule_namespace = 1 [(dev.f110.kubeproto.field) = { go_name: "RuleNamespace", api_field_name: "ruleNamespace", inline: false }];
  // RuleNamespace - name of excluded rule
  string rule_name = 2 [(dev.f110.kubeproto.field) = { go_name: "RuleName", api_field_name: "ruleName", inline: false }];
}

message PrometheusRuleList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of Rules
  repeated PrometheusRule items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message PrometheusRuleSpec {
  // Content of Prometheus rule file
  repeated RuleGroup groups = 1 [(dev.f110.kubeproto.field) = { go_name: "Groups", api_field_name: "groups", inline: false }];
}

message PrometheusSpec {
  CommonPrometheusFields common_prometheus_fields = 1 [(dev.f110.kubeproto.field) = { go_name: "CommonPrometheusFields", inline: true }];
  // Base image to use for a Prometheus deployment.
  // Deprecated: use 'image' instead
  optional string base_image = 2 [(dev.f110.kubeproto.field) = { go_name: "BaseImage", api_field_name: "baseImage", inline: false }];
  // Tag of Prometheus container image to be deployed. Defaults to the value of `version`.
  // Version is ignored if Tag is set.
  // Deprecated: use 'image' instead.  The image tag can be specified
  // as part of the image URL.
  optional string tag = 3 [(dev.f110.kubeproto.field) = { go_name: "Tag", api_field_name: "tag", inline: false }];
  // SHA of Prometheus container image to be deployed. Defaults to the value of `version`.
  // Similar to a tag, but the SHA explicitly deploys an immutable container image.
  // Version and Tag are ignored if SHA is set.
  // Deprecated: use 'image' instead.  The image digest can be specified
  // as part of the image URL.
  optional string s_h_a = 4 [(dev.f110.kubeproto.field) = { go_name: "SHA", api_field_name: "sha", inline: false }];
  // Time duration Prometheus shall retain data for. Default is '24h' if
  // retentionSize is not set, and must match the regular expression `[0-9]+(ms|s|m|h|d|w|y)`
  // (milliseconds seconds minutes hours days weeks years).
  string retention = 5 [(dev.f110.kubeproto.field) = { go_name: "Retention", api_field_name: "retention", inline: false }];
  // Maximum amount of disk space used by blocks.
  string retention_size = 6 [(dev.f110.kubeproto.field) = { go_name: "RetentionSize", api_field_name: "retentionSize", inline: false }];
  // Disable prometheus compaction.
  optional bool disable_compaction = 7 [(dev.f110.kubeproto.field) = { go_name: "DisableCompaction", api_field_name: "disableCompaction", inline: false }];
  // /--rules.*/ command-line arguments.
  optional Rules rules = 8 [(dev.f110.kubeproto.field) = { go_name: "Rules", api_field_name: "rules", inline: false }];
  // PrometheusRulesExcludedFromEnforce - list of prometheus rules to be excluded from enforcing
  // of adding namespace labels. Works only if enforcedNamespaceLabel set to true.
  // Make sure both ruleNamespace and ruleName are set for each pair.
  // Deprecated: use excludedFromEnforcement instead.
  repeated PrometheusRuleExcludeConfig prometheus_rules_excluded_from_enforce = 9 [(dev.f110.kubeproto.field) = { go_name: "PrometheusRulesExcludedFromEnforce", api_field_name: "prometheusRulesExcludedFromEnforce", inline: false }];
  // QuerySpec defines the query command line flags when starting Prometheus.
  optional QuerySpec query = 10 [(dev.f110.kubeproto.field) = { go_name: "Query", api_field_name: "query", inline: false }];
  // A selector to select which PrometheusRules to mount for loading alerting/recording
  // rules from. Until (excluding) Prometheus Operator v0.24.0 Prometheus
  // Operator will migrate any legacy rule ConfigMaps to PrometheusRule custom
  // resources selected by RuleSelector. Make sure it does not match any config
  // maps that you do not want to be migrated.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector rule_selector = 11 [(dev.f110.kubeproto.field) = { go_name: "RuleSelector", api_field_name: "ruleSelector", inline: false }];
  // Namespaces to be selected for PrometheusRules discovery. If unspecified, only
  // the same namespace as the Prometheus object is in is used.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector rule_namespace_selector = 12 [(dev.f110.kubeproto.field) = { go_name: "RuleNamespaceSelector", api_field_name: "ruleNamespaceSelector", inline: false }];
  // Define details regarding alerting.
  optional AlertingSpec alerting = 13 [(dev.f110.kubeproto.field) = { go_name: "Alerting", api_field_name: "alerting", inline: false }];
  // remoteRead is the list of remote read configurations.
  repeated RemoteReadSpec remote_read = 14 [(dev.f110.kubeproto.field) = { go_name: "RemoteRead", api_field_name: "remoteRead", inline: false }];
  // AdditionalAlertRelabelConfigs allows specifying a key of a Secret containing
  // additional Prometheus alert relabel configurations. Alert relabel configurations
  // specified are appended to the configurations generated by the Prometheus
  // Operator. Alert relabel configurations specified must have the form as specified
  // in the official Prometheus documentation:
  // https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs.
  // As alert relabel configs are appended, the user is responsible to make sure it
  // is valid. Note that using this feature may expose the possibility to
  // break upgrades of Prometheus. It is advised to review Prometheus release
  // notes to ensure that no incompatible alert relabel configs are going to break
  // Prometheus after the upgrade.
  optional .k8s.io.api.core.v1.SecretKeySelector additional_alert_relabel_configs = 15 [(dev.f110.kubeproto.field) = { go_name: "AdditionalAlertRelabelConfigs", api_field_name: "additionalAlertRelabelConfigs", inline: false }];
  // AdditionalAlertManagerConfigs allows specifying a key of a Secret containing
  // additional Prometheus AlertManager configurations. AlertManager configurations
  // specified are appended to the configurations generated by the Prometheus
  // Operator. Job configurations specified must have the form as specified
  // in the official Prometheus documentation:
  // https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alertmanager_config.
  // As AlertManager configs are appended, the user is responsible to make sure it
  // is valid. Note that using this feature may expose the possibility to
  // break upgrades of Prometheus. It is advised to review Prometheus release
  // notes to ensure that no incompatible AlertManager configs are going to break
  // Prometheus after the upgrade.
  optional .k8s.io.api.core.v1.SecretKeySelector additional_alert_manager_configs = 16 [(dev.f110.kubeproto.field) = { go_name: "AdditionalAlertManagerConfigs", api_field_name: "additionalAlertManagerConfigs", inline: false }];
  // Thanos configuration allows configuring various aspects of a Prometheus
  // server in a Thanos environment.
  // This section is experimental, it may change significantly without
  // deprecation notice in any release.
  // This is experimental and may change significantly without backward
  // compatibility in any release.
  optional ThanosSpec thanos = 17 [(dev.f110.kubeproto.field) = { go_name: "Thanos", api_field_name: "thanos", inline: false }];
  // QueryLogFile specifies the file to which PromQL queries are logged.
  // If the filename has an empty path, e.g. 'query.log', prometheus-operator will mount the file into an
  // emptyDir volume at `/var/log/prometheus`. If a full path is provided, e.g. /var/log/prometheus/query.log, you must mount a volume
  // in the specified directory and it must be writable. This is because the prometheus container runs with a read-only root filesystem for security reasons.
  // Alternatively, the location can be set to a stdout location such as `/dev/stdout` to log
  // query information to the default Prometheus log stream.
  // This is only available in versions of Prometheus >= 2.16.0.
  // For more details, see the Prometheus docs (https://prometheus.io/docs/guides/query-log/)
  optional string query_log_file = 18 [(dev.f110.kubeproto.field) = { go_name: "QueryLogFile", api_field_name: "queryLogFile", inline: false }];
  // AllowOverlappingBlocks enables vertical compaction and vertical query merge in Prometheus.
  // This is still experimental in Prometheus so it may change in any upcoming release.
  optional bool allow_overlapping_blocks = 19 [(dev.f110.kubeproto.field) = { go_name: "AllowOverlappingBlocks", api_field_name: "allowOverlappingBlocks", inline: false }];
  // Exemplars related settings that are runtime reloadable.
  // It requires to enable the exemplar storage feature to be effective.
  optional Exemplars exemplars = 20 [(dev.f110.kubeproto.field) = { go_name: "Exemplars", api_field_name: "exemplars", inline: false }];
  // Interval between consecutive evaluations. Default: `30s`
  string evaluation_interval = 21 [(dev.f110.kubeproto.field) = { go_name: "EvaluationInterval", api_field_name: "evaluationInterval", inline: false }];
  // Enable access to prometheus web admin API. Defaults to the value of `false`.
  // WARNING: Enabling the admin APIs enables mutating endpoints, to delete data,
  // shutdown Prometheus, and more. Enabling this should be done with care and the
  // user is advised to add additional authentication authorization via a proxy to
  // ensure only clients authorized to perform these actions can do so.
  // For more information see https://prometheus.io/docs/prometheus/latest/querying/api/#tsdb-admin-apis
  optional bool enable_admin_api = 22 [(dev.f110.kubeproto.field) = { go_name: "EnableAdminAPI", api_field_name: "enableAdminAPI", inline: false }];
}

message PrometheusStatus {
  // Represents whether any actions on the underlying managed objects are
  // being performed. Only delete actions will be performed.
  bool paused = 1 [(dev.f110.kubeproto.field) = { go_name: "Paused", api_field_name: "paused", inline: false }];
  // Total number of non-terminated pods targeted by this Prometheus deployment
  // (their labels match the selector).
  int32 replicas = 2 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // Total number of non-terminated pods targeted by this Prometheus deployment
  // that have the desired version spec.
  int32 updated_replicas = 3 [(dev.f110.kubeproto.field) = { go_name: "UpdatedReplicas", api_field_name: "updatedReplicas", inline: false }];
  // Total number of available pods (ready for at least minReadySeconds)
  // targeted by this Prometheus deployment.
  int32 available_replicas = 4 [(dev.f110.kubeproto.field) = { go_name: "AvailableReplicas", api_field_name: "availableReplicas", inline: false }];
  // Total number of unavailable pods targeted by this Prometheus deployment.
  int32 unavailable_replicas = 5 [(dev.f110.kubeproto.field) = { go_name: "UnavailableReplicas", api_field_name: "unavailableReplicas", inline: false }];
  // The current state of the Prometheus deployment.
  repeated PrometheusCondition conditions = 6 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
  // The list has one entry per shard. Each entry provides a summary of the shard status.
  repeated ShardStatus shard_statuses = 7 [(dev.f110.kubeproto.field) = { go_name: "ShardStatuses", api_field_name: "shardStatuses", inline: false }];
}

message PrometheusWebSpec {
  WebConfigFileFields web_config_file_fields = 1 [(dev.f110.kubeproto.field) = { go_name: "WebConfigFileFields", inline: true }];
  // The prometheus web page title
  optional string page_title = 2 [(dev.f110.kubeproto.field) = { go_name: "PageTitle", api_field_name: "pageTitle", inline: false }];
}

message QuerySpec {
  // The delta difference allowed for retrieving metrics during expression evaluations.
  optional string lookback_delta = 1 [(dev.f110.kubeproto.field) = { go_name: "LookbackDelta", api_field_name: "lookbackDelta", inline: false }];
  // Number of concurrent queries that can be run at once.
  optional int32 max_concurrency = 2 [(dev.f110.kubeproto.field) = { go_name: "MaxConcurrency", api_field_name: "maxConcurrency", inline: false }];
  // Maximum number of samples a single query can load into memory. Note that queries will fail if they would load more samples than this into memory, so this also limits the number of samples a query can return.
  optional int32 max_samples = 3 [(dev.f110.kubeproto.field) = { go_name: "MaxSamples", api_field_name: "maxSamples", inline: false }];
  // Maximum time a query may take before being aborted.
  string timeout = 4 [(dev.f110.kubeproto.field) = { go_name: "Timeout", api_field_name: "timeout", inline: false }];
}

message QueueConfig {
  // Capacity is the number of samples to buffer per shard before we start dropping them.
  optional int32 capacity = 1 [(dev.f110.kubeproto.field) = { go_name: "Capacity", api_field_name: "capacity", inline: false }];
  // MinShards is the minimum number of shards, i.e. amount of concurrency.
  optional int32 min_shards = 2 [(dev.f110.kubeproto.field) = { go_name: "MinShards", api_field_name: "minShards", inline: false }];
  // MaxShards is the maximum number of shards, i.e. amount of concurrency.
  optional int32 max_shards = 3 [(dev.f110.kubeproto.field) = { go_name: "MaxShards", api_field_name: "maxShards", inline: false }];
  // MaxSamplesPerSend is the maximum number of samples per send.
  optional int32 max_samples_per_send = 4 [(dev.f110.kubeproto.field) = { go_name: "MaxSamplesPerSend", api_field_name: "maxSamplesPerSend", inline: false }];
  // BatchSendDeadline is the maximum time a sample will wait in buffer.
  optional string batch_send_deadline = 5 [(dev.f110.kubeproto.field) = { go_name: "BatchSendDeadline", api_field_name: "batchSendDeadline", inline: false }];
  // MaxRetries is the maximum number of times to retry a batch on recoverable errors.
  optional int32 max_retries = 6 [(dev.f110.kubeproto.field) = { go_name: "MaxRetries", api_field_name: "maxRetries", inline: false }];
  // MinBackoff is the initial retry delay. Gets doubled for every retry.
  optional string min_backoff = 7 [(dev.f110.kubeproto.field) = { go_name: "MinBackoff", api_field_name: "minBackoff", inline: false }];
  // MaxBackoff is the maximum retry delay.
  optional string max_backoff = 8 [(dev.f110.kubeproto.field) = { go_name: "MaxBackoff", api_field_name: "maxBackoff", inline: false }];
  // Retry upon receiving a 429 status code from the remote-write storage.
  // This is experimental feature and might change in the future.
  optional bool retry_on_rate_limit = 9 [(dev.f110.kubeproto.field) = { go_name: "RetryOnRateLimit", api_field_name: "retryOnRateLimit", inline: false }];
}

message RelabelConfig {
  // The source labels select values from existing labels. Their content is concatenated
  // using the configured separator and matched against the configured regular expression
  // for the replace, keep, and drop actions.
  repeated string source_labels = 1 [(dev.f110.kubeproto.field) = { go_name: "SourceLabels", api_field_name: "sourceLabels", inline: false }];
  // Separator placed between concatenated source label values. default is ';'.
  optional string separator = 2 [(dev.f110.kubeproto.field) = { go_name: "Separator", api_field_name: "separator", inline: false }];
  // Label to which the resulting value is written in a replace action.
  // It is mandatory for replace actions. Regex capture groups are available.
  optional string target_label = 3 [(dev.f110.kubeproto.field) = { go_name: "TargetLabel", api_field_name: "targetLabel", inline: false }];
  // Regular expression against which the extracted value is matched. Default is '(.*)'
  optional string regex = 4 [(dev.f110.kubeproto.field) = { go_name: "Regex", api_field_name: "regex", inline: false }];
  // Modulus to take of the hash of the source label values.
  optional uint64 modulus = 5 [(dev.f110.kubeproto.field) = { go_name: "Modulus", api_field_name: "modulus", inline: false }];
  // Replacement value against which a regex replace is performed if the
  // regular expression matches. Regex capture groups are available. Default is '$1'
  optional string replacement = 6 [(dev.f110.kubeproto.field) = { go_name: "Replacement", api_field_name: "replacement", inline: false }];
  // Action to perform based on regex matching. Default is 'replace'.
  // uppercase and lowercase actions require Prometheus >= 2.36.
  optional string action = 7 [(dev.f110.kubeproto.field) = { go_name: "Action", api_field_name: "action", inline: false }];
}

message RemoteReadSpec {
  // The URL of the endpoint to query from.
  string url = 1 [(dev.f110.kubeproto.field) = { go_name: "URL", api_field_name: "url", inline: false }];
  // The name of the remote read queue, it must be unique if specified. The name
  // is used in metrics and logging in order to differentiate read
  // configurations.  Only valid in Prometheus versions 2.15.0 and newer.
  optional string name = 2 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // An optional list of equality matchers which have to be present
  // in a selector to query the remote read endpoint.
  map<string, string> required_matchers = 3 [(dev.f110.kubeproto.field) = { go_name: "RequiredMatchers", api_field_name: "requiredMatchers", inline: false }];
  // Timeout for requests to the remote read endpoint.
  string remote_timeout = 4 [(dev.f110.kubeproto.field) = { go_name: "RemoteTimeout", api_field_name: "remoteTimeout", inline: false }];
  // Custom HTTP headers to be sent along with each remote read request.
  // Be aware that headers that are set by Prometheus itself can't be overwritten.
  // Only valid in Prometheus versions 2.26.0 and newer.
  map<string, string> headers = 5 [(dev.f110.kubeproto.field) = { go_name: "Headers", api_field_name: "headers", inline: false }];
  // Whether reads should be made for queries for time ranges that
  // the local storage should have complete data for.
  optional bool read_recent = 6 [(dev.f110.kubeproto.field) = { go_name: "ReadRecent", api_field_name: "readRecent", inline: false }];
  // BasicAuth for the URL.
  optional BasicAuth basic_auth = 7 [(dev.f110.kubeproto.field) = { go_name: "BasicAuth", api_field_name: "basicAuth", inline: false }];
  // OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
  optional OAuth2 o_auth2 = 8 [(dev.f110.kubeproto.field) = { go_name: "OAuth2", api_field_name: "oauth2", inline: false }];
  // Bearer token for remote read.
  optional string bearer_token = 9 [(dev.f110.kubeproto.field) = { go_name: "BearerToken", api_field_name: "bearerToken", inline: false }];
  // File to read bearer token for remote read.
  optional string bearer_token_file = 10 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenFile", api_field_name: "bearerTokenFile", inline: false }];
  // Authorization section for remote read
  optional Authorization authorization = 11 [(dev.f110.kubeproto.field) = { go_name: "Authorization", api_field_name: "authorization", inline: false }];
  // TLS Config to use for remote read.
  optional TLSConfig tls_config = 12 [(dev.f110.kubeproto.field) = { go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false }];
  // Optional ProxyURL.
  optional string proxy_url = 13 [(dev.f110.kubeproto.field) = { go_name: "ProxyURL", api_field_name: "proxyUrl", inline: false }];
}

message RemoteWriteSpec {
  // The URL of the endpoint to send samples to.
  string url = 1 [(dev.f110.kubeproto.field) = { go_name: "URL", api_field_name: "url", inline: false }];
  // The name of the remote write queue, it must be unique if specified. The
  // name is used in metrics and logging in order to differentiate queues.
  // Only valid in Prometheus versions 2.15.0 and newer.
  optional string name = 2 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Enables sending of exemplars over remote write. Note that
  // exemplar-storage itself must be enabled using the enableFeature option
  // for exemplars to be scraped in the first place.  Only valid in
  // Prometheus versions 2.27.0 and newer.
  optional bool send_exemplars = 3 [(dev.f110.kubeproto.field) = { go_name: "SendExemplars", api_field_name: "sendExemplars", inline: false }];
  // Timeout for requests to the remote write endpoint.
  string remote_timeout = 4 [(dev.f110.kubeproto.field) = { go_name: "RemoteTimeout", api_field_name: "remoteTimeout", inline: false }];
  // Custom HTTP headers to be sent along with each remote write request.
  // Be aware that headers that are set by Prometheus itself can't be overwritten.
  // Only valid in Prometheus versions 2.25.0 and newer.
  map<string, string> headers = 5 [(dev.f110.kubeproto.field) = { go_name: "Headers", api_field_name: "headers", inline: false }];
  // The list of remote write relabel configurations.
  repeated RelabelConfig write_relabel_configs = 6 [(dev.f110.kubeproto.field) = { go_name: "WriteRelabelConfigs", api_field_name: "writeRelabelConfigs", inline: false }];
  // OAuth2 for the URL. Only valid in Prometheus versions 2.27.0 and newer.
  optional OAuth2 o_auth2 = 7 [(dev.f110.kubeproto.field) = { go_name: "OAuth2", api_field_name: "oauth2", inline: false }];
  // BasicAuth for the URL.
  optional BasicAuth basic_auth = 8 [(dev.f110.kubeproto.field) = { go_name: "BasicAuth", api_field_name: "basicAuth", inline: false }];
  // Bearer token for remote write.
  optional string bearer_token = 9 [(dev.f110.kubeproto.field) = { go_name: "BearerToken", api_field_name: "bearerToken", inline: false }];
  // File to read bearer token for remote write.
  optional string bearer_token_file = 10 [(dev.f110.kubeproto.field) = { go_name: "BearerTokenFile", api_field_name: "bearerTokenFile", inline: false }];
  // Authorization section for remote write
  optional Authorization authorization = 11 [(dev.f110.kubeproto.field) = { go_name: "Authorization", api_field_name: "authorization", inline: false }];
  // Sigv4 allows to configures AWS's Signature Verification 4
  optional Sigv4 sigv4 = 12 [(dev.f110.kubeproto.field) = { go_name: "Sigv4", api_field_name: "sigv4", inline: false }];
  // TLS Config to use for remote write.
  optional TLSConfig tls_config = 13 [(dev.f110.kubeproto.field) = { go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false }];
  // Optional ProxyURL.
  optional string proxy_url = 14 [(dev.f110.kubeproto.field) = { go_name: "ProxyURL", api_field_name: "proxyUrl", inline: false }];
  // QueueConfig allows tuning of the remote write queue parameters.
  optional QueueConfig queue_config = 15 [(dev.f110.kubeproto.field) = { go_name: "QueueConfig", api_field_name: "queueConfig", inline: false }];
  // MetadataConfig configures the sending of series metadata to the remote storage.
  optional MetadataConfig metadata_config = 16 [(dev.f110.kubeproto.field) = { go_name: "MetadataConfig", api_field_name: "metadataConfig", inline: false }];
}

message Rule {
  optional string                                  record      = 1 [(dev.f110.kubeproto.field) = { go_name: "Record", api_field_name: "record", inline: false }];
  optional string                                  alert       = 2 [(dev.f110.kubeproto.field) = { go_name: "Alert", api_field_name: "alert", inline: false }];
  .k8s.io.apimachinery.pkg.util.intstr.IntOrString expr        = 3 [(dev.f110.kubeproto.field) = { go_name: "Expr", api_field_name: "expr", inline: false }];
optional string for = 4 [(dev.f110.kubeproto.field) = {go_name: "For", api_field_name: "for", inline: false}];
map<string, string>                                labels      = 5 [(dev.f110.kubeproto.field) = { go_name: "Labels", api_field_name: "labels", inline: false }];
map<string, string>                                annotations = 6 [(dev.f110.kubeproto.field) = { go_name: "Annotations", api_field_name: "annotations", inline: false }];
}

message RuleGroup {
  string          name                      = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  optional string interval                  = 2 [(dev.f110.kubeproto.field) = { go_name: "Interval", api_field_name: "interval", inline: false }];
  repeated Rule   rules                     = 3 [(dev.f110.kubeproto.field) = { go_name: "Rules", api_field_name: "rules", inline: false }];
  optional string partial_response_strategy = 4 [(dev.f110.kubeproto.field) = { go_name: "PartialResponseStrategy", api_field_name: "partial_response_strategy", inline: false }];
}

message Rules {
  optional RulesAlert alert = 1 [(dev.f110.kubeproto.field) = { go_name: "Alert", api_field_name: "alert", inline: false }];
}

message RulesAlert {
  // Max time to tolerate prometheus outage for restoring 'for' state of alert.
  optional string for_outage_tolerance = 1 [(dev.f110.kubeproto.field) = { go_name: "ForOutageTolerance", api_field_name: "forOutageTolerance", inline: false }];
  // Minimum duration between alert and restored 'for' state.
  // This is maintained only for alerts with configured 'for' time greater than grace period.
  optional string for_grace_period = 2 [(dev.f110.kubeproto.field) = { go_name: "ForGracePeriod", api_field_name: "forGracePeriod", inline: false }];
  // Minimum amount of time to wait before resending an alert to Alertmanager.
  optional string resend_delay = 3 [(dev.f110.kubeproto.field) = { go_name: "ResendDelay", api_field_name: "resendDelay", inline: false }];
}

message SafeAuthorization {
  // Set the authentication type. Defaults to Bearer, Basic will cause an
  // error
  optional string type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // The secret's key that contains the credentials of the request
  optional .k8s.io.api.core.v1.SecretKeySelector credentials = 2 [(dev.f110.kubeproto.field) = { go_name: "Credentials", api_field_name: "credentials", inline: false }];
}

message SafeTLSConfig {
  // Struct containing the CA cert to use for the targets.
  optional SecretOrConfigMap c_a = 1 [(dev.f110.kubeproto.field) = { go_name: "CA", api_field_name: "ca", inline: false }];
  // Struct containing the client cert file for the targets.
  optional SecretOrConfigMap cert = 2 [(dev.f110.kubeproto.field) = { go_name: "Cert", api_field_name: "cert", inline: false }];
  // Secret containing the client key file for the targets.
  optional .k8s.io.api.core.v1.SecretKeySelector key_secret = 3 [(dev.f110.kubeproto.field) = { go_name: "KeySecret", api_field_name: "keySecret", inline: false }];
  // Used to verify the hostname for the targets.
  optional string server_name = 4 [(dev.f110.kubeproto.field) = { go_name: "ServerName", api_field_name: "serverName", inline: false }];
  // Disable target certificate validation.
  optional bool insecure_skip_verify = 5 [(dev.f110.kubeproto.field) = { go_name: "InsecureSkipVerify", api_field_name: "insecureSkipVerify", inline: false }];
}

message SecretOrConfigMap {
  // Secret containing data to use for the targets.
  optional .k8s.io.api.core.v1.SecretKeySelector secret = 1 [(dev.f110.kubeproto.field) = { go_name: "Secret", api_field_name: "secret", inline: false }];
  // ConfigMap containing data to use for the targets.
  optional .k8s.io.api.core.v1.ConfigMapKeySelector config_map = 2 [(dev.f110.kubeproto.field) = { go_name: "ConfigMap", api_field_name: "configMap", inline: false }];
}

message SecretOrConfigMapValidationError {
}

message ServiceMonitor {
  // Specification of desired Service selection for target discovery by
  // Prometheus.
  ServiceMonitorSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ServiceMonitorList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of ServiceMonitors
  repeated ServiceMonitor items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ServiceMonitorSpec {
  // JobLabel selects the label from the associated Kubernetes service which will be used as the `job` label for all metrics.
  // For example:
  // If in `ServiceMonitor.spec.jobLabel: foo` and in `Service.metadata.labels.foo: bar`,
  // then the `job="bar"` label is added to all metrics.
  // If the value of this field is empty or if the label doesn't exist for the given Service, the `job` label of the metrics defaults to the name of the Kubernetes Service.
  optional string job_label = 1 [(dev.f110.kubeproto.field) = { go_name: "JobLabel", api_field_name: "jobLabel", inline: false }];
  // TargetLabels transfers labels from the Kubernetes `Service` onto the created metrics.
  repeated string target_labels = 2 [(dev.f110.kubeproto.field) = { go_name: "TargetLabels", api_field_name: "targetLabels", inline: false }];
  // PodTargetLabels transfers labels on the Kubernetes `Pod` onto the created metrics.
  repeated string pod_target_labels = 3 [(dev.f110.kubeproto.field) = { go_name: "PodTargetLabels", api_field_name: "podTargetLabels", inline: false }];
  // A list of endpoints allowed as part of this ServiceMonitor.
  repeated Endpoint endpoints = 4 [(dev.f110.kubeproto.field) = { go_name: "Endpoints", api_field_name: "endpoints", inline: false }];
  // Selector to select Endpoints objects.
  .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 5 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // Selector to select which namespaces the Kubernetes Endpoints objects are discovered from.
  optional NamespaceSelector namespace_selector = 6 [(dev.f110.kubeproto.field) = { go_name: "NamespaceSelector", api_field_name: "namespaceSelector", inline: false }];
  // SampleLimit defines per-scrape limit on number of scraped samples that will be accepted.
  optional uint64 sample_limit = 7 [(dev.f110.kubeproto.field) = { go_name: "SampleLimit", api_field_name: "sampleLimit", inline: false }];
  // TargetLimit defines a limit on the number of scraped targets that will be accepted.
  optional uint64 target_limit = 8 [(dev.f110.kubeproto.field) = { go_name: "TargetLimit", api_field_name: "targetLimit", inline: false }];
  // Per-scrape limit on number of labels that will be accepted for a sample.
  // Only valid in Prometheus versions 2.27.0 and newer.
  optional uint64 label_limit = 9 [(dev.f110.kubeproto.field) = { go_name: "LabelLimit", api_field_name: "labelLimit", inline: false }];
  // Per-scrape limit on length of labels name that will be accepted for a sample.
  // Only valid in Prometheus versions 2.27.0 and newer.
  optional uint64 label_name_length_limit = 10 [(dev.f110.kubeproto.field) = { go_name: "LabelNameLengthLimit", api_field_name: "labelNameLengthLimit", inline: false }];
  // Per-scrape limit on length of labels value that will be accepted for a sample.
  // Only valid in Prometheus versions 2.27.0 and newer.
  optional uint64 label_value_length_limit = 11 [(dev.f110.kubeproto.field) = { go_name: "LabelValueLengthLimit", api_field_name: "labelValueLengthLimit", inline: false }];
}

message ShardStatus {
  // Identifier of the shard.
  string shard_id = 1 [(dev.f110.kubeproto.field) = { go_name: "ShardID", api_field_name: "shardID", inline: false }];
  // Total number of pods targeted by this shard.
  int32 replicas = 2 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // Total number of non-terminated pods targeted by this shard
  // that have the desired spec.
  int32 updated_replicas = 3 [(dev.f110.kubeproto.field) = { go_name: "UpdatedReplicas", api_field_name: "updatedReplicas", inline: false }];
  // Total number of available pods (ready for at least minReadySeconds)
  // targeted by this shard.
  int32 available_replicas = 4 [(dev.f110.kubeproto.field) = { go_name: "AvailableReplicas", api_field_name: "availableReplicas", inline: false }];
  // Total number of unavailable pods targeted by this shard.
  int32 unavailable_replicas = 5 [(dev.f110.kubeproto.field) = { go_name: "UnavailableReplicas", api_field_name: "unavailableReplicas", inline: false }];
}

message Sigv4 {
  // Region is the AWS region. If blank, the region from the default credentials chain used.
  optional string region = 1 [(dev.f110.kubeproto.field) = { go_name: "Region", api_field_name: "region", inline: false }];
  // AccessKey is the AWS API key. If blank, the environment variable `AWS_ACCESS_KEY_ID` is used.
  optional .k8s.io.api.core.v1.SecretKeySelector access_key = 2 [(dev.f110.kubeproto.field) = { go_name: "AccessKey", api_field_name: "accessKey", inline: false }];
  // SecretKey is the AWS API secret. If blank, the environment variable `AWS_SECRET_ACCESS_KEY` is used.
  optional .k8s.io.api.core.v1.SecretKeySelector secret_key = 3 [(dev.f110.kubeproto.field) = { go_name: "SecretKey", api_field_name: "secretKey", inline: false }];
  // Profile is the named AWS profile used to authenticate.
  optional string profile = 4 [(dev.f110.kubeproto.field) = { go_name: "Profile", api_field_name: "profile", inline: false }];
  // RoleArn is the named AWS profile used to authenticate.
  optional string role_arn = 5 [(dev.f110.kubeproto.field) = { go_name: "RoleArn", api_field_name: "roleArn", inline: false }];
}

message StorageSpec {
  // Deprecated: subPath usage will be disabled by default in a future release, this option will become unnecessary.
  // DisableMountSubPath allows to remove any subPath usage in volume mounts.
  optional bool disable_mount_sub_path = 1 [(dev.f110.kubeproto.field) = { go_name: "DisableMountSubPath", api_field_name: "disableMountSubPath", inline: false }];
  // EmptyDirVolumeSource to be used by the Prometheus StatefulSets. If specified, used in place of any volumeClaimTemplate. More
  // info: https://kubernetes.io/docs/concepts/storage/volumes/#emptydir
  optional .k8s.io.api.core.v1.EmptyDirVolumeSource empty_dir = 2 [(dev.f110.kubeproto.field) = { go_name: "EmptyDir", api_field_name: "emptyDir", inline: false }];
  // EphemeralVolumeSource to be used by the Prometheus StatefulSets.
  // This is a beta field in k8s 1.21, for lower versions, starting with k8s 1.19, it requires enabling the GenericEphemeralVolume feature gate.
  // More info: https://kubernetes.io/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes
  optional .k8s.io.api.core.v1.EphemeralVolumeSource ephemeral = 3 [(dev.f110.kubeproto.field) = { go_name: "Ephemeral", api_field_name: "ephemeral", inline: false }];
  // A PVC spec to be used by the Prometheus StatefulSets.
  optional EmbeddedPersistentVolumeClaim volume_claim_template = 4 [(dev.f110.kubeproto.field) = { go_name: "VolumeClaimTemplate", api_field_name: "volumeClaimTemplate", inline: false }];
}

message TLSConfig {
  SafeTLSConfig safe_tls_config = 1 [(dev.f110.kubeproto.field) = { go_name: "SafeTLSConfig", inline: true }];
  // Path to the CA cert in the Prometheus container to use for the targets.
  optional string c_a_file = 2 [(dev.f110.kubeproto.field) = { go_name: "CAFile", api_field_name: "caFile", inline: false }];
  // Path to the client cert file in the Prometheus container for the targets.
  optional string cert_file = 3 [(dev.f110.kubeproto.field) = { go_name: "CertFile", api_field_name: "certFile", inline: false }];
  // Path to the client key file in the Prometheus container for the targets.
  optional string key_file = 4 [(dev.f110.kubeproto.field) = { go_name: "KeyFile", api_field_name: "keyFile", inline: false }];
}

message TLSConfigValidationError {
}

message ThanosRuler {
  // Specification of the desired behavior of the ThanosRuler cluster. More info:
  // https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  ThanosRulerSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Most recent observed status of the ThanosRuler cluster. Read-only. Not
  // included when requesting from the apiserver, only from the ThanosRuler
  // Operator API itself. More info:
  // https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional ThanosRulerStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ThanosRulerList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of Prometheuses
  repeated ThanosRuler items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ThanosRulerSpec {
  // PodMetadata contains Labels and Annotations gets propagated to the thanos ruler pods.
  optional EmbeddedObjectMetadata pod_metadata = 1 [(dev.f110.kubeproto.field) = { go_name: "PodMetadata", api_field_name: "podMetadata", inline: false }];
  // Thanos container image URL.
  optional string image = 2 [(dev.f110.kubeproto.field) = { go_name: "Image", api_field_name: "image", inline: false }];
  // An optional list of references to secrets in the same namespace
  // to use for pulling thanos images from registries
  // see http://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
  repeated .k8s.io.api.core.v1.LocalObjectReference image_pull_secrets = 3 [(dev.f110.kubeproto.field) = { go_name: "ImagePullSecrets", api_field_name: "imagePullSecrets", inline: false }];
  // When a ThanosRuler deployment is paused, no actions except for deletion
  // will be performed on the underlying objects.
  optional bool paused = 4 [(dev.f110.kubeproto.field) = { go_name: "Paused", api_field_name: "paused", inline: false }];
  // Number of thanos ruler instances to deploy.
  optional int32 replicas = 5 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // Define which Nodes the Pods are scheduled on.
  map<string, string> node_selector = 6 [(dev.f110.kubeproto.field) = { go_name: "NodeSelector", api_field_name: "nodeSelector", inline: false }];
  // Resources defines the resource requirements for single Pods.
  // If not provided, no requests/limits will be set
  optional .k8s.io.api.core.v1.ResourceRequirements resources = 7 [(dev.f110.kubeproto.field) = { go_name: "Resources", api_field_name: "resources", inline: false }];
  // If specified, the pod's scheduling constraints.
  optional .k8s.io.api.core.v1.Affinity affinity = 8 [(dev.f110.kubeproto.field) = { go_name: "Affinity", api_field_name: "affinity", inline: false }];
  // If specified, the pod's tolerations.
  repeated .k8s.io.api.core.v1.Toleration tolerations = 9 [(dev.f110.kubeproto.field) = { go_name: "Tolerations", api_field_name: "tolerations", inline: false }];
  // If specified, the pod's topology spread constraints.
  repeated .k8s.io.api.core.v1.TopologySpreadConstraint topology_spread_constraints = 10 [(dev.f110.kubeproto.field) = { go_name: "TopologySpreadConstraints", api_field_name: "topologySpreadConstraints", inline: false }];
  // SecurityContext holds pod-level security attributes and common container settings.
  // This defaults to the default PodSecurityContext.
  optional .k8s.io.api.core.v1.PodSecurityContext security_context = 11 [(dev.f110.kubeproto.field) = { go_name: "SecurityContext", api_field_name: "securityContext", inline: false }];
  // Priority class assigned to the Pods
  optional string priority_class_name = 12 [(dev.f110.kubeproto.field) = { go_name: "PriorityClassName", api_field_name: "priorityClassName", inline: false }];
  // ServiceAccountName is the name of the ServiceAccount to use to run the
  // Thanos Ruler Pods.
  optional string service_account_name = 13 [(dev.f110.kubeproto.field) = { go_name: "ServiceAccountName", api_field_name: "serviceAccountName", inline: false }];
  // Storage spec to specify how storage shall be used.
  optional StorageSpec storage = 14 [(dev.f110.kubeproto.field) = { go_name: "Storage", api_field_name: "storage", inline: false }];
  // Volumes allows configuration of additional volumes on the output StatefulSet definition. Volumes specified will
  // be appended to other volumes that are generated as a result of StorageSpec objects.
  repeated .k8s.io.api.core.v1.Volume volumes = 15 [(dev.f110.kubeproto.field) = { go_name: "Volumes", api_field_name: "volumes", inline: false }];
  // ObjectStorageConfig configures object storage in Thanos.
  // Alternative to ObjectStorageConfigFile, and lower order priority.
  optional .k8s.io.api.core.v1.SecretKeySelector object_storage_config = 16 [(dev.f110.kubeproto.field) = { go_name: "ObjectStorageConfig", api_field_name: "objectStorageConfig", inline: false }];
  // ObjectStorageConfigFile specifies the path of the object storage configuration file.
  // When used alongside with ObjectStorageConfig, ObjectStorageConfigFile takes precedence.
  optional string object_storage_config_file = 17 [(dev.f110.kubeproto.field) = { go_name: "ObjectStorageConfigFile", api_field_name: "objectStorageConfigFile", inline: false }];
  // ListenLocal makes the Thanos ruler listen on loopback, so that it
  // does not bind against the Pod IP.
  optional bool listen_local = 18 [(dev.f110.kubeproto.field) = { go_name: "ListenLocal", api_field_name: "listenLocal", inline: false }];
  // QueryEndpoints defines Thanos querier endpoints from which to query metrics.
  // Maps to the --query flag of thanos ruler.
  repeated string query_endpoints = 19 [(dev.f110.kubeproto.field) = { go_name: "QueryEndpoints", api_field_name: "queryEndpoints", inline: false }];
  // Define configuration for connecting to thanos query instances.
  // If this is defined, the QueryEndpoints field will be ignored.
  // Maps to the `query.config` CLI argument.
  // Only available with thanos v0.11.0 and higher.
  optional .k8s.io.api.core.v1.SecretKeySelector query_config = 20 [(dev.f110.kubeproto.field) = { go_name: "QueryConfig", api_field_name: "queryConfig", inline: false }];
  // Define URLs to send alerts to Alertmanager.  For Thanos v0.10.0 and higher,
  // AlertManagersConfig should be used instead.  Note: this field will be ignored
  // if AlertManagersConfig is specified.
  // Maps to the `alertmanagers.url` arg.
  repeated string alert_managers_url = 21 [(dev.f110.kubeproto.field) = { go_name: "AlertManagersURL", api_field_name: "alertmanagersUrl", inline: false }];
  // Define configuration for connecting to alertmanager.  Only available with thanos v0.10.0
  // and higher.  Maps to the `alertmanagers.config` arg.
  optional .k8s.io.api.core.v1.SecretKeySelector alert_managers_config = 22 [(dev.f110.kubeproto.field) = { go_name: "AlertManagersConfig", api_field_name: "alertmanagersConfig", inline: false }];
  // A label selector to select which PrometheusRules to mount for alerting and
  // recording.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector rule_selector = 23 [(dev.f110.kubeproto.field) = { go_name: "RuleSelector", api_field_name: "ruleSelector", inline: false }];
  // Namespaces to be selected for Rules discovery. If unspecified, only
  // the same namespace as the ThanosRuler object is in is used.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector rule_namespace_selector = 24 [(dev.f110.kubeproto.field) = { go_name: "RuleNamespaceSelector", api_field_name: "ruleNamespaceSelector", inline: false }];
  // EnforcedNamespaceLabel enforces adding a namespace label of origin for each alert
  // and metric that is user created. The label value will always be the namespace of the object that is
  // being created.
  optional string enforced_namespace_label = 25 [(dev.f110.kubeproto.field) = { go_name: "EnforcedNamespaceLabel", api_field_name: "enforcedNamespaceLabel", inline: false }];
  // List of references to PrometheusRule objects
  // to be excluded from enforcing a namespace label of origin.
  // Applies only if enforcedNamespaceLabel set to true.
  repeated ObjectReference excluded_from_enforcement = 26 [(dev.f110.kubeproto.field) = { go_name: "ExcludedFromEnforcement", api_field_name: "excludedFromEnforcement", inline: false }];
  // PrometheusRulesExcludedFromEnforce - list of Prometheus rules to be excluded from enforcing
  // of adding namespace labels. Works only if enforcedNamespaceLabel set to true.
  // Make sure both ruleNamespace and ruleName are set for each pair
  // Deprecated: use excludedFromEnforcement instead.
  repeated PrometheusRuleExcludeConfig prometheus_rules_excluded_from_enforce = 27 [(dev.f110.kubeproto.field) = { go_name: "PrometheusRulesExcludedFromEnforce", api_field_name: "prometheusRulesExcludedFromEnforce", inline: false }];
  // Log level for ThanosRuler to be configured with.
  optional string log_level = 28 [(dev.f110.kubeproto.field) = { go_name: "LogLevel", api_field_name: "logLevel", inline: false }];
  // Log format for ThanosRuler to be configured with.
  optional string log_format = 29 [(dev.f110.kubeproto.field) = { go_name: "LogFormat", api_field_name: "logFormat", inline: false }];
  // Port name used for the pods and governing service.
  // This defaults to web
  optional string port_name = 30 [(dev.f110.kubeproto.field) = { go_name: "PortName", api_field_name: "portName", inline: false }];
  // Interval between consecutive evaluations.
  string evaluation_interval = 31 [(dev.f110.kubeproto.field) = { go_name: "EvaluationInterval", api_field_name: "evaluationInterval", inline: false }];
  // Time duration ThanosRuler shall retain data for. Default is '24h',
  // and must match the regular expression `[0-9]+(ms|s|m|h|d|w|y)` (milliseconds seconds minutes hours days weeks years).
  string retention = 32 [(dev.f110.kubeproto.field) = { go_name: "Retention", api_field_name: "retention", inline: false }];
  // Containers allows injecting additional containers or modifying operator generated
  // containers. This can be used to allow adding an authentication proxy to a ThanosRuler pod or
  // to change the behavior of an operator generated container. Containers described here modify
  // an operator generated container if they share the same name and modifications are done via a
  // strategic merge patch. The current container names are: `thanos-ruler` and `config-reloader`.
  // Overriding containers is entirely outside the scope of what the maintainers will support and by doing
  // so, you accept that this behaviour may break at any time without notice.
  repeated .k8s.io.api.core.v1.Container containers = 33 [(dev.f110.kubeproto.field) = { go_name: "Containers", api_field_name: "containers", inline: false }];
  // InitContainers allows adding initContainers to the pod definition. Those can be used to e.g.
  // fetch secrets for injection into the ThanosRuler configuration from external sources. Any
  // errors during the execution of an initContainer will lead to a restart of the Pod.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  // Using initContainers for any use case other then secret fetching is entirely outside the scope
  // of what the maintainers will support and by doing so, you accept that this behaviour may break
  // at any time without notice.
  repeated .k8s.io.api.core.v1.Container init_containers = 34 [(dev.f110.kubeproto.field) = { go_name: "InitContainers", api_field_name: "initContainers", inline: false }];
  // TracingConfig configures tracing in Thanos. This is an experimental feature, it may change in any upcoming release in a breaking way.
  optional .k8s.io.api.core.v1.SecretKeySelector tracing_config = 35 [(dev.f110.kubeproto.field) = { go_name: "TracingConfig", api_field_name: "tracingConfig", inline: false }];
  // TracingConfig specifies the path of the tracing configuration file.
  // When used alongside with TracingConfig, TracingConfigFile takes precedence.
  optional string tracing_config_file = 36 [(dev.f110.kubeproto.field) = { go_name: "TracingConfigFile", api_field_name: "tracingConfigFile", inline: false }];
  // Labels configure the external label pairs to ThanosRuler. A default replica label
  // `thanos_ruler_replica` will be always added  as a label with the value of the pod's name and it will be dropped in the alerts.
  map<string, string> labels = 37 [(dev.f110.kubeproto.field) = { go_name: "Labels", api_field_name: "labels", inline: false }];
  // AlertDropLabels configure the label names which should be dropped in ThanosRuler alerts.
  // The replica label `thanos_ruler_replica` will always be dropped in alerts.
  repeated string alert_drop_labels = 38 [(dev.f110.kubeproto.field) = { go_name: "AlertDropLabels", api_field_name: "alertDropLabels", inline: false }];
  // The external URL the Thanos Ruler instances will be available under. This is
  // necessary to generate correct URLs. This is necessary if Thanos Ruler is not
  // served from root of a DNS name.
  optional string external_prefix = 39 [(dev.f110.kubeproto.field) = { go_name: "ExternalPrefix", api_field_name: "externalPrefix", inline: false }];
  // The route prefix ThanosRuler registers HTTP handlers for. This allows thanos UI to be served on a sub-path.
  optional string route_prefix = 40 [(dev.f110.kubeproto.field) = { go_name: "RoutePrefix", api_field_name: "routePrefix", inline: false }];
  // GRPCServerTLSConfig configures the gRPC server from which Thanos Querier reads
  // recorded rule data.
  // Note: Currently only the CAFile, CertFile, and KeyFile fields are supported.
  // Maps to the '--grpc-server-tls-*' CLI args.
  optional TLSConfig g_r_p_c_server_tls_config = 41 [(dev.f110.kubeproto.field) = { go_name: "GRPCServerTLSConfig", api_field_name: "grpcServerTlsConfig", inline: false }];
  // The external Query URL the Thanos Ruler will set in the 'Source' field
  // of all alerts.
  // Maps to the '--alert.query-url' CLI arg.
  optional string alert_query_url = 42 [(dev.f110.kubeproto.field) = { go_name: "AlertQueryURL", api_field_name: "alertQueryUrl", inline: false }];
  // Minimum number of seconds for which a newly created pod should be ready
  // without any of its container crashing for it to be considered available.
  // Defaults to 0 (pod will be considered available as soon as it is ready)
  // This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate.
  optional uint32 min_ready_seconds = 43 [(dev.f110.kubeproto.field) = { go_name: "MinReadySeconds", api_field_name: "minReadySeconds", inline: false }];
  // AlertRelabelConfigs configures alert relabeling in ThanosRuler.
  // Alert relabel configurations must have the form as specified in the official Prometheus documentation:
  // https://prometheus.io/docs/prometheus/latest/configuration/configuration/#alert_relabel_configs
  // Alternative to AlertRelabelConfigFile, and lower order priority.
  optional .k8s.io.api.core.v1.SecretKeySelector alert_relabel_configs = 44 [(dev.f110.kubeproto.field) = { go_name: "AlertRelabelConfigs", api_field_name: "alertRelabelConfigs", inline: false }];
  // AlertRelabelConfigFile specifies the path of the alert relabeling configuration file.
  // When used alongside with AlertRelabelConfigs, alertRelabelConfigFile takes precedence.
  optional string alert_relabel_config_file = 45 [(dev.f110.kubeproto.field) = { go_name: "AlertRelabelConfigFile", api_field_name: "alertRelabelConfigFile", inline: false }];
  // Pods' hostAliases configuration
  repeated HostAlias host_aliases = 46 [(dev.f110.kubeproto.field) = { go_name: "HostAliases", api_field_name: "hostAliases", inline: false }];
}

message ThanosRulerStatus {
  // Represents whether any actions on the underlying managed objects are
  // being performed. Only delete actions will be performed.
  bool paused = 1 [(dev.f110.kubeproto.field) = { go_name: "Paused", api_field_name: "paused", inline: false }];
  // Total number of non-terminated pods targeted by this ThanosRuler deployment
  // (their labels match the selector).
  int32 replicas = 2 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // Total number of non-terminated pods targeted by this ThanosRuler deployment
  // that have the desired version spec.
  int32 updated_replicas = 3 [(dev.f110.kubeproto.field) = { go_name: "UpdatedReplicas", api_field_name: "updatedReplicas", inline: false }];
  // Total number of available pods (ready for at least minReadySeconds)
  // targeted by this ThanosRuler deployment.
  int32 available_replicas = 4 [(dev.f110.kubeproto.field) = { go_name: "AvailableReplicas", api_field_name: "availableReplicas", inline: false }];
  // Total number of unavailable pods targeted by this ThanosRuler deployment.
  int32 unavailable_replicas = 5 [(dev.f110.kubeproto.field) = { go_name: "UnavailableReplicas", api_field_name: "unavailableReplicas", inline: false }];
}

message ThanosSpec {
  // Image if specified has precedence over baseImage, tag and sha
  // combinations. Specifying the version is still necessary to ensure the
  // Prometheus Operator knows what version of Thanos is being
  // configured.
  optional string image = 1 [(dev.f110.kubeproto.field) = { go_name: "Image", api_field_name: "image", inline: false }];
  // Version describes the version of Thanos to use.
  optional string version = 2 [(dev.f110.kubeproto.field) = { go_name: "Version", api_field_name: "version", inline: false }];
  // Tag of Thanos sidecar container image to be deployed. Defaults to the value of `version`.
  // Version is ignored if Tag is set.
  // Deprecated: use 'image' instead.  The image tag can be specified
  // as part of the image URL.
  optional string tag = 3 [(dev.f110.kubeproto.field) = { go_name: "Tag", api_field_name: "tag", inline: false }];
  // SHA of Thanos container image to be deployed. Defaults to the value of `version`.
  // Similar to a tag, but the SHA explicitly deploys an immutable container image.
  // Version and Tag are ignored if SHA is set.
  // Deprecated: use 'image' instead.  The image digest can be specified
  // as part of the image URL.
  optional string s_h_a = 4 [(dev.f110.kubeproto.field) = { go_name: "SHA", api_field_name: "sha", inline: false }];
  // Thanos base image if other than default.
  // Deprecated: use 'image' instead
  optional string base_image = 5 [(dev.f110.kubeproto.field) = { go_name: "BaseImage", api_field_name: "baseImage", inline: false }];
  // Resources defines the resource requirements for the Thanos sidecar.
  // If not provided, no requests/limits will be set
  optional .k8s.io.api.core.v1.ResourceRequirements resources = 6 [(dev.f110.kubeproto.field) = { go_name: "Resources", api_field_name: "resources", inline: false }];
  // ObjectStorageConfig configures object storage in Thanos.
  // Alternative to ObjectStorageConfigFile, and lower order priority.
  optional .k8s.io.api.core.v1.SecretKeySelector object_storage_config = 7 [(dev.f110.kubeproto.field) = { go_name: "ObjectStorageConfig", api_field_name: "objectStorageConfig", inline: false }];
  // ObjectStorageConfigFile specifies the path of the object storage configuration file.
  // When used alongside with ObjectStorageConfig, ObjectStorageConfigFile takes precedence.
  optional string object_storage_config_file = 8 [(dev.f110.kubeproto.field) = { go_name: "ObjectStorageConfigFile", api_field_name: "objectStorageConfigFile", inline: false }];
  // ListenLocal makes the Thanos sidecar listen on loopback, so that it
  // does not bind against the Pod IP.
  optional bool listen_local = 9 [(dev.f110.kubeproto.field) = { go_name: "ListenLocal", api_field_name: "listenLocal", inline: false }];
  // TracingConfig configures tracing in Thanos. This is an experimental feature, it may change in any upcoming release in a breaking way.
  optional .k8s.io.api.core.v1.SecretKeySelector tracing_config = 10 [(dev.f110.kubeproto.field) = { go_name: "TracingConfig", api_field_name: "tracingConfig", inline: false }];
  // TracingConfig specifies the path of the tracing configuration file.
  // When used alongside with TracingConfig, TracingConfigFile takes precedence.
  optional string tracing_config_file = 11 [(dev.f110.kubeproto.field) = { go_name: "TracingConfigFile", api_field_name: "tracingConfigFile", inline: false }];
  // GRPCServerTLSConfig configures the gRPC server from which Thanos Querier reads
  // recorded rule data.
  // Note: Currently only the CAFile, CertFile, and KeyFile fields are supported.
  // Maps to the '--grpc-server-tls-*' CLI args.
  optional TLSConfig g_r_p_c_server_tls_config = 12 [(dev.f110.kubeproto.field) = { go_name: "GRPCServerTLSConfig", api_field_name: "grpcServerTlsConfig", inline: false }];
  // LogLevel for Thanos sidecar to be configured with.
  optional string log_level = 13 [(dev.f110.kubeproto.field) = { go_name: "LogLevel", api_field_name: "logLevel", inline: false }];
  // LogFormat for Thanos sidecar to be configured with.
  optional string log_format = 14 [(dev.f110.kubeproto.field) = { go_name: "LogFormat", api_field_name: "logFormat", inline: false }];
  // MinTime for Thanos sidecar to be configured with. Option can be a constant time in RFC3339 format or time duration relative to current time, such as -1d or 2h45m. Valid duration units are ms, s, m, h, d, w, y.
  optional string min_time = 15 [(dev.f110.kubeproto.field) = { go_name: "MinTime", api_field_name: "minTime", inline: false }];
  // ReadyTimeout is the maximum time Thanos sidecar will wait for Prometheus to start. Eg 10m
  string ready_timeout = 16 [(dev.f110.kubeproto.field) = { go_name: "ReadyTimeout", api_field_name: "readyTimeout", inline: false }];
  // VolumeMounts allows configuration of additional VolumeMounts on the output StatefulSet definition.
  // VolumeMounts specified will be appended to other VolumeMounts in the thanos-sidecar container.
  repeated .k8s.io.api.core.v1.VolumeMount volume_mounts = 17 [(dev.f110.kubeproto.field) = { go_name: "VolumeMounts", api_field_name: "volumeMounts", inline: false }];
  // AdditionalArgs allows setting additional arguments for the Thanos container.
  // The arguments are passed as-is to the Thanos container which may cause issues
  // if they are invalid or not supporeted the given Thanos version.
  // In case of an argument conflict (e.g. an argument which is already set by the
  // operator itself) or when providing an invalid argument the reconciliation will
  // fail and an error will be logged.
  repeated Argument additional_args = 18 [(dev.f110.kubeproto.field) = { go_name: "AdditionalArgs", api_field_name: "additionalArgs", inline: false }];
}

message WebConfigFileFields {
  // Defines the TLS parameters for HTTPS.
  optional WebTLSConfig tls_config = 1 [(dev.f110.kubeproto.field) = { go_name: "TLSConfig", api_field_name: "tlsConfig", inline: false }];
  // Defines HTTP parameters for web server.
  optional WebHTTPConfig http_config = 2 [(dev.f110.kubeproto.field) = { go_name: "HTTPConfig", api_field_name: "httpConfig", inline: false }];
}

message WebHTTPConfig {
  // Enable HTTP/2 support. Note that HTTP/2 is only supported with TLS.
  // When TLSConfig is not configured, HTTP/2 will be disabled.
  // Whenever the value of the field changes, a rolling update will be triggered.
  optional bool http_2 = 1 [(dev.f110.kubeproto.field) = { go_name: "HTTP2", api_field_name: "http2", inline: false }];
  // List of headers that can be added to HTTP responses.
  optional WebHTTPHeaders headers = 2 [(dev.f110.kubeproto.field) = { go_name: "Headers", api_field_name: "headers", inline: false }];
}

message WebHTTPHeaders {
  // Set the Content-Security-Policy header to HTTP responses.
  // Unset if blank.
  optional string content_security_policy = 1 [(dev.f110.kubeproto.field) = { go_name: "ContentSecurityPolicy", api_field_name: "contentSecurityPolicy", inline: false }];
  // Set the X-Frame-Options header to HTTP responses.
  // Unset if blank. Accepted values are deny and sameorigin.
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
  optional string x_frame_options = 2 [(dev.f110.kubeproto.field) = { go_name: "XFrameOptions", api_field_name: "xFrameOptions", inline: false }];
  // Set the X-Content-Type-Options header to HTTP responses.
  // Unset if blank. Accepted value is nosniff.
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
  optional string x_content_type_options = 3 [(dev.f110.kubeproto.field) = { go_name: "XContentTypeOptions", api_field_name: "xContentTypeOptions", inline: false }];
  // Set the X-XSS-Protection header to all responses.
  // Unset if blank.
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection
  optional string x_x_s_s_protection = 4 [(dev.f110.kubeproto.field) = { go_name: "XXSSProtection", api_field_name: "xXSSProtection", inline: false }];
  // Set the Strict-Transport-Security header to HTTP responses.
  // Unset if blank.
  // Please make sure that you use this with care as this header might force
  // browsers to load Prometheus and the other applications hosted on the same
  // domain and subdomains over HTTPS.
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
  optional string strict_transport_security = 5 [(dev.f110.kubeproto.field) = { go_name: "StrictTransportSecurity", api_field_name: "strictTransportSecurity", inline: false }];
}

message WebTLSConfig {
  // Secret containing the TLS key for the server.
  .k8s.io.api.core.v1.SecretKeySelector key_secret = 1 [(dev.f110.kubeproto.field) = { go_name: "KeySecret", api_field_name: "keySecret", inline: false }];
  // Contains the TLS certificate for the server.
  SecretOrConfigMap cert = 2 [(dev.f110.kubeproto.field) = { go_name: "Cert", api_field_name: "cert", inline: false }];
  // Server policy for client authentication. Maps to ClientAuth Policies.
  // For more detail on clientAuth options:
  // https://golang.org/pkg/crypto/tls/#ClientAuthType
  optional string client_auth_type = 3 [(dev.f110.kubeproto.field) = { go_name: "ClientAuthType", api_field_name: "clientAuthType", inline: false }];
  // Contains the CA certificate for client certificate authentication to the server.
  optional SecretOrConfigMap client_c_a = 4 [(dev.f110.kubeproto.field) = { go_name: "ClientCA", api_field_name: "client_ca", inline: false }];
  // Minimum TLS version that is acceptable. Defaults to TLS12.
  optional string min_version = 5 [(dev.f110.kubeproto.field) = { go_name: "MinVersion", api_field_name: "minVersion", inline: false }];
  // Maximum TLS version that is acceptable. Defaults to TLS13.
  optional string max_version = 6 [(dev.f110.kubeproto.field) = { go_name: "MaxVersion", api_field_name: "maxVersion", inline: false }];
  // List of supported cipher suites for TLS versions up to TLS 1.2. If empty,
  // Go default cipher suites are used. Available cipher suites are documented
  // in the go documentation: https://golang.org/pkg/crypto/tls/#pkg-constants
  repeated string cipher_suites = 7 [(dev.f110.kubeproto.field) = { go_name: "CipherSuites", api_field_name: "cipherSuites", inline: false }];
  // Controls whether the server selects the
  // client's most preferred cipher suite, or the server's most preferred
  // cipher suite. If true then the server's preference, as expressed in
  // the order of elements in cipherSuites, is used.
  optional bool prefer_server_cipher_suites = 8 [(dev.f110.kubeproto.field) = { go_name: "PreferServerCipherSuites", api_field_name: "preferServerCipherSuites", inline: false }];
  // Elliptic curves that will be used in an ECDHE handshake, in preference
  // order. Available curves are documented in the go documentation:
  // https://golang.org/pkg/crypto/tls/#CurveID
  repeated string curve_preferences = 9 [(dev.f110.kubeproto.field) = { go_name: "CurvePreferences", api_field_name: "curvePreferences", inline: false }];
}

message WebTLSConfigError {
}
