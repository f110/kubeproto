// Generated by: gen-go-to-protobuf
syntax = "proto3";
package k8s.io.api.core.v1;
option  go_package              = "k8s.io/api/core/v1";
option (dev.f110.kubeproto.k8s) = {
  version: "v1",
};
option (dev.f110.kubeproto.kubeproto_go_package) = "go.f110.dev/kubeproto/go/apis/corev1";

import "kube.proto";
import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";

enum AzureDataDiskCachingMode {
  AZURE_DATA_DISK_CACHING_MODE_NONE       = 0 [(dev.f110.kubeproto.value) = { value: "None" }];
  AZURE_DATA_DISK_CACHING_MODE_READ_ONLY  = 1;
  AZURE_DATA_DISK_CACHING_MODE_READ_WRITE = 2;
}

enum AzureDataDiskKind {
  AZURE_DATA_DISK_KIND_SHARED    = 0 [(dev.f110.kubeproto.value) = { value: "Shared" }];
  AZURE_DATA_DISK_KIND_DEDICATED = 1 [(dev.f110.kubeproto.value) = { value: "Dedicated" }];
  AZURE_DATA_DISK_KIND_MANAGED   = 2 [(dev.f110.kubeproto.value) = { value: "Managed" }];
}

enum ComponentConditionType {
  COMPONENT_CONDITION_TYPE_HEALTHY = 0 [(dev.f110.kubeproto.value) = { value: "Healthy" }];
}

enum ConditionStatus {
  CONDITION_STATUS_TRUE    = 0 [(dev.f110.kubeproto.value) = { value: "True" }];
  CONDITION_STATUS_FALSE   = 1 [(dev.f110.kubeproto.value) = { value: "False" }];
  CONDITION_STATUS_UNKNOWN = 2 [(dev.f110.kubeproto.value) = { value: "Unknown" }];
}

enum DNSPolicy {
  DNS_POLICY_CLUSTER_FIRST_WITH_HOST_NET = 0;
  DNS_POLICY_CLUSTER_FIRST               = 1;
  DNS_POLICY_DEFAULT                     = 2 [(dev.f110.kubeproto.value) = { value: "Default" }];
  DNS_POLICY_NONE                        = 3 [(dev.f110.kubeproto.value) = { value: "None" }];
}

enum FinalizerName {
  FINALIZER_NAME_KUBERNETES = 0 [(dev.f110.kubeproto.value) = { value: "kubernetes" }];
}

enum HostPathType {
  HOST_PATH_TYPE_HOST_PATH_UNSET     = 0 [(dev.f110.kubeproto.value) = { value: "" }];
  HOST_PATH_TYPE_DIRECTORY_OR_CREATE = 1;
  HOST_PATH_TYPE_DIRECTORY           = 2 [(dev.f110.kubeproto.value) = { value: "Directory" }];
  HOST_PATH_TYPE_FILE_OR_CREATE      = 3;
  HOST_PATH_TYPE_FILE                = 4 [(dev.f110.kubeproto.value) = { value: "File" }];
  HOST_PATH_TYPE_SOCKET              = 5 [(dev.f110.kubeproto.value) = { value: "Socket" }];
  HOST_PATH_TYPE_CHAR_DEVICE         = 6;
  HOST_PATH_TYPE_BLOCK_DEVICE        = 7;
}

enum IPFamily {
  IP_FAMILY_IP_V4 = 0 [(dev.f110.kubeproto.value) = { value: "IPv4" }];
  IP_FAMILY_IP_V6 = 1 [(dev.f110.kubeproto.value) = { value: "IPv6" }];
}

enum IPFamilyPolicy {
  IP_FAMILY_POLICY_SINGLE_STACK       = 0;
  IP_FAMILY_POLICY_PREFER_DUAL_STACK  = 1;
  IP_FAMILY_POLICY_REQUIRE_DUAL_STACK = 2;
}

enum LimitType {
  LIMIT_TYPE_POD                     = 0 [(dev.f110.kubeproto.value) = { value: "Pod" }];
  LIMIT_TYPE_CONTAINER               = 1 [(dev.f110.kubeproto.value) = { value: "Container" }];
  LIMIT_TYPE_PERSISTENT_VOLUME_CLAIM = 2;
}

enum MountPropagationMode {
  MOUNT_PROPAGATION_MODE_NONE              = 0 [(dev.f110.kubeproto.value) = { value: "None" }];
  MOUNT_PROPAGATION_MODE_HOST_TO_CONTAINER = 1;
  MOUNT_PROPAGATION_MODE_BIDIRECTIONAL     = 2 [(dev.f110.kubeproto.value) = { value: "Bidirectional" }];
}

enum NamespaceConditionType {
  NAMESPACE_CONDITION_TYPE_NAMESPACE_DELETION_DISCOVERY_FAILURE             = 0;
  NAMESPACE_CONDITION_TYPE_NAMESPACE_DELETION_CONTENT_FAILURE               = 1;
  NAMESPACE_CONDITION_TYPE_NAMESPACE_DELETION_GROUP_VERSION_PARSING_FAILURE = 2;
  NAMESPACE_CONDITION_TYPE_NAMESPACE_CONTENT_REMAINING                      = 3;
  NAMESPACE_CONDITION_TYPE_NAMESPACE_FINALIZERS_REMAINING                   = 4;
}

enum NamespacePhase {
  NAMESPACE_PHASE_ACTIVE      = 0 [(dev.f110.kubeproto.value) = { value: "Active" }];
  NAMESPACE_PHASE_TERMINATING = 1 [(dev.f110.kubeproto.value) = { value: "Terminating" }];
}

enum NodeAddressType {
  NODE_ADDRESS_TYPE_HOSTNAME     = 0 [(dev.f110.kubeproto.value) = { value: "Hostname" }];
  NODE_ADDRESS_TYPE_INTERNAL_IP  = 1 [(dev.f110.kubeproto.value) = { value: "InternalIP" }];
  NODE_ADDRESS_TYPE_EXTERNAL_IP  = 2 [(dev.f110.kubeproto.value) = { value: "ExternalIP" }];
  NODE_ADDRESS_TYPE_INTERNAL_DNS = 3 [(dev.f110.kubeproto.value) = { value: "InternalDNS" }];
  NODE_ADDRESS_TYPE_EXTERNAL_DNS = 4 [(dev.f110.kubeproto.value) = { value: "ExternalDNS" }];
}

enum NodeConditionType {
  NODE_CONDITION_TYPE_READY               = 0 [(dev.f110.kubeproto.value) = { value: "Ready" }];
  NODE_CONDITION_TYPE_MEMORY_PRESSURE     = 1;
  NODE_CONDITION_TYPE_DISK_PRESSURE       = 2;
  NODE_CONDITION_TYPE_PID_PRESSURE        = 3 [(dev.f110.kubeproto.value) = { value: "PIDPressure" }];
  NODE_CONDITION_TYPE_NETWORK_UNAVAILABLE = 4;
}

enum NodeInclusionPolicy {
  NODE_INCLUSION_POLICY_IGNORE = 0 [(dev.f110.kubeproto.value) = { value: "Ignore" }];
  NODE_INCLUSION_POLICY_HONOR  = 1 [(dev.f110.kubeproto.value) = { value: "Honor" }];
}

enum NodePhase {
  NODE_PHASE_PENDING    = 0 [(dev.f110.kubeproto.value) = { value: "Pending" }];
  NODE_PHASE_RUNNING    = 1 [(dev.f110.kubeproto.value) = { value: "Running" }];
  NODE_PHASE_TERMINATED = 2 [(dev.f110.kubeproto.value) = { value: "Terminated" }];
}

enum NodeSelectorOperator {
  NODE_SELECTOR_OPERATOR_IN             = 0 [(dev.f110.kubeproto.value) = { value: "In" }];
  NODE_SELECTOR_OPERATOR_NOT_IN         = 1;
  NODE_SELECTOR_OPERATOR_EXISTS         = 2 [(dev.f110.kubeproto.value) = { value: "Exists" }];
  NODE_SELECTOR_OPERATOR_DOES_NOT_EXIST = 3;
  NODE_SELECTOR_OPERATOR_GT             = 4 [(dev.f110.kubeproto.value) = { value: "Gt" }];
  NODE_SELECTOR_OPERATOR_LT             = 5 [(dev.f110.kubeproto.value) = { value: "Lt" }];
}

enum OSName {
  OS_NAME_LINUX   = 0 [(dev.f110.kubeproto.value) = { value: "linux" }];
  OS_NAME_WINDOWS = 1 [(dev.f110.kubeproto.value) = { value: "windows" }];
}

enum PersistentVolumeAccessMode {
  PERSISTENT_VOLUME_ACCESS_MODE_READ_WRITE_ONCE     = 0;
  PERSISTENT_VOLUME_ACCESS_MODE_READ_ONLY_MANY      = 1;
  PERSISTENT_VOLUME_ACCESS_MODE_READ_WRITE_MANY     = 2;
  PERSISTENT_VOLUME_ACCESS_MODE_READ_WRITE_ONCE_POD = 3;
}

enum PersistentVolumeClaimConditionType {
  PERSISTENT_VOLUME_CLAIM_CONDITION_TYPE_RESIZING                   = 0 [(dev.f110.kubeproto.value) = { value: "Resizing" }];
  PERSISTENT_VOLUME_CLAIM_CONDITION_TYPE_FILE_SYSTEM_RESIZE_PENDING = 1;
}

enum PersistentVolumeClaimPhase {
  PERSISTENT_VOLUME_CLAIM_PHASE_PENDING = 0 [(dev.f110.kubeproto.value) = { value: "Pending" }];
  PERSISTENT_VOLUME_CLAIM_PHASE_BOUND   = 1 [(dev.f110.kubeproto.value) = { value: "Bound" }];
  PERSISTENT_VOLUME_CLAIM_PHASE_LOST    = 2 [(dev.f110.kubeproto.value) = { value: "Lost" }];
}

enum PersistentVolumeClaimResizeStatus {
  PERSISTENT_VOLUME_CLAIM_RESIZE_STATUS_PERSISTENT_VOLUME_CLAIM_NO_EXPANSION_IN_PROGRESS = 0 [(dev.f110.kubeproto.value) = { value: "" }];
  PERSISTENT_VOLUME_CLAIM_RESIZE_STATUS_CONTROLLER_EXPANSION_IN_PROGRESS                 = 1;
  PERSISTENT_VOLUME_CLAIM_RESIZE_STATUS_CONTROLLER_EXPANSION_FAILED                      = 2;
  PERSISTENT_VOLUME_CLAIM_RESIZE_STATUS_NODE_EXPANSION_PENDING                           = 3;
  PERSISTENT_VOLUME_CLAIM_RESIZE_STATUS_NODE_EXPANSION_IN_PROGRESS                       = 4;
  PERSISTENT_VOLUME_CLAIM_RESIZE_STATUS_NODE_EXPANSION_FAILED                            = 5;
}

enum PersistentVolumeMode {
  PERSISTENT_VOLUME_MODE_BLOCK      = 0 [(dev.f110.kubeproto.value) = { value: "Block" }];
  PERSISTENT_VOLUME_MODE_FILESYSTEM = 1 [(dev.f110.kubeproto.value) = { value: "Filesystem" }];
}

enum PersistentVolumePhase {
  PERSISTENT_VOLUME_PHASE_PENDING   = 0 [(dev.f110.kubeproto.value) = { value: "Pending" }];
  PERSISTENT_VOLUME_PHASE_AVAILABLE = 1 [(dev.f110.kubeproto.value) = { value: "Available" }];
  PERSISTENT_VOLUME_PHASE_BOUND     = 2 [(dev.f110.kubeproto.value) = { value: "Bound" }];
  PERSISTENT_VOLUME_PHASE_RELEASED  = 3 [(dev.f110.kubeproto.value) = { value: "Released" }];
  PERSISTENT_VOLUME_PHASE_FAILED    = 4 [(dev.f110.kubeproto.value) = { value: "Failed" }];
}

enum PersistentVolumeReclaimPolicy {
  PERSISTENT_VOLUME_RECLAIM_POLICY_RECYCLE = 0 [(dev.f110.kubeproto.value) = { value: "Recycle" }];
  PERSISTENT_VOLUME_RECLAIM_POLICY_DELETE  = 1 [(dev.f110.kubeproto.value) = { value: "Delete" }];
  PERSISTENT_VOLUME_RECLAIM_POLICY_RETAIN  = 2 [(dev.f110.kubeproto.value) = { value: "Retain" }];
}

enum PodConditionType {
  POD_CONDITION_TYPE_CONTAINERS_READY  = 0;
  POD_CONDITION_TYPE_INITIALIZED       = 1 [(dev.f110.kubeproto.value) = { value: "Initialized" }];
  POD_CONDITION_TYPE_READY             = 2 [(dev.f110.kubeproto.value) = { value: "Ready" }];
  POD_CONDITION_TYPE_POD_SCHEDULED     = 3;
  POD_CONDITION_TYPE_DISRUPTION_TARGET = 4;
}

enum PodFSGroupChangePolicy {
  POD_FS_GROUP_CHANGE_POLICY_ON_ROOT_MISMATCH = 0;
  POD_FS_GROUP_CHANGE_POLICY_ALWAYS           = 1 [(dev.f110.kubeproto.value) = { value: "Always" }];
}

enum PodPhase {
  POD_PHASE_PENDING   = 0 [(dev.f110.kubeproto.value) = { value: "Pending" }];
  POD_PHASE_RUNNING   = 1 [(dev.f110.kubeproto.value) = { value: "Running" }];
  POD_PHASE_SUCCEEDED = 2 [(dev.f110.kubeproto.value) = { value: "Succeeded" }];
  POD_PHASE_FAILED    = 3 [(dev.f110.kubeproto.value) = { value: "Failed" }];
  POD_PHASE_UNKNOWN   = 4 [(dev.f110.kubeproto.value) = { value: "Unknown" }];
}

enum PodQOSClass {
  POD_QOS_CLASS_GUARANTEED  = 0 [(dev.f110.kubeproto.value) = { value: "Guaranteed" }];
  POD_QOS_CLASS_BURSTABLE   = 1 [(dev.f110.kubeproto.value) = { value: "Burstable" }];
  POD_QOS_CLASS_BEST_EFFORT = 2;
}

enum PodResizeStatus {
  POD_RESIZE_STATUS_PROPOSED    = 0 [(dev.f110.kubeproto.value) = { value: "Proposed" }];
  POD_RESIZE_STATUS_IN_PROGRESS = 1;
  POD_RESIZE_STATUS_DEFERRED    = 2 [(dev.f110.kubeproto.value) = { value: "Deferred" }];
  POD_RESIZE_STATUS_INFEASIBLE  = 3 [(dev.f110.kubeproto.value) = { value: "Infeasible" }];
}

enum PreemptionPolicy {
  PREEMPTION_POLICY_PREEMPT_LOWER_PRIORITY = 0;
  PREEMPTION_POLICY_NEVER                  = 1 [(dev.f110.kubeproto.value) = { value: "Never" }];
}

enum ProcMountType {
  PROC_MOUNT_TYPE_DEFAULT  = 0 [(dev.f110.kubeproto.value) = { value: "Default" }];
  PROC_MOUNT_TYPE_UNMASKED = 1 [(dev.f110.kubeproto.value) = { value: "Unmasked" }];
}

enum Protocol {
  PROTOCOL_TCP  = 0;
  PROTOCOL_UDP  = 1;
  PROTOCOL_SCTP = 2;
}

enum PullPolicy {
  PULL_POLICY_ALWAYS         = 0 [(dev.f110.kubeproto.value) = { value: "Always" }];
  PULL_POLICY_NEVER          = 1 [(dev.f110.kubeproto.value) = { value: "Never" }];
  PULL_POLICY_IF_NOT_PRESENT = 2;
}

enum ReplicationControllerConditionType {
  REPLICATION_CONTROLLER_CONDITION_TYPE_REPLICA_FAILURE = 0;
}

enum ResourceName {
  RESOURCE_NAME_CPU                        = 0 [(dev.f110.kubeproto.value) = { value: "cpu" }];
  RESOURCE_NAME_MEMORY                     = 1 [(dev.f110.kubeproto.value) = { value: "memory" }];
  RESOURCE_NAME_STORAGE                    = 2 [(dev.f110.kubeproto.value) = { value: "storage" }];
  RESOURCE_NAME_EPHEMERAL_STORAGE          = 3 [(dev.f110.kubeproto.value) = { value: "ephemeral-storage" }];
  RESOURCE_NAME_PODS                       = 4 [(dev.f110.kubeproto.value) = { value: "pods" }];
  RESOURCE_NAME_SERVICES                   = 5 [(dev.f110.kubeproto.value) = { value: "services" }];
  RESOURCE_NAME_REPLICATIONCONTROLLERS     = 6 [(dev.f110.kubeproto.value) = { value: "replicationcontrollers" }];
  RESOURCE_NAME_RESOURCEQUOTAS             = 7 [(dev.f110.kubeproto.value) = { value: "resourcequotas" }];
  RESOURCE_NAME_SECRETS                    = 8 [(dev.f110.kubeproto.value) = { value: "secrets" }];
  RESOURCE_NAME_CONFIGMAPS                 = 9 [(dev.f110.kubeproto.value) = { value: "configmaps" }];
  RESOURCE_NAME_PERSISTENTVOLUMECLAIMS     = 10 [(dev.f110.kubeproto.value) = { value: "persistentvolumeclaims" }];
  RESOURCE_NAME_SERVICES_NODEPORTS         = 11 [(dev.f110.kubeproto.value) = { value: "services.nodeports" }];
  RESOURCE_NAME_SERVICES_LOADBALANCERS     = 12 [(dev.f110.kubeproto.value) = { value: "services.loadbalancers" }];
  RESOURCE_NAME_REQUESTS_CPU               = 13 [(dev.f110.kubeproto.value) = { value: "requests.cpu" }];
  RESOURCE_NAME_REQUESTS_MEMORY            = 14 [(dev.f110.kubeproto.value) = { value: "requests.memory" }];
  RESOURCE_NAME_REQUESTS_STORAGE           = 15 [(dev.f110.kubeproto.value) = { value: "requests.storage" }];
  RESOURCE_NAME_REQUESTS_EPHEMERAL_STORAGE = 16 [(dev.f110.kubeproto.value) = { value: "requests.ephemeral-storage" }];
  RESOURCE_NAME_LIMITS_CPU                 = 17 [(dev.f110.kubeproto.value) = { value: "limits.cpu" }];
  RESOURCE_NAME_LIMITS_MEMORY              = 18 [(dev.f110.kubeproto.value) = { value: "limits.memory" }];
  RESOURCE_NAME_LIMITS_EPHEMERAL_STORAGE   = 19 [(dev.f110.kubeproto.value) = { value: "limits.ephemeral-storage" }];
}

enum ResourceQuotaScope {
  RESOURCE_QUOTA_SCOPE_TERMINATING                  = 0 [(dev.f110.kubeproto.value) = { value: "Terminating" }];
  RESOURCE_QUOTA_SCOPE_NOT_TERMINATING              = 1;
  RESOURCE_QUOTA_SCOPE_BEST_EFFORT                  = 2;
  RESOURCE_QUOTA_SCOPE_NOT_BEST_EFFORT              = 3;
  RESOURCE_QUOTA_SCOPE_PRIORITY_CLASS               = 4;
  RESOURCE_QUOTA_SCOPE_CROSS_NAMESPACE_POD_AFFINITY = 5;
}

enum ResourceResizeRestartPolicy {
  RESOURCE_RESIZE_RESTART_POLICY_NOT_REQUIRED      = 0;
  RESOURCE_RESIZE_RESTART_POLICY_RESTART_CONTAINER = 1;
}

enum RestartPolicy {
  RESTART_POLICY_ALWAYS     = 0 [(dev.f110.kubeproto.value) = { value: "Always" }];
  RESTART_POLICY_ON_FAILURE = 1;
  RESTART_POLICY_NEVER      = 2 [(dev.f110.kubeproto.value) = { value: "Never" }];
}

enum ScopeSelectorOperator {
  SCOPE_SELECTOR_OPERATOR_IN             = 0 [(dev.f110.kubeproto.value) = { value: "In" }];
  SCOPE_SELECTOR_OPERATOR_NOT_IN         = 1;
  SCOPE_SELECTOR_OPERATOR_EXISTS         = 2 [(dev.f110.kubeproto.value) = { value: "Exists" }];
  SCOPE_SELECTOR_OPERATOR_DOES_NOT_EXIST = 3;
}

enum SeccompProfileType {
  SECCOMP_PROFILE_TYPE_UNCONFINED      = 0 [(dev.f110.kubeproto.value) = { value: "Unconfined" }];
  SECCOMP_PROFILE_TYPE_RUNTIME_DEFAULT = 1;
  SECCOMP_PROFILE_TYPE_LOCALHOST       = 2 [(dev.f110.kubeproto.value) = { value: "Localhost" }];
}

enum SecretType {
  SECRET_TYPE_OPAQUE                              = 0 [(dev.f110.kubeproto.value) = { value: "Opaque" }];
  SECRET_TYPE_KUBERNETES_IO_SERVICE_ACCOUNT_TOKEN = 1 [(dev.f110.kubeproto.value) = { value: "kubernetes.io/service-account-token" }];
  SECRET_TYPE_KUBERNETES_IO_DOCKERCFG             = 2 [(dev.f110.kubeproto.value) = { value: "kubernetes.io/dockercfg" }];
  SECRET_TYPE_KUBERNETES_IO_DOCKERCONFIGJSON      = 3 [(dev.f110.kubeproto.value) = { value: "kubernetes.io/dockerconfigjson" }];
  SECRET_TYPE_KUBERNETES_IO_BASIC_AUTH            = 4 [(dev.f110.kubeproto.value) = { value: "kubernetes.io/basic-auth" }];
  SECRET_TYPE_KUBERNETES_IO_SSH_AUTH              = 5 [(dev.f110.kubeproto.value) = { value: "kubernetes.io/ssh-auth" }];
  SECRET_TYPE_KUBERNETES_IO_TLS                   = 6 [(dev.f110.kubeproto.value) = { value: "kubernetes.io/tls" }];
  SECRET_TYPE_BOOTSTRAP_KUBERNETES_IO_TOKEN       = 7 [(dev.f110.kubeproto.value) = { value: "bootstrap.kubernetes.io/token" }];
}

enum ServiceAffinity {
  SERVICE_AFFINITY_CLIENT_IP = 0 [(dev.f110.kubeproto.value) = { value: "ClientIP" }];
  SERVICE_AFFINITY_NONE      = 1 [(dev.f110.kubeproto.value) = { value: "None" }];
}

enum ServiceExternalTrafficPolicy {
  SERVICE_EXTERNAL_TRAFFIC_POLICY_CLUSTER = 0 [(dev.f110.kubeproto.value) = { value: "Cluster" }];
  SERVICE_EXTERNAL_TRAFFIC_POLICY_LOCAL   = 1 [(dev.f110.kubeproto.value) = { value: "Local" }];
}

enum ServiceInternalTrafficPolicy {
  SERVICE_INTERNAL_TRAFFIC_POLICY_CLUSTER = 0 [(dev.f110.kubeproto.value) = { value: "Cluster" }];
  SERVICE_INTERNAL_TRAFFIC_POLICY_LOCAL   = 1 [(dev.f110.kubeproto.value) = { value: "Local" }];
}

enum ServiceType {
  SERVICE_TYPE_CLUSTER_IP    = 0 [(dev.f110.kubeproto.value) = { value: "ClusterIP" }];
  SERVICE_TYPE_NODE_PORT     = 1;
  SERVICE_TYPE_LOAD_BALANCER = 2;
  SERVICE_TYPE_EXTERNAL_NAME = 3;
}

enum StorageMedium {
  STORAGE_MEDIUM_DEFAULT    = 0 [(dev.f110.kubeproto.value) = { value: "" }];
  STORAGE_MEDIUM_MEMORY     = 1 [(dev.f110.kubeproto.value) = { value: "Memory" }];
  STORAGE_MEDIUM_HUGE_PAGES = 2;
}

enum TaintEffect {
  TAINT_EFFECT_NO_SCHEDULE        = 0;
  TAINT_EFFECT_PREFER_NO_SCHEDULE = 1;
  TAINT_EFFECT_NO_EXECUTE         = 2;
}

enum TerminationMessagePolicy {
  TERMINATION_MESSAGE_POLICY_FILE                      = 0 [(dev.f110.kubeproto.value) = { value: "File" }];
  TERMINATION_MESSAGE_POLICY_FALLBACK_TO_LOGS_ON_ERROR = 1;
}

enum TolerationOperator {
  TOLERATION_OPERATOR_EXISTS = 0 [(dev.f110.kubeproto.value) = { value: "Exists" }];
  TOLERATION_OPERATOR_EQUAL  = 1 [(dev.f110.kubeproto.value) = { value: "Equal" }];
}

enum URIScheme {
  URI_SCHEME_HTTP  = 0;
  URI_SCHEME_HTTPS = 1;
}

enum UnsatisfiableConstraintAction {
  UNSATISFIABLE_CONSTRAINT_ACTION_DO_NOT_SCHEDULE = 0;
  UNSATISFIABLE_CONSTRAINT_ACTION_SCHEDULE_ANYWAY = 1;
}

message AWSElasticBlockStoreVolumeSource {
  // volumeID is unique ID of the persistent disk resource in AWS (Amazon EBS volume).
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  string volume_id = 1 [(dev.f110.kubeproto.field) = { go_name: "VolumeID", api_field_name: "volumeID", inline: false }];
  // fsType is the filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  optional string fs_type = 2 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // partition is the partition in the volume that you want to mount.
  // If omitted, the default is to mount by volume name.
  // Examples: For volume /dev/sda1, you specify the partition as "1".
  // Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  optional int32 partition = 3 [(dev.f110.kubeproto.field) = { go_name: "Partition", api_field_name: "partition", inline: false }];
  // readOnly value true will force the readOnly setting in VolumeMounts.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  optional bool read_only = 4 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
}

message Affinity {
  // Describes node affinity scheduling rules for the pod.
  optional NodeAffinity node_affinity = 1 [(dev.f110.kubeproto.field) = { go_name: "NodeAffinity", api_field_name: "nodeAffinity", inline: false }];
  // Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
  optional PodAffinity pod_affinity = 2 [(dev.f110.kubeproto.field) = { go_name: "PodAffinity", api_field_name: "podAffinity", inline: false }];
  // Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
  optional PodAntiAffinity pod_anti_affinity = 3 [(dev.f110.kubeproto.field) = { go_name: "PodAntiAffinity", api_field_name: "podAntiAffinity", inline: false }];
}

message AttachedVolume {
  // Name of the attached volume
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // DevicePath represents the device path where the volume should be available
  string device_path = 2 [(dev.f110.kubeproto.field) = { go_name: "DevicePath", api_field_name: "devicePath", inline: false }];
}

message AvoidPods {
  // Bounded-sized list of signatures of pods that should avoid this node, sorted
  // in timestamp order from oldest to newest. Size of the slice is unspecified.
  repeated PreferAvoidPodsEntry prefer_avoid_pods = 1 [(dev.f110.kubeproto.field) = { go_name: "PreferAvoidPods", api_field_name: "preferAvoidPods", inline: false }];
}

message AzureDiskVolumeSource {
  // diskName is the Name of the data disk in the blob storage
  string disk_name = 1 [(dev.f110.kubeproto.field) = { go_name: "DiskName", api_field_name: "diskName", inline: false }];
  // diskURI is the URI of data disk in the blob storage
  string data_disk_uri = 2 [(dev.f110.kubeproto.field) = { go_name: "DataDiskURI", api_field_name: "diskURI", inline: false }];
  // cachingMode is the Host Caching mode: None, Read Only, Read Write.
  optional AzureDataDiskCachingMode caching_mode = 3 [(dev.f110.kubeproto.field) = { go_name: "CachingMode", api_field_name: "cachingMode", inline: false }];
  // fsType is Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  optional string fs_type = 4 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // readOnly Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool read_only = 5 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // kind expected values are Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
  optional AzureDataDiskKind kind = 6 [(dev.f110.kubeproto.field) = { go_name: "Kind", api_field_name: "kind", inline: false }];
}

message AzureFilePersistentVolumeSource {
  // secretName is the name of secret that contains Azure Storage Account Name and Key
  string secret_name = 1 [(dev.f110.kubeproto.field) = { go_name: "SecretName", api_field_name: "secretName", inline: false }];
  // shareName is the azure Share Name
  string share_name = 2 [(dev.f110.kubeproto.field) = { go_name: "ShareName", api_field_name: "shareName", inline: false }];
  // readOnly defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool read_only = 3 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // secretNamespace is the namespace of the secret that contains Azure Storage Account Name and Key
  // default is the same as the Pod
  optional string secret_namespace = 4 [(dev.f110.kubeproto.field) = { go_name: "SecretNamespace", api_field_name: "secretNamespace", inline: false }];
}

message AzureFileVolumeSource {
  // secretName is the  name of secret that contains Azure Storage Account Name and Key
  string secret_name = 1 [(dev.f110.kubeproto.field) = { go_name: "SecretName", api_field_name: "secretName", inline: false }];
  // shareName is the azure share Name
  string share_name = 2 [(dev.f110.kubeproto.field) = { go_name: "ShareName", api_field_name: "shareName", inline: false }];
  // readOnly defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool read_only = 3 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
}

message Binding {
  // The target object that you want to bind to the standard object.
  ObjectReference target = 3 [(dev.f110.kubeproto.field) = { go_name: "Target", api_field_name: "target", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message CSIPersistentVolumeSource {
  // driver is the name of the driver to use for this volume.
  // Required.
  string driver = 1 [(dev.f110.kubeproto.field) = { go_name: "Driver", api_field_name: "driver", inline: false }];
  // volumeHandle is the unique volume name returned by the CSI volume
  // plugin’s CreateVolume to refer to the volume on all subsequent calls.
  // Required.
  string volume_handle = 2 [(dev.f110.kubeproto.field) = { go_name: "VolumeHandle", api_field_name: "volumeHandle", inline: false }];
  // readOnly value to pass to ControllerPublishVolumeRequest.
  // Defaults to false (read/write).
  optional bool read_only = 3 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // fsType to mount. Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs".
  optional string fs_type = 4 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // volumeAttributes of the volume to publish.
  map<string, string> volume_attributes = 5 [(dev.f110.kubeproto.field) = { go_name: "VolumeAttributes", api_field_name: "volumeAttributes", inline: false }];
  // controllerPublishSecretRef is a reference to the secret object containing
  // sensitive information to pass to the CSI driver to complete the CSI
  // ControllerPublishVolume and ControllerUnpublishVolume calls.
  // This field is optional, and may be empty if no secret is required. If the
  // secret object contains more than one secret, all secrets are passed.
  optional SecretReference controller_publish_secret_ref = 6 [(dev.f110.kubeproto.field) = { go_name: "ControllerPublishSecretRef", api_field_name: "controllerPublishSecretRef", inline: false }];
  // nodeStageSecretRef is a reference to the secret object containing sensitive
  // information to pass to the CSI driver to complete the CSI NodeStageVolume
  // and NodeStageVolume and NodeUnstageVolume calls.
  // This field is optional, and may be empty if no secret is required. If the
  // secret object contains more than one secret, all secrets are passed.
  optional SecretReference node_stage_secret_ref = 7 [(dev.f110.kubeproto.field) = { go_name: "NodeStageSecretRef", api_field_name: "nodeStageSecretRef", inline: false }];
  // nodePublishSecretRef is a reference to the secret object containing
  // sensitive information to pass to the CSI driver to complete the CSI
  // NodePublishVolume and NodeUnpublishVolume calls.
  // This field is optional, and may be empty if no secret is required. If the
  // secret object contains more than one secret, all secrets are passed.
  optional SecretReference node_publish_secret_ref = 8 [(dev.f110.kubeproto.field) = { go_name: "NodePublishSecretRef", api_field_name: "nodePublishSecretRef", inline: false }];
  // controllerExpandSecretRef is a reference to the secret object containing
  // sensitive information to pass to the CSI driver to complete the CSI
  // ControllerExpandVolume call.
  // This field is optional, and may be empty if no secret is required. If the
  // secret object contains more than one secret, all secrets are passed.
  optional SecretReference controller_expand_secret_ref = 9 [(dev.f110.kubeproto.field) = { go_name: "ControllerExpandSecretRef", api_field_name: "controllerExpandSecretRef", inline: false }];
  // nodeExpandSecretRef is a reference to the secret object containing
  // sensitive information to pass to the CSI driver to complete the CSI
  // NodeExpandVolume call.
  // This is a beta field which is enabled default by CSINodeExpandSecret feature gate.
  // This field is optional, may be omitted if no secret is required. If the
  // secret object contains more than one secret, all secrets are passed.
  optional SecretReference node_expand_secret_ref = 10 [(dev.f110.kubeproto.field) = { go_name: "NodeExpandSecretRef", api_field_name: "nodeExpandSecretRef", inline: false }];
}

message CSIVolumeSource {
  // driver is the name of the CSI driver that handles this volume.
  // Consult with your admin for the correct name as registered in the cluster.
  string driver = 1 [(dev.f110.kubeproto.field) = { go_name: "Driver", api_field_name: "driver", inline: false }];
  // readOnly specifies a read-only configuration for the volume.
  // Defaults to false (read/write).
  optional bool read_only = 2 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // fsType to mount. Ex. "ext4", "xfs", "ntfs".
  // If not provided, the empty value is passed to the associated CSI driver
  // which will determine the default filesystem to apply.
  optional string fs_type = 3 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // volumeAttributes stores driver-specific properties that are passed to the CSI
  // driver. Consult your driver's documentation for supported values.
  map<string, string> volume_attributes = 4 [(dev.f110.kubeproto.field) = { go_name: "VolumeAttributes", api_field_name: "volumeAttributes", inline: false }];
  // nodePublishSecretRef is a reference to the secret object containing
  // sensitive information to pass to the CSI driver to complete the CSI
  // NodePublishVolume and NodeUnpublishVolume calls.
  // This field is optional, and  may be empty if no secret is required. If the
  // secret object contains more than one secret, all secret references are passed.
  optional LocalObjectReference node_publish_secret_ref = 5 [(dev.f110.kubeproto.field) = { go_name: "NodePublishSecretRef", api_field_name: "nodePublishSecretRef", inline: false }];
}

message Capabilities {
  // Added capabilities
  repeated string add = 1 [(dev.f110.kubeproto.field) = { go_name: "Add", api_field_name: "add", inline: false }];
  // Removed capabilities
  repeated string drop = 2 [(dev.f110.kubeproto.field) = { go_name: "Drop", api_field_name: "drop", inline: false }];
}

message CephFSPersistentVolumeSource {
  // monitors is Required: Monitors is a collection of Ceph monitors
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  repeated string monitors = 1 [(dev.f110.kubeproto.field) = { go_name: "Monitors", api_field_name: "monitors", inline: false }];
  // path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
  optional string path = 2 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // user is Optional: User is the rados user name, default is admin
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  optional string user = 3 [(dev.f110.kubeproto.field) = { go_name: "User", api_field_name: "user", inline: false }];
  // secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  optional string secret_file = 4 [(dev.f110.kubeproto.field) = { go_name: "SecretFile", api_field_name: "secretFile", inline: false }];
  // secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  optional SecretReference secret_ref = 5 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
  // readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  optional bool read_only = 6 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
}

message CephFSVolumeSource {
  // monitors is Required: Monitors is a collection of Ceph monitors
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  repeated string monitors = 1 [(dev.f110.kubeproto.field) = { go_name: "Monitors", api_field_name: "monitors", inline: false }];
  // path is Optional: Used as the mounted root, rather than the full Ceph tree, default is /
  optional string path = 2 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // user is optional: User is the rados user name, default is admin
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  optional string user = 3 [(dev.f110.kubeproto.field) = { go_name: "User", api_field_name: "user", inline: false }];
  // secretFile is Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  optional string secret_file = 4 [(dev.f110.kubeproto.field) = { go_name: "SecretFile", api_field_name: "secretFile", inline: false }];
  // secretRef is Optional: SecretRef is reference to the authentication secret for User, default is empty.
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  optional LocalObjectReference secret_ref = 5 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
  // readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it
  optional bool read_only = 6 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
}

message CinderPersistentVolumeSource {
  // volumeID used to identify the volume in cinder.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  string volume_id = 1 [(dev.f110.kubeproto.field) = { go_name: "VolumeID", api_field_name: "volumeID", inline: false }];
  // fsType Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  optional string fs_type = 2 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  optional bool read_only = 3 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // secretRef is Optional: points to a secret object containing parameters used to connect
  // to OpenStack.
  optional SecretReference secret_ref = 4 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
}

message CinderVolumeSource {
  // volumeID used to identify the volume in cinder.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  string volume_id = 1 [(dev.f110.kubeproto.field) = { go_name: "VolumeID", api_field_name: "volumeID", inline: false }];
  // fsType is the filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  optional string fs_type = 2 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // readOnly defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  optional bool read_only = 3 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // secretRef is optional: points to a secret object containing parameters used to connect
  // to OpenStack.
  optional LocalObjectReference secret_ref = 4 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
}

message ClaimSource {
  // ResourceClaimName is the name of a ResourceClaim object in the same
  // namespace as this pod.
  optional string resource_claim_name = 1 [(dev.f110.kubeproto.field) = { go_name: "ResourceClaimName", api_field_name: "resourceClaimName", inline: false }];
  // ResourceClaimTemplateName is the name of a ResourceClaimTemplate
  // object in the same namespace as this pod.
  // The template will be used to create a new ResourceClaim, which will
  // be bound to this pod. When this pod is deleted, the ResourceClaim
  // will also be deleted. The name of the ResourceClaim will be <pod
  // name>-<resource name>, where <resource name> is the
  // PodResourceClaim.Name. Pod validation will reject the pod if the
  // concatenated name is not valid for a ResourceClaim (e.g. too long).
  // An existing ResourceClaim with that name that is not owned by the
  // pod will not be used for the pod to avoid using an unrelated
  // resource by mistake. Scheduling and pod startup are then blocked
  // until the unrelated ResourceClaim is removed.
  // This field is immutable and no changes will be made to the
  // corresponding ResourceClaim by the control plane after creating the
  // ResourceClaim.
  optional string resource_claim_template_name = 2 [(dev.f110.kubeproto.field) = { go_name: "ResourceClaimTemplateName", api_field_name: "resourceClaimTemplateName", inline: false }];
}

message ClientIPConfig {
  // timeoutSeconds specifies the seconds of ClientIP type session sticky time.
  // The value must be >0 && <=86400(for 1 day) if ServiceAffinity == "ClientIP".
  // Default value is 10800(for 3 hours).
  optional int32 timeout_seconds = 1 [(dev.f110.kubeproto.field) = { go_name: "TimeoutSeconds", api_field_name: "timeoutSeconds", inline: false }];
}

message ComponentCondition {
  // Type of condition for a component.
  // Valid value: "Healthy"
  ComponentConditionType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Status of the condition for a component.
  // Valid values for "Healthy": "True", "False", or "Unknown".
  ConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // Message about the condition for a component.
  // For example, information about a health check.
  optional string message = 3 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
  // Condition error code for a component.
  // For example, a health check error code.
  optional string error = 4 [(dev.f110.kubeproto.field) = { go_name: "Error", api_field_name: "error", inline: false }];
}

message ComponentStatus {
  // List of component conditions observed
  repeated ComponentCondition conditions = 3 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];

  option (dev.f110.kubeproto.kind) = {
    scope: SCOPE_CLUSTER
  };
}

message ComponentStatusList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of ComponentStatus objects.
  repeated ComponentStatus items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ConfigMap {
  // Immutable, if set to true, ensures that data stored in the ConfigMap cannot
  // be updated (only object metadata can be modified).
  // If not set to true, the field can be modified at any time.
  // Defaulted to nil.
  optional bool immutable = 3 [(dev.f110.kubeproto.field) = { go_name: "Immutable", api_field_name: "immutable", inline: false }];
  // Data contains the configuration data.
  // Each key must consist of alphanumeric characters, '-', '_' or '.'.
  // Values with non-UTF-8 byte sequences must use the BinaryData field.
  // The keys stored in Data must not overlap with the keys in
  // the BinaryData field, this is enforced during validation process.
  map<string, string> data = 4 [(dev.f110.kubeproto.field) = { go_name: "Data", api_field_name: "data", inline: false }];
  // BinaryData contains the binary data.
  // Each key must consist of alphanumeric characters, '-', '_' or '.'.
  // BinaryData can contain byte sequences that are not in the UTF-8 range.
  // The keys stored in BinaryData must not overlap with the ones in
  // the Data field, this is enforced during validation process.
  // Using this field will require 1.10+ apiserver and
  // kubelet.
  map<string, bytes> binary_data = 5 [(dev.f110.kubeproto.field) = { go_name: "BinaryData", api_field_name: "binaryData", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ConfigMapEnvSource {
  // The ConfigMap to select from.
  LocalObjectReference local_object_reference = 1 [(dev.f110.kubeproto.field) = { go_name: "LocalObjectReference", inline: true }];
  // Specify whether the ConfigMap must be defined
  optional bool optional = 2 [(dev.f110.kubeproto.field) = { go_name: "Optional", api_field_name: "optional", inline: false }];
}

message ConfigMapKeySelector {
  // The ConfigMap to select from.
  LocalObjectReference local_object_reference = 1 [(dev.f110.kubeproto.field) = { go_name: "LocalObjectReference", inline: true }];
  // The key to select.
  string key = 2 [(dev.f110.kubeproto.field) = { go_name: "Key", api_field_name: "key", inline: false }];
  // Specify whether the ConfigMap or its key must be defined
  optional bool optional = 3 [(dev.f110.kubeproto.field) = { go_name: "Optional", api_field_name: "optional", inline: false }];
}

message ConfigMapList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // Items is the list of ConfigMaps.
  repeated ConfigMap items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ConfigMapNodeConfigSource {
  // Namespace is the metadata.namespace of the referenced ConfigMap.
  // This field is required in all cases.
  string namespace = 1 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
  // Name is the metadata.name of the referenced ConfigMap.
  // This field is required in all cases.
  string name = 2 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // UID is the metadata.UID of the referenced ConfigMap.
  // This field is forbidden in Node.Spec, and required in Node.Status.
  optional string uid = 3 [(dev.f110.kubeproto.field) = { go_name: "UID", api_field_name: "uid", inline: false }];
  // ResourceVersion is the metadata.ResourceVersion of the referenced ConfigMap.
  // This field is forbidden in Node.Spec, and required in Node.Status.
  optional string resource_version = 4 [(dev.f110.kubeproto.field) = { go_name: "ResourceVersion", api_field_name: "resourceVersion", inline: false }];
  // KubeletConfigKey declares which key of the referenced ConfigMap corresponds to the KubeletConfiguration structure
  // This field is required in all cases.
  string kubelet_config_key = 5 [(dev.f110.kubeproto.field) = { go_name: "KubeletConfigKey", api_field_name: "kubeletConfigKey", inline: false }];
}

message ConfigMapProjection {
  LocalObjectReference local_object_reference = 1 [(dev.f110.kubeproto.field) = { go_name: "LocalObjectReference", inline: true }];
  // items if unspecified, each key-value pair in the Data field of the referenced
  // ConfigMap will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the ConfigMap,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  repeated KeyToPath items = 2 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
  // optional specify whether the ConfigMap or its keys must be defined
  optional bool optional = 3 [(dev.f110.kubeproto.field) = { go_name: "Optional", api_field_name: "optional", inline: false }];
}

message ConfigMapVolumeSource {
  LocalObjectReference local_object_reference = 1 [(dev.f110.kubeproto.field) = { go_name: "LocalObjectReference", inline: true }];
  // items if unspecified, each key-value pair in the Data field of the referenced
  // ConfigMap will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the ConfigMap,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  repeated KeyToPath items = 2 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
  // defaultMode is optional: mode bits used to set permissions on created files by default.
  // Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
  // YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
  // Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  optional int32 default_mode = 3 [(dev.f110.kubeproto.field) = { go_name: "DefaultMode", api_field_name: "defaultMode", inline: false }];
  // optional specify whether the ConfigMap or its keys must be defined
  optional bool optional = 4 [(dev.f110.kubeproto.field) = { go_name: "Optional", api_field_name: "optional", inline: false }];
}

message Container {
  // Name of the container specified as a DNS_LABEL.
  // Each container in a pod must have a unique name (DNS_LABEL).
  // Cannot be updated.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Container image name.
  // More info: https://kubernetes.io/docs/concepts/containers/images
  // This field is optional to allow higher level config management to default or override
  // container images in workload controllers like Deployments and StatefulSets.
  optional string image = 2 [(dev.f110.kubeproto.field) = { go_name: "Image", api_field_name: "image", inline: false }];
  // Entrypoint array. Not executed within a shell.
  // The container image's ENTRYPOINT is used if this is not provided.
  // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
  // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
  // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
  // of whether the variable exists or not. Cannot be updated.
  // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  repeated string command = 3 [(dev.f110.kubeproto.field) = { go_name: "Command", api_field_name: "command", inline: false }];
  // Arguments to the entrypoint.
  // The container image's CMD is used if this is not provided.
  // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
  // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
  // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
  // of whether the variable exists or not. Cannot be updated.
  // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  repeated string args = 4 [(dev.f110.kubeproto.field) = { go_name: "Args", api_field_name: "args", inline: false }];
  // Container's working directory.
  // If not specified, the container runtime's default will be used, which
  // might be configured in the container image.
  // Cannot be updated.
  optional string working_dir = 5 [(dev.f110.kubeproto.field) = { go_name: "WorkingDir", api_field_name: "workingDir", inline: false }];
  // List of ports to expose from the container. Not specifying a port here
  // DOES NOT prevent that port from being exposed. Any port which is
  // listening on the default "0.0.0.0" address inside a container will be
  // accessible from the network.
  // Modifying this array with strategic merge patch may corrupt the data.
  // For more information See https://github.com/kubernetes/kubernetes/issues/108255.
  // Cannot be updated.
  repeated ContainerPort ports = 6 [(dev.f110.kubeproto.field) = { go_name: "Ports", api_field_name: "ports", inline: false }];
  // List of sources to populate environment variables in the container.
  // The keys defined within a source must be a C_IDENTIFIER. All invalid keys
  // will be reported as an event when the container is starting. When a key exists in multiple
  // sources, the value associated with the last source will take precedence.
  // Values defined by an Env with a duplicate key will take precedence.
  // Cannot be updated.
  repeated EnvFromSource env_from = 7 [(dev.f110.kubeproto.field) = { go_name: "EnvFrom", api_field_name: "envFrom", inline: false }];
  // List of environment variables to set in the container.
  // Cannot be updated.
  repeated EnvVar env = 8 [(dev.f110.kubeproto.field) = { go_name: "Env", api_field_name: "env", inline: false }];
  // Compute Resources required by this container.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  optional ResourceRequirements resources = 9 [(dev.f110.kubeproto.field) = { go_name: "Resources", api_field_name: "resources", inline: false }];
  // Resources resize policy for the container.
  repeated ContainerResizePolicy resize_policy = 10 [(dev.f110.kubeproto.field) = { go_name: "ResizePolicy", api_field_name: "resizePolicy", inline: false }];
  // Pod volumes to mount into the container's filesystem.
  // Cannot be updated.
  repeated VolumeMount volume_mounts = 11 [(dev.f110.kubeproto.field) = { go_name: "VolumeMounts", api_field_name: "volumeMounts", inline: false }];
  // volumeDevices is the list of block devices to be used by the container.
  repeated VolumeDevice volume_devices = 12 [(dev.f110.kubeproto.field) = { go_name: "VolumeDevices", api_field_name: "volumeDevices", inline: false }];
  // Periodic probe of container liveness.
  // Container will be restarted if the probe fails.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  optional Probe liveness_probe = 13 [(dev.f110.kubeproto.field) = { go_name: "LivenessProbe", api_field_name: "livenessProbe", inline: false }];
  // Periodic probe of container service readiness.
  // Container will be removed from service endpoints if the probe fails.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  optional Probe readiness_probe = 14 [(dev.f110.kubeproto.field) = { go_name: "ReadinessProbe", api_field_name: "readinessProbe", inline: false }];
  // StartupProbe indicates that the Pod has successfully initialized.
  // If specified, no other probes are executed until this completes successfully.
  // If this probe fails, the Pod will be restarted, just as if the livenessProbe failed.
  // This can be used to provide different probe parameters at the beginning of a Pod's lifecycle,
  // when it might take a long time to load data or warm a cache, than during steady-state operation.
  // This cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  optional Probe startup_probe = 15 [(dev.f110.kubeproto.field) = { go_name: "StartupProbe", api_field_name: "startupProbe", inline: false }];
  // Actions that the management system should take in response to container lifecycle events.
  // Cannot be updated.
  optional Lifecycle lifecycle = 16 [(dev.f110.kubeproto.field) = { go_name: "Lifecycle", api_field_name: "lifecycle", inline: false }];
  // Optional: Path at which the file to which the container's termination message
  // will be written is mounted into the container's filesystem.
  // Message written is intended to be brief final status, such as an assertion failure message.
  // Will be truncated by the node if greater than 4096 bytes. The total message length across
  // all containers will be limited to 12kb.
  // Defaults to /dev/termination-log.
  // Cannot be updated.
  optional string termination_message_path = 17 [(dev.f110.kubeproto.field) = { go_name: "TerminationMessagePath", api_field_name: "terminationMessagePath", inline: false }];
  // Indicate how the termination message should be populated. File will use the contents of
  // terminationMessagePath to populate the container status message on both success and failure.
  // FallbackToLogsOnError will use the last chunk of container log output if the termination
  // message file is empty and the container exited with an error.
  // The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
  // Defaults to File.
  // Cannot be updated.
  optional TerminationMessagePolicy termination_message_policy = 18 [(dev.f110.kubeproto.field) = { go_name: "TerminationMessagePolicy", api_field_name: "terminationMessagePolicy", inline: false }];
  // Image pull policy.
  // One of Always, Never, IfNotPresent.
  // Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
  optional PullPolicy image_pull_policy = 19 [(dev.f110.kubeproto.field) = { go_name: "ImagePullPolicy", api_field_name: "imagePullPolicy", inline: false }];
  // SecurityContext defines the security options the container should be run with.
  // If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
  // More info: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
  optional SecurityContext security_context = 20 [(dev.f110.kubeproto.field) = { go_name: "SecurityContext", api_field_name: "securityContext", inline: false }];
  // Whether this container should allocate a buffer for stdin in the container runtime. If this
  // is not set, reads from stdin in the container will always result in EOF.
  // Default is false.
  optional bool stdin = 21 [(dev.f110.kubeproto.field) = { go_name: "Stdin", api_field_name: "stdin", inline: false }];
  // Whether the container runtime should close the stdin channel after it has been opened by
  // a single attach. When stdin is true the stdin stream will remain open across multiple attach
  // sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
  // first client attaches to stdin, and then remains open and accepts data until the client disconnects,
  // at which time stdin is closed and remains closed until the container is restarted. If this
  // flag is false, a container processes that reads from stdin will never receive an EOF.
  // Default is false
  optional bool stdin_once = 22 [(dev.f110.kubeproto.field) = { go_name: "StdinOnce", api_field_name: "stdinOnce", inline: false }];
  // Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
  // Default is false.
  optional bool tty = 23 [(dev.f110.kubeproto.field) = { go_name: "TTY", api_field_name: "tty", inline: false }];
}

message ContainerImage {
  // Names by which this image is known.
  // e.g. ["kubernetes.example/hyperkube:v1.0.7", "cloud-vendor.registry.example/cloud-vendor/hyperkube:v1.0.7"]
  repeated string names = 1 [(dev.f110.kubeproto.field) = { go_name: "Names", api_field_name: "names", inline: false }];
  // The size of the image in bytes.
  optional int64 size_bytes = 2 [(dev.f110.kubeproto.field) = { go_name: "SizeBytes", api_field_name: "sizeBytes", inline: false }];
}

message ContainerPort {
  // If specified, this must be an IANA_SVC_NAME and unique within the pod. Each
  // named port in a pod must have a unique name. Name for the port that can be
  // referred to by services.
  optional string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Number of port to expose on the host.
  // If specified, this must be a valid port number, 0 < x < 65536.
  // If HostNetwork is specified, this must match ContainerPort.
  // Most containers do not need this.
  optional int32 host_port = 2 [(dev.f110.kubeproto.field) = { go_name: "HostPort", api_field_name: "hostPort", inline: false }];
  // Number of port to expose on the pod's IP address.
  // This must be a valid port number, 0 < x < 65536.
  int32 container_port = 3 [(dev.f110.kubeproto.field) = { go_name: "ContainerPort", api_field_name: "containerPort", inline: false }];
  // Protocol for port. Must be UDP, TCP, or SCTP.
  // Defaults to "TCP".
  optional Protocol protocol = 4 [(dev.f110.kubeproto.field) = { go_name: "Protocol", api_field_name: "protocol", inline: false }];
  // What host IP to bind the external port to.
  optional string host_ip = 5 [(dev.f110.kubeproto.field) = { go_name: "HostIP", api_field_name: "hostIP", inline: false }];
}

message ContainerResizePolicy {
  // Name of the resource to which this resource resize policy applies.
  // Supported values: cpu, memory.
  ResourceName resource_name = 1 [(dev.f110.kubeproto.field) = { go_name: "ResourceName", api_field_name: "resourceName", inline: false }];
  // Restart policy to apply when specified resource is resized.
  // If not specified, it defaults to NotRequired.
  ResourceResizeRestartPolicy restart_policy = 2 [(dev.f110.kubeproto.field) = { go_name: "RestartPolicy", api_field_name: "restartPolicy", inline: false }];
}

message ContainerState {
  // Details about a waiting container
  optional ContainerStateWaiting waiting = 1 [(dev.f110.kubeproto.field) = { go_name: "Waiting", api_field_name: "waiting", inline: false }];
  // Details about a running container
  optional ContainerStateRunning running = 2 [(dev.f110.kubeproto.field) = { go_name: "Running", api_field_name: "running", inline: false }];
  // Details about a terminated container
  optional ContainerStateTerminated terminated = 3 [(dev.f110.kubeproto.field) = { go_name: "Terminated", api_field_name: "terminated", inline: false }];
}

message ContainerStateRunning {
  // Time at which the container was last (re-)started
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time started_at = 1 [(dev.f110.kubeproto.field) = { go_name: "StartedAt", api_field_name: "startedAt", inline: false }];
}

message ContainerStateTerminated {
  // Exit status from the last termination of the container
  int32 exit_code = 1 [(dev.f110.kubeproto.field) = { go_name: "ExitCode", api_field_name: "exitCode", inline: false }];
  // Signal from the last termination of the container
  optional int32 signal = 2 [(dev.f110.kubeproto.field) = { go_name: "Signal", api_field_name: "signal", inline: false }];
  // (brief) reason from the last termination of the container
  optional string reason = 3 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // Message regarding the last termination of the container
  optional string message = 4 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
  // Time at which previous execution of the container started
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time started_at = 5 [(dev.f110.kubeproto.field) = { go_name: "StartedAt", api_field_name: "startedAt", inline: false }];
  // Time at which the container last terminated
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time finished_at = 6 [(dev.f110.kubeproto.field) = { go_name: "FinishedAt", api_field_name: "finishedAt", inline: false }];
  // Container's ID in the format '<type>://<container_id>'
  optional string container_id = 7 [(dev.f110.kubeproto.field) = { go_name: "ContainerID", api_field_name: "containerID", inline: false }];
}

message ContainerStateWaiting {
  // (brief) reason the container is not yet running.
  optional string reason = 1 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // Message regarding why the container is not yet running.
  optional string message = 2 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message ContainerStatus {
  // Name is a DNS_LABEL representing the unique name of the container.
  // Each container in a pod must have a unique name across all container types.
  // Cannot be updated.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // State holds details about the container's current condition.
  optional ContainerState state = 2 [(dev.f110.kubeproto.field) = { go_name: "State", api_field_name: "state", inline: false }];
  // LastTerminationState holds the last termination state of the container to
  // help debug container crashes and restarts. This field is not
  // populated if the container is still running and RestartCount is 0.
  optional ContainerState last_termination_state = 3 [(dev.f110.kubeproto.field) = { go_name: "LastTerminationState", api_field_name: "lastState", inline: false }];
  // Ready specifies whether the container is currently passing its readiness check.
  // The value will change as readiness probes keep executing. If no readiness
  // probes are specified, this field defaults to true once the container is
  // fully started (see Started field).
  // The value is typically used to determine whether a container is ready to
  // accept traffic.
  bool ready = 4 [(dev.f110.kubeproto.field) = { go_name: "Ready", api_field_name: "ready", inline: false }];
  // RestartCount holds the number of times the container has been restarted.
  // Kubelet makes an effort to always increment the value, but there
  // are cases when the state may be lost due to node restarts and then the value
  // may be reset to 0. The value is never negative.
  int32 restart_count = 5 [(dev.f110.kubeproto.field) = { go_name: "RestartCount", api_field_name: "restartCount", inline: false }];
  // Image is the name of container image that the container is running.
  // The container image may not match the image used in the PodSpec,
  // as it may have been resolved by the runtime.
  // More info: https://kubernetes.io/docs/concepts/containers/images.
  string image = 6 [(dev.f110.kubeproto.field) = { go_name: "Image", api_field_name: "image", inline: false }];
  // ImageID is the image ID of the container's image. The image ID may not
  // match the image ID of the image used in the PodSpec, as it may have been
  // resolved by the runtime.
  string image_id = 7 [(dev.f110.kubeproto.field) = { go_name: "ImageID", api_field_name: "imageID", inline: false }];
  // ContainerID is the ID of the container in the format '<type>://<container_id>'.
  // Where type is a container runtime identifier, returned from Version call of CRI API
  // (for example "containerd").
  optional string container_id = 8 [(dev.f110.kubeproto.field) = { go_name: "ContainerID", api_field_name: "containerID", inline: false }];
  // Started indicates whether the container has finished its postStart lifecycle hook
  // and passed its startup probe.
  // Initialized as false, becomes true after startupProbe is considered
  // successful. Resets to false when the container is restarted, or if kubelet
  // loses state temporarily. In both cases, startup probes will run again.
  // Is always true when no startupProbe is defined and container is running and
  // has passed the postStart lifecycle hook. The null value must be treated the
  // same as false.
  optional bool started = 9 [(dev.f110.kubeproto.field) = { go_name: "Started", api_field_name: "started", inline: false }];
  // AllocatedResources represents the compute resources allocated for this container by the
  // node. Kubelet sets this value to Container.Resources.Requests upon successful pod admission
  // and after successfully admitting desired pod resize.
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> allocated_resources = 10 [(dev.f110.kubeproto.field) = { go_name: "AllocatedResources", api_field_name: "allocatedResources", inline: false }];
  // Resources represents the compute resource requests and limits that have been successfully
  // enacted on the running container after it has been started or has been successfully resized.
  optional ResourceRequirements resources = 11 [(dev.f110.kubeproto.field) = { go_name: "Resources", api_field_name: "resources", inline: false }];
}

message DaemonEndpoint {
  // Port number of the given endpoint.
  int32 port = 1 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "Port", inline: false }];
}

message DownwardAPIProjection {
  // Items is a list of DownwardAPIVolume file
  repeated DownwardAPIVolumeFile items = 1 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message DownwardAPIVolumeFile {
  // Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
  string path = 1 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
  optional ObjectFieldSelector field_ref = 2 [(dev.f110.kubeproto.field) = { go_name: "FieldRef", api_field_name: "fieldRef", inline: false }];
  // Selects a resource of the container: only resources limits and requests
  // (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
  optional ResourceFieldSelector resource_field_ref = 3 [(dev.f110.kubeproto.field) = { go_name: "ResourceFieldRef", api_field_name: "resourceFieldRef", inline: false }];
  // Optional: mode bits used to set permissions on this file, must be an octal value
  // between 0000 and 0777 or a decimal value between 0 and 511.
  // YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
  // If not specified, the volume defaultMode will be used.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  optional int32 mode = 4 [(dev.f110.kubeproto.field) = { go_name: "Mode", api_field_name: "mode", inline: false }];
}

message DownwardAPIVolumeSource {
  // Items is a list of downward API volume file
  repeated DownwardAPIVolumeFile items = 1 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
  // Optional: mode bits to use on created files by default. Must be a
  // Optional: mode bits used to set permissions on created files by default.
  // Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
  // YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
  // Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  optional int32 default_mode = 2 [(dev.f110.kubeproto.field) = { go_name: "DefaultMode", api_field_name: "defaultMode", inline: false }];
}

message EmptyDirVolumeSource {
  // medium represents what type of storage medium should back this directory.
  // The default is "" which means to use the node's default medium.
  // Must be an empty string (default) or Memory.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  optional StorageMedium medium = 1 [(dev.f110.kubeproto.field) = { go_name: "Medium", api_field_name: "medium", inline: false }];
  // sizeLimit is the total amount of local storage required for this EmptyDir volume.
  // The size limit is also applicable for memory medium.
  // The maximum usage on memory medium EmptyDir would be the minimum value between
  // the SizeLimit specified here and the sum of memory limits of all containers in a pod.
  // The default is nil which means that the limit is undefined.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  optional .k8s.io.apimachinery.pkg.api.resource.Quantity size_limit = 2 [(dev.f110.kubeproto.field) = { go_name: "SizeLimit", api_field_name: "sizeLimit", inline: false }];
}

message EndpointAddress {
  // The IP of this endpoint.
  // May not be loopback (127.0.0.0/8 or ::1), link-local (169.254.0.0/16 or fe80::/10),
  // or link-local multicast (224.0.0.0/24 or ff02::/16).
  string ip = 1 [(dev.f110.kubeproto.field) = { go_name: "IP", api_field_name: "ip", inline: false }];
  // The Hostname of this endpoint
  optional string hostname = 2 [(dev.f110.kubeproto.field) = { go_name: "Hostname", api_field_name: "hostname", inline: false }];
  // Optional: Node hosting this endpoint. This can be used to determine endpoints local to a node.
  optional string node_name = 3 [(dev.f110.kubeproto.field) = { go_name: "NodeName", api_field_name: "nodeName", inline: false }];
  // Reference to object providing the endpoint.
  optional ObjectReference target_ref = 4 [(dev.f110.kubeproto.field) = { go_name: "TargetRef", api_field_name: "targetRef", inline: false }];
}

message EndpointPort {
  // The name of this port.  This must match the 'name' field in the
  // corresponding ServicePort.
  // Must be a DNS_LABEL.
  // Optional only if one port is defined.
  optional string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // The port number of the endpoint.
  int32 port = 2 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // The IP protocol for this port.
  // Must be UDP, TCP, or SCTP.
  // Default is TCP.
  optional Protocol protocol = 3 [(dev.f110.kubeproto.field) = { go_name: "Protocol", api_field_name: "protocol", inline: false }];
  // The application protocol for this port.
  // This is used as a hint for implementations to offer richer behavior for protocols that they understand.
  // This field follows standard Kubernetes label syntax.
  // Valid values are either:
  // * Un-prefixed protocol names - reserved for IANA standard service names (as per
  // RFC-6335 and https://www.iana.org/assignments/service-names).
  // * Kubernetes-defined prefixed names:
  //   * 'kubernetes.io/h2c' - HTTP/2 over cleartext as described in https://www.rfc-editor.org/rfc/rfc7540
  // * Other protocols should use implementation-defined prefixed names such as
  // mycompany.com/my-custom-protocol.
  optional string app_protocol = 4 [(dev.f110.kubeproto.field) = { go_name: "AppProtocol", api_field_name: "appProtocol", inline: false }];
}

message EndpointSubset {
  // IP addresses which offer the related ports that are marked as ready. These endpoints
  // should be considered safe for load balancers and clients to utilize.
  repeated EndpointAddress addresses = 1 [(dev.f110.kubeproto.field) = { go_name: "Addresses", api_field_name: "addresses", inline: false }];
  // IP addresses which offer the related ports but are not currently marked as ready
  // because they have not yet finished starting, have recently failed a readiness check,
  // or have recently failed a liveness check.
  repeated EndpointAddress not_ready_addresses = 2 [(dev.f110.kubeproto.field) = { go_name: "NotReadyAddresses", api_field_name: "notReadyAddresses", inline: false }];
  // Port numbers available on the related IP addresses.
  repeated EndpointPort ports = 3 [(dev.f110.kubeproto.field) = { go_name: "Ports", api_field_name: "ports", inline: false }];
}

message Endpoints {
  // The set of all endpoints is the union of all subsets. Addresses are placed into
  // subsets according to the IPs they share. A single address with multiple ports,
  // some of which are ready and some of which are not (because they come from
  // different containers) will result in the address being displayed in different
  // subsets for the different ports. No address will appear in both Addresses and
  // NotReadyAddresses in the same subset.
  // Sets of addresses and ports that comprise a service.
  repeated EndpointSubset subsets = 3 [(dev.f110.kubeproto.field) = { go_name: "Subsets", api_field_name: "subsets", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message EndpointsList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of endpoints.
  repeated Endpoints items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message EnvFromSource {
  // An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
  optional string prefix = 1 [(dev.f110.kubeproto.field) = { go_name: "Prefix", api_field_name: "prefix", inline: false }];
  // The ConfigMap to select from
  optional ConfigMapEnvSource config_map_ref = 2 [(dev.f110.kubeproto.field) = { go_name: "ConfigMapRef", api_field_name: "configMapRef", inline: false }];
  // The Secret to select from
  optional SecretEnvSource secret_ref = 3 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
}

message EnvVar {
  // Name of the environment variable. Must be a C_IDENTIFIER.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Variable references $(VAR_NAME) are expanded
  // using the previously defined environment variables in the container and
  // any service environment variables. If a variable cannot be resolved,
  // the reference in the input string will be unchanged. Double $$ are reduced
  // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e.
  // "$$(VAR_NAME)" will produce the string literal "$(VAR_NAME)".
  // Escaped references will never be expanded, regardless of whether the variable
  // exists or not.
  // Defaults to "".
  optional string value = 2 [(dev.f110.kubeproto.field) = { go_name: "Value", api_field_name: "value", inline: false }];
  // Source for the environment variable's value. Cannot be used if value is not empty.
  optional EnvVarSource value_from = 3 [(dev.f110.kubeproto.field) = { go_name: "ValueFrom", api_field_name: "valueFrom", inline: false }];
}

message EnvVarSource {
  // Selects a field of the pod: supports metadata.name, metadata.namespace, `metadata.labels['<KEY>']`, `metadata.annotations['<KEY>']`,
  // spec.nodeName, spec.serviceAccountName, status.hostIP, status.podIP, status.podIPs.
  optional ObjectFieldSelector field_ref = 1 [(dev.f110.kubeproto.field) = { go_name: "FieldRef", api_field_name: "fieldRef", inline: false }];
  // Selects a resource of the container: only resources limits and requests
  // (limits.cpu, limits.memory, limits.ephemeral-storage, requests.cpu, requests.memory and requests.ephemeral-storage) are currently supported.
  optional ResourceFieldSelector resource_field_ref = 2 [(dev.f110.kubeproto.field) = { go_name: "ResourceFieldRef", api_field_name: "resourceFieldRef", inline: false }];
  // Selects a key of a ConfigMap.
  optional ConfigMapKeySelector config_map_key_ref = 3 [(dev.f110.kubeproto.field) = { go_name: "ConfigMapKeyRef", api_field_name: "configMapKeyRef", inline: false }];
  // Selects a key of a secret in the pod's namespace
  optional SecretKeySelector secret_key_ref = 4 [(dev.f110.kubeproto.field) = { go_name: "SecretKeyRef", api_field_name: "secretKeyRef", inline: false }];
}

message EphemeralContainer {
  // Ephemeral containers have all of the fields of Container, plus additional fields
  // specific to ephemeral containers. Fields in common with Container are in the
  // following inlined struct so than an EphemeralContainer may easily be converted
  // to a Container.
  EphemeralContainerCommon ephemeral_container_common = 1 [(dev.f110.kubeproto.field) = { go_name: "EphemeralContainerCommon", inline: true }];
  // If set, the name of the container from PodSpec that this ephemeral container targets.
  // The ephemeral container will be run in the namespaces (IPC, PID, etc) of this container.
  // If not set then the ephemeral container uses the namespaces configured in the Pod spec.
  // The container runtime must implement support for this feature. If the runtime does not
  // support namespace targeting then the result of setting this field is undefined.
  optional string target_container_name = 2 [(dev.f110.kubeproto.field) = { go_name: "TargetContainerName", api_field_name: "targetContainerName", inline: false }];
}

message EphemeralContainerCommon {
  // Name of the ephemeral container specified as a DNS_LABEL.
  // This name must be unique among all containers, init containers and ephemeral containers.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Container image name.
  // More info: https://kubernetes.io/docs/concepts/containers/images
  optional string image = 2 [(dev.f110.kubeproto.field) = { go_name: "Image", api_field_name: "image", inline: false }];
  // Entrypoint array. Not executed within a shell.
  // The image's ENTRYPOINT is used if this is not provided.
  // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
  // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
  // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
  // of whether the variable exists or not. Cannot be updated.
  // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  repeated string command = 3 [(dev.f110.kubeproto.field) = { go_name: "Command", api_field_name: "command", inline: false }];
  // Arguments to the entrypoint.
  // The image's CMD is used if this is not provided.
  // Variable references $(VAR_NAME) are expanded using the container's environment. If a variable
  // cannot be resolved, the reference in the input string will be unchanged. Double $$ are reduced
  // to a single $, which allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
  // produce the string literal "$(VAR_NAME)". Escaped references will never be expanded, regardless
  // of whether the variable exists or not. Cannot be updated.
  // More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
  repeated string args = 4 [(dev.f110.kubeproto.field) = { go_name: "Args", api_field_name: "args", inline: false }];
  // Container's working directory.
  // If not specified, the container runtime's default will be used, which
  // might be configured in the container image.
  // Cannot be updated.
  optional string working_dir = 5 [(dev.f110.kubeproto.field) = { go_name: "WorkingDir", api_field_name: "workingDir", inline: false }];
  // Ports are not allowed for ephemeral containers.
  repeated ContainerPort ports = 6 [(dev.f110.kubeproto.field) = { go_name: "Ports", api_field_name: "ports", inline: false }];
  // List of sources to populate environment variables in the container.
  // The keys defined within a source must be a C_IDENTIFIER. All invalid keys
  // will be reported as an event when the container is starting. When a key exists in multiple
  // sources, the value associated with the last source will take precedence.
  // Values defined by an Env with a duplicate key will take precedence.
  // Cannot be updated.
  repeated EnvFromSource env_from = 7 [(dev.f110.kubeproto.field) = { go_name: "EnvFrom", api_field_name: "envFrom", inline: false }];
  // List of environment variables to set in the container.
  // Cannot be updated.
  repeated EnvVar env = 8 [(dev.f110.kubeproto.field) = { go_name: "Env", api_field_name: "env", inline: false }];
  // Resources are not allowed for ephemeral containers. Ephemeral containers use spare resources
  // already allocated to the pod.
  optional ResourceRequirements resources = 9 [(dev.f110.kubeproto.field) = { go_name: "Resources", api_field_name: "resources", inline: false }];
  // Resources resize policy for the container.
  repeated ContainerResizePolicy resize_policy = 10 [(dev.f110.kubeproto.field) = { go_name: "ResizePolicy", api_field_name: "resizePolicy", inline: false }];
  // Pod volumes to mount into the container's filesystem. Subpath mounts are not allowed for ephemeral containers.
  // Cannot be updated.
  repeated VolumeMount volume_mounts = 11 [(dev.f110.kubeproto.field) = { go_name: "VolumeMounts", api_field_name: "volumeMounts", inline: false }];
  // volumeDevices is the list of block devices to be used by the container.
  repeated VolumeDevice volume_devices = 12 [(dev.f110.kubeproto.field) = { go_name: "VolumeDevices", api_field_name: "volumeDevices", inline: false }];
  // Probes are not allowed for ephemeral containers.
  optional Probe liveness_probe = 13 [(dev.f110.kubeproto.field) = { go_name: "LivenessProbe", api_field_name: "livenessProbe", inline: false }];
  // Probes are not allowed for ephemeral containers.
  optional Probe readiness_probe = 14 [(dev.f110.kubeproto.field) = { go_name: "ReadinessProbe", api_field_name: "readinessProbe", inline: false }];
  // Probes are not allowed for ephemeral containers.
  optional Probe startup_probe = 15 [(dev.f110.kubeproto.field) = { go_name: "StartupProbe", api_field_name: "startupProbe", inline: false }];
  // Lifecycle is not allowed for ephemeral containers.
  optional Lifecycle lifecycle = 16 [(dev.f110.kubeproto.field) = { go_name: "Lifecycle", api_field_name: "lifecycle", inline: false }];
  // Optional: Path at which the file to which the container's termination message
  // will be written is mounted into the container's filesystem.
  // Message written is intended to be brief final status, such as an assertion failure message.
  // Will be truncated by the node if greater than 4096 bytes. The total message length across
  // all containers will be limited to 12kb.
  // Defaults to /dev/termination-log.
  // Cannot be updated.
  optional string termination_message_path = 17 [(dev.f110.kubeproto.field) = { go_name: "TerminationMessagePath", api_field_name: "terminationMessagePath", inline: false }];
  // Indicate how the termination message should be populated. File will use the contents of
  // terminationMessagePath to populate the container status message on both success and failure.
  // FallbackToLogsOnError will use the last chunk of container log output if the termination
  // message file is empty and the container exited with an error.
  // The log output is limited to 2048 bytes or 80 lines, whichever is smaller.
  // Defaults to File.
  // Cannot be updated.
  optional TerminationMessagePolicy termination_message_policy = 18 [(dev.f110.kubeproto.field) = { go_name: "TerminationMessagePolicy", api_field_name: "terminationMessagePolicy", inline: false }];
  // Image pull policy.
  // One of Always, Never, IfNotPresent.
  // Defaults to Always if :latest tag is specified, or IfNotPresent otherwise.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
  optional PullPolicy image_pull_policy = 19 [(dev.f110.kubeproto.field) = { go_name: "ImagePullPolicy", api_field_name: "imagePullPolicy", inline: false }];
  // Optional: SecurityContext defines the security options the ephemeral container should be run with.
  // If set, the fields of SecurityContext override the equivalent fields of PodSecurityContext.
  optional SecurityContext security_context = 20 [(dev.f110.kubeproto.field) = { go_name: "SecurityContext", api_field_name: "securityContext", inline: false }];
  // Whether this container should allocate a buffer for stdin in the container runtime. If this
  // is not set, reads from stdin in the container will always result in EOF.
  // Default is false.
  optional bool stdin = 21 [(dev.f110.kubeproto.field) = { go_name: "Stdin", api_field_name: "stdin", inline: false }];
  // Whether the container runtime should close the stdin channel after it has been opened by
  // a single attach. When stdin is true the stdin stream will remain open across multiple attach
  // sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the
  // first client attaches to stdin, and then remains open and accepts data until the client disconnects,
  // at which time stdin is closed and remains closed until the container is restarted. If this
  // flag is false, a container processes that reads from stdin will never receive an EOF.
  // Default is false
  optional bool stdin_once = 22 [(dev.f110.kubeproto.field) = { go_name: "StdinOnce", api_field_name: "stdinOnce", inline: false }];
  // Whether this container should allocate a TTY for itself, also requires 'stdin' to be true.
  // Default is false.
  optional bool tty = 23 [(dev.f110.kubeproto.field) = { go_name: "TTY", api_field_name: "tty", inline: false }];
}

message EphemeralVolumeSource {
  // Will be used to create a stand-alone PVC to provision the volume.
  // The pod in which this EphemeralVolumeSource is embedded will be the
  // owner of the PVC, i.e. the PVC will be deleted together with the
  // pod.  The name of the PVC will be `<pod name>-<volume name>` where
  // `<volume name>` is the name from the `PodSpec.Volumes` array
  // entry. Pod validation will reject the pod if the concatenated name
  // is not valid for a PVC (for example, too long).
  // An existing PVC with that name that is not owned by the pod
  // will *not* be used for the pod to avoid using an unrelated
  // volume by mistake. Starting the pod is then blocked until
  // the unrelated PVC is removed. If such a pre-created PVC is
  // meant to be used by the pod, the PVC has to updated with an
  // owner reference to the pod once the pod exists. Normally
  // this should not be necessary, but it may be useful when
  // manually reconstructing a broken cluster.
  // This field is read-only and no changes will be made by Kubernetes
  // to the PVC after it has been created.
  // Required, must not be nil.
  optional PersistentVolumeClaimTemplate volume_claim_template = 1 [(dev.f110.kubeproto.field) = { go_name: "VolumeClaimTemplate", api_field_name: "volumeClaimTemplate", inline: false }];
}

message Event {
  // The object that this event is about.
  ObjectReference involved_object = 3 [(dev.f110.kubeproto.field) = { go_name: "InvolvedObject", api_field_name: "involvedObject", inline: false }];
  // This should be a short, machine understandable string that gives the reason
  // for the transition into the object's current status.
  optional string reason = 4 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // A human-readable description of the status of this operation.
  optional string message = 5 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
  // The component reporting this event. Should be a short machine understandable string.
  optional EventSource source = 6 [(dev.f110.kubeproto.field) = { go_name: "Source", api_field_name: "source", inline: false }];
  // The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time first_timestamp = 7 [(dev.f110.kubeproto.field) = { go_name: "FirstTimestamp", api_field_name: "firstTimestamp", inline: false }];
  // The time at which the most recent occurrence of this event was recorded.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_timestamp = 8 [(dev.f110.kubeproto.field) = { go_name: "LastTimestamp", api_field_name: "lastTimestamp", inline: false }];
  // The number of times this event has occurred.
  optional int32 count = 9 [(dev.f110.kubeproto.field) = { go_name: "Count", api_field_name: "count", inline: false }];
  // Type of this event (Normal, Warning), new types could be added in the future
  optional string type = 10 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Time when this Event was first observed.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime event_time = 11 [(dev.f110.kubeproto.field) = { go_name: "EventTime", api_field_name: "eventTime", inline: false }];
  // Data about the Event series this event represents or nil if it's a singleton Event.
  optional EventSeries series = 12 [(dev.f110.kubeproto.field) = { go_name: "Series", api_field_name: "series", inline: false }];
  // What action was taken/failed regarding to the Regarding object.
  optional string action = 13 [(dev.f110.kubeproto.field) = { go_name: "Action", api_field_name: "action", inline: false }];
  // Optional secondary object for more complex actions.
  optional ObjectReference related = 14 [(dev.f110.kubeproto.field) = { go_name: "Related", api_field_name: "related", inline: false }];
  // Name of the controller that emitted this Event, e.g. `kubernetes.io/kubelet`.
  string reporting_controller = 15 [(dev.f110.kubeproto.field) = { go_name: "ReportingController", api_field_name: "reportingComponent", inline: false }];
  // ID of the controller instance, e.g. `kubelet-xyzf`.
  string reporting_instance = 16 [(dev.f110.kubeproto.field) = { go_name: "ReportingInstance", api_field_name: "reportingInstance", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message EventList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of events
  repeated Event items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message EventSeries {
  // Number of occurrences in this series up to the last heartbeat time
  optional int32 count = 1 [(dev.f110.kubeproto.field) = { go_name: "Count", api_field_name: "count", inline: false }];
  // Time of the last occurrence observed
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime last_observed_time = 2 [(dev.f110.kubeproto.field) = { go_name: "LastObservedTime", api_field_name: "lastObservedTime", inline: false }];
}

message EventSource {
  // Component from which the event is generated.
  optional string component = 1 [(dev.f110.kubeproto.field) = { go_name: "Component", api_field_name: "component", inline: false }];
  // Node name on which the event is generated.
  optional string host = 2 [(dev.f110.kubeproto.field) = { go_name: "Host", api_field_name: "host", inline: false }];
}

message ExecAction {
  // Command is the command line to execute inside the container, the working directory for the
  // command  is root ('/') in the container's filesystem. The command is simply exec'd, it is
  // not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use
  // a shell, you need to explicitly call out to that shell.
  // Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
  repeated string command = 1 [(dev.f110.kubeproto.field) = { go_name: "Command", api_field_name: "command", inline: false }];
}

message FCVolumeSource {
  // targetWWNs is Optional: FC target worldwide names (WWNs)
  repeated string target_wwns = 1 [(dev.f110.kubeproto.field) = { go_name: "TargetWWNs", api_field_name: "targetWWNs", inline: false }];
  // lun is Optional: FC target lun number
  optional int32 lun = 2 [(dev.f110.kubeproto.field) = { go_name: "Lun", api_field_name: "lun", inline: false }];
  // fsType is the filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  optional string fs_type = 3 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // readOnly is Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool read_only = 4 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // wwids Optional: FC volume world wide identifiers (wwids)
  // Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
  repeated string wwids = 5 [(dev.f110.kubeproto.field) = { go_name: "WWIDs", api_field_name: "wwids", inline: false }];
}

message FlexPersistentVolumeSource {
  // driver is the name of the driver to use for this volume.
  string driver = 1 [(dev.f110.kubeproto.field) = { go_name: "Driver", api_field_name: "driver", inline: false }];
  // fsType is the Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
  optional string fs_type = 2 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // secretRef is Optional: SecretRef is reference to the secret object containing
  // sensitive information to pass to the plugin scripts. This may be
  // empty if no secret object is specified. If the secret object
  // contains more than one secret, all secrets are passed to the plugin
  // scripts.
  optional SecretReference secret_ref = 3 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
  // readOnly is Optional: defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool read_only = 4 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // options is Optional: this field holds extra command options if any.
  map<string, string> options = 5 [(dev.f110.kubeproto.field) = { go_name: "Options", api_field_name: "options", inline: false }];
}

message FlexVolumeSource {
  // driver is the name of the driver to use for this volume.
  string driver = 1 [(dev.f110.kubeproto.field) = { go_name: "Driver", api_field_name: "driver", inline: false }];
  // fsType is the filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
  optional string fs_type = 2 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // secretRef is Optional: secretRef is reference to the secret object containing
  // sensitive information to pass to the plugin scripts. This may be
  // empty if no secret object is specified. If the secret object
  // contains more than one secret, all secrets are passed to the plugin
  // scripts.
  optional LocalObjectReference secret_ref = 3 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
  // readOnly is Optional: defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool read_only = 4 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // options is Optional: this field holds extra command options if any.
  map<string, string> options = 5 [(dev.f110.kubeproto.field) = { go_name: "Options", api_field_name: "options", inline: false }];
}

message FlockerVolumeSource {
  // datasetName is Name of the dataset stored as metadata -> name on the dataset for Flocker
  // should be considered as deprecated
  optional string dataset_name = 1 [(dev.f110.kubeproto.field) = { go_name: "DatasetName", api_field_name: "datasetName", inline: false }];
  // datasetUUID is the UUID of the dataset. This is unique identifier of a Flocker dataset
  optional string dataset_uuid = 2 [(dev.f110.kubeproto.field) = { go_name: "DatasetUUID", api_field_name: "datasetUUID", inline: false }];
}

message GCEPersistentDiskVolumeSource {
  // pdName is unique name of the PD resource in GCE. Used to identify the disk in GCE.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  string p_d_name = 1 [(dev.f110.kubeproto.field) = { go_name: "PDName", api_field_name: "pdName", inline: false }];
  // fsType is filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  optional string fs_type = 2 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // partition is the partition in the volume that you want to mount.
  // If omitted, the default is to mount by volume name.
  // Examples: For volume /dev/sda1, you specify the partition as "1".
  // Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  optional int32 partition = 3 [(dev.f110.kubeproto.field) = { go_name: "Partition", api_field_name: "partition", inline: false }];
  // readOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  optional bool read_only = 4 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
}

message GRPCAction {
  // Port number of the gRPC service. Number must be in the range 1 to 65535.
  int32 port = 1 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // Service is the name of the service to place in the gRPC HealthCheckRequest
  // (see https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
  // If this is not specified, the default behavior is defined by gRPC.
  optional string service = 2 [(dev.f110.kubeproto.field) = { go_name: "Service", api_field_name: "service", inline: false }];
}

message GitRepoVolumeSource {
  // repository is the URL
  string repository = 1 [(dev.f110.kubeproto.field) = { go_name: "Repository", api_field_name: "repository", inline: false }];
  // revision is the commit hash for the specified revision.
  optional string revision = 2 [(dev.f110.kubeproto.field) = { go_name: "Revision", api_field_name: "revision", inline: false }];
  // directory is the target directory name.
  // Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
  // git repository.  Otherwise, if specified, the volume will contain the git repository in
  // the subdirectory with the given name.
  optional string directory = 3 [(dev.f110.kubeproto.field) = { go_name: "Directory", api_field_name: "directory", inline: false }];
}

message GlusterfsPersistentVolumeSource {
  // endpoints is the endpoint name that details Glusterfs topology.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  string endpoints_name = 1 [(dev.f110.kubeproto.field) = { go_name: "EndpointsName", api_field_name: "endpoints", inline: false }];
  // path is the Glusterfs volume path.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  string path = 2 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
  // Defaults to false.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  optional bool read_only = 3 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // endpointsNamespace is the namespace that contains Glusterfs endpoint.
  // If this field is empty, the EndpointNamespace defaults to the same namespace as the bound PVC.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  optional string endpoints_namespace = 4 [(dev.f110.kubeproto.field) = { go_name: "EndpointsNamespace", api_field_name: "endpointsNamespace", inline: false }];
}

message GlusterfsVolumeSource {
  // endpoints is the endpoint name that details Glusterfs topology.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  string endpoints_name = 1 [(dev.f110.kubeproto.field) = { go_name: "EndpointsName", api_field_name: "endpoints", inline: false }];
  // path is the Glusterfs volume path.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  string path = 2 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // readOnly here will force the Glusterfs volume to be mounted with read-only permissions.
  // Defaults to false.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod
  optional bool read_only = 3 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
}

message HTTPGetAction {
  // Path to access on the HTTP server.
  optional string path = 1 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // Name or number of the port to access on the container.
  // Number must be in the range 1 to 65535.
  // Name must be an IANA_SVC_NAME.
  .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // Host name to connect to, defaults to the pod IP. You probably want to set
  // "Host" in httpHeaders instead.
  optional string host = 3 [(dev.f110.kubeproto.field) = { go_name: "Host", api_field_name: "host", inline: false }];
  // Scheme to use for connecting to the host.
  // Defaults to HTTP.
  optional URIScheme scheme = 4 [(dev.f110.kubeproto.field) = { go_name: "Scheme", api_field_name: "scheme", inline: false }];
  // Custom headers to set in the request. HTTP allows repeated headers.
  repeated HTTPHeader http_headers = 5 [(dev.f110.kubeproto.field) = { go_name: "HTTPHeaders", api_field_name: "httpHeaders", inline: false }];
}

message HTTPHeader {
  // The header field name
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // The header field value
  string value = 2 [(dev.f110.kubeproto.field) = { go_name: "Value", api_field_name: "value", inline: false }];
}

message HostAlias {
  // IP address of the host file entry.
  optional string ip = 1 [(dev.f110.kubeproto.field) = { go_name: "IP", api_field_name: "ip", inline: false }];
  // Hostnames for the above IP address.
  repeated string hostnames = 2 [(dev.f110.kubeproto.field) = { go_name: "Hostnames", api_field_name: "hostnames", inline: false }];
}

message HostPathVolumeSource {
  // path of the directory on the host.
  // If the path is a symlink, it will follow the link to the real path.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  string path = 1 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // type for HostPath Volume
  // Defaults to ""
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  optional HostPathType type = 2 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
}

message ISCSIPersistentVolumeSource {
  // targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
  // is other than default (typically TCP ports 860 and 3260).
  string target_portal = 1 [(dev.f110.kubeproto.field) = { go_name: "TargetPortal", api_field_name: "targetPortal", inline: false }];
  // iqn is Target iSCSI Qualified Name.
  string iqn = 2 [(dev.f110.kubeproto.field) = { go_name: "IQN", api_field_name: "iqn", inline: false }];
  // lun is iSCSI Target Lun number.
  int32 lun = 3 [(dev.f110.kubeproto.field) = { go_name: "Lun", api_field_name: "lun", inline: false }];
  // iscsiInterface is the interface Name that uses an iSCSI transport.
  // Defaults to 'default' (tcp).
  optional string iscsi_interface = 4 [(dev.f110.kubeproto.field) = { go_name: "ISCSIInterface", api_field_name: "iscsiInterface", inline: false }];
  // fsType is the filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
  optional string fs_type = 5 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // readOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  optional bool read_only = 6 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // portals is the iSCSI Target Portal List. The Portal is either an IP or ip_addr:port if the port
  // is other than default (typically TCP ports 860 and 3260).
  repeated string portals = 7 [(dev.f110.kubeproto.field) = { go_name: "Portals", api_field_name: "portals", inline: false }];
  // chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
  optional bool discovery_chap_auth = 8 [(dev.f110.kubeproto.field) = { go_name: "DiscoveryCHAPAuth", api_field_name: "chapAuthDiscovery", inline: false }];
  // chapAuthSession defines whether support iSCSI Session CHAP authentication
  optional bool session_chap_auth = 9 [(dev.f110.kubeproto.field) = { go_name: "SessionCHAPAuth", api_field_name: "chapAuthSession", inline: false }];
  // secretRef is the CHAP Secret for iSCSI target and initiator authentication
  optional SecretReference secret_ref = 10 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
  // initiatorName is the custom iSCSI Initiator Name.
  // If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
  // <target portal>:<volume name> will be created for the connection.
  optional string initiator_name = 11 [(dev.f110.kubeproto.field) = { go_name: "InitiatorName", api_field_name: "initiatorName", inline: false }];
}

message ISCSIVolumeSource {
  // targetPortal is iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port
  // is other than default (typically TCP ports 860 and 3260).
  string target_portal = 1 [(dev.f110.kubeproto.field) = { go_name: "TargetPortal", api_field_name: "targetPortal", inline: false }];
  // iqn is the target iSCSI Qualified Name.
  string iqn = 2 [(dev.f110.kubeproto.field) = { go_name: "IQN", api_field_name: "iqn", inline: false }];
  // lun represents iSCSI Target Lun number.
  int32 lun = 3 [(dev.f110.kubeproto.field) = { go_name: "Lun", api_field_name: "lun", inline: false }];
  // iscsiInterface is the interface Name that uses an iSCSI transport.
  // Defaults to 'default' (tcp).
  optional string iscsi_interface = 4 [(dev.f110.kubeproto.field) = { go_name: "ISCSIInterface", api_field_name: "iscsiInterface", inline: false }];
  // fsType is the filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
  optional string fs_type = 5 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // readOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  optional bool read_only = 6 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // portals is the iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port
  // is other than default (typically TCP ports 860 and 3260).
  repeated string portals = 7 [(dev.f110.kubeproto.field) = { go_name: "Portals", api_field_name: "portals", inline: false }];
  // chapAuthDiscovery defines whether support iSCSI Discovery CHAP authentication
  optional bool discovery_chap_auth = 8 [(dev.f110.kubeproto.field) = { go_name: "DiscoveryCHAPAuth", api_field_name: "chapAuthDiscovery", inline: false }];
  // chapAuthSession defines whether support iSCSI Session CHAP authentication
  optional bool session_chap_auth = 9 [(dev.f110.kubeproto.field) = { go_name: "SessionCHAPAuth", api_field_name: "chapAuthSession", inline: false }];
  // secretRef is the CHAP Secret for iSCSI target and initiator authentication
  optional LocalObjectReference secret_ref = 10 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
  // initiatorName is the custom iSCSI Initiator Name.
  // If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface
  // <target portal>:<volume name> will be created for the connection.
  optional string initiator_name = 11 [(dev.f110.kubeproto.field) = { go_name: "InitiatorName", api_field_name: "initiatorName", inline: false }];
}

message KeyToPath {
  // key is the key to project.
  string key = 1 [(dev.f110.kubeproto.field) = { go_name: "Key", api_field_name: "key", inline: false }];
  // path is the relative path of the file to map the key to.
  // May not be an absolute path.
  // May not contain the path element '..'.
  // May not start with the string '..'.
  string path = 2 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // mode is Optional: mode bits used to set permissions on this file.
  // Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
  // YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
  // If not specified, the volume defaultMode will be used.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  optional int32 mode = 3 [(dev.f110.kubeproto.field) = { go_name: "Mode", api_field_name: "mode", inline: false }];
}

message Lifecycle {
  // PostStart is called immediately after a container is created. If the handler fails,
  // the container is terminated and restarted according to its restart policy.
  // Other management of the container blocks until the hook completes.
  // More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  optional LifecycleHandler post_start = 1 [(dev.f110.kubeproto.field) = { go_name: "PostStart", api_field_name: "postStart", inline: false }];
  // PreStop is called immediately before a container is terminated due to an
  // API request or management event such as liveness/startup probe failure,
  // preemption, resource contention, etc. The handler is not called if the
  // container crashes or exits. The Pod's termination grace period countdown begins before the
  // PreStop hook is executed. Regardless of the outcome of the handler, the
  // container will eventually terminate within the Pod's termination grace
  // period (unless delayed by finalizers). Other management of the container blocks until the hook completes
  // or until the termination grace period is reached.
  // More info: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-hooks
  optional LifecycleHandler pre_stop = 2 [(dev.f110.kubeproto.field) = { go_name: "PreStop", api_field_name: "preStop", inline: false }];
}

message LifecycleHandler {
  // Exec specifies the action to take.
  optional ExecAction exec = 1 [(dev.f110.kubeproto.field) = { go_name: "Exec", api_field_name: "exec", inline: false }];
  // HTTPGet specifies the http request to perform.
  optional HTTPGetAction http_get = 2 [(dev.f110.kubeproto.field) = { go_name: "HTTPGet", api_field_name: "httpGet", inline: false }];
  // Deprecated. TCPSocket is NOT supported as a LifecycleHandler and kept
  // for the backward compatibility. There are no validation of this field and
  // lifecycle hooks will fail in runtime when tcp handler is specified.
  optional TCPSocketAction tcp_socket = 3 [(dev.f110.kubeproto.field) = { go_name: "TCPSocket", api_field_name: "tcpSocket", inline: false }];
}

message LimitRange {
  // Spec defines the limits enforced.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional LimitRangeSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message LimitRangeItem {
  // Type of resource that this limit applies to.
  LimitType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Max usage constraints on this kind by resource name.
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> max = 2 [(dev.f110.kubeproto.field) = { go_name: "Max", api_field_name: "max", inline: false }];
  // Min usage constraints on this kind by resource name.
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> min = 3 [(dev.f110.kubeproto.field) = { go_name: "Min", api_field_name: "min", inline: false }];
  // Default resource requirement limit value by resource name if resource limit is omitted.
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> default = 4 [(dev.f110.kubeproto.field) = { go_name: "Default", api_field_name: "default", inline: false }];
  // DefaultRequest is the default resource requirement request value by resource name if resource request is omitted.
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> default_request = 5 [(dev.f110.kubeproto.field) = { go_name: "DefaultRequest", api_field_name: "defaultRequest", inline: false }];
  // MaxLimitRequestRatio if specified, the named resource must have a request and limit that are both non-zero where limit divided by request is less than or equal to the enumerated value; this represents the max burst for the named resource.
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> max_limit_request_ratio = 6 [(dev.f110.kubeproto.field) = { go_name: "MaxLimitRequestRatio", api_field_name: "maxLimitRequestRatio", inline: false }];
}

message LimitRangeList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // Items is a list of LimitRange objects.
  // More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  repeated LimitRange items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message LimitRangeSpec {
  // Limits is the list of LimitRangeItem objects that are enforced.
  repeated LimitRangeItem limits = 1 [(dev.f110.kubeproto.field) = { go_name: "Limits", api_field_name: "limits", inline: false }];
}

message LoadBalancerIngress {
  // IP is set for load-balancer ingress points that are IP based
  // (typically GCE or OpenStack load-balancers)
  optional string ip = 1 [(dev.f110.kubeproto.field) = { go_name: "IP", api_field_name: "ip", inline: false }];
  // Hostname is set for load-balancer ingress points that are DNS based
  // (typically AWS load-balancers)
  optional string hostname = 2 [(dev.f110.kubeproto.field) = { go_name: "Hostname", api_field_name: "hostname", inline: false }];
  // Ports is a list of records of service ports
  // If used, every port defined in the service should have an entry in it
  repeated PortStatus ports = 3 [(dev.f110.kubeproto.field) = { go_name: "Ports", api_field_name: "ports", inline: false }];
}

message LoadBalancerStatus {
  // Ingress is a list containing ingress points for the load-balancer.
  // Traffic intended for the service should be sent to these ingress points.
  repeated LoadBalancerIngress ingress = 1 [(dev.f110.kubeproto.field) = { go_name: "Ingress", api_field_name: "ingress", inline: false }];
}

message LocalObjectReference {
  // Name of the referent.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  optional string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
}

message LocalVolumeSource {
  // path of the full path to the volume on the node.
  // It can be either a directory or block device (disk, partition, ...).
  string path = 1 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // fsType is the filesystem type to mount.
  // It applies only when the Path is a block device.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". The default value is to auto-select a filesystem if unspecified.
  optional string fs_type = 2 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
}

message NFSVolumeSource {
  // server is the hostname or IP address of the NFS server.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  string server = 1 [(dev.f110.kubeproto.field) = { go_name: "Server", api_field_name: "server", inline: false }];
  // path that is exported by the NFS server.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  string path = 2 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // readOnly here will force the NFS export to be mounted with read-only permissions.
  // Defaults to false.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  optional bool read_only = 3 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
}

message Namespace {
  // Spec defines the behavior of the Namespace.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional NamespaceSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status describes the current status of a Namespace.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional NamespaceStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", sub_resource: true, inline: false }];

  option (dev.f110.kubeproto.kind) = {
    scope: SCOPE_CLUSTER
  };
}

message NamespaceCondition {
  // Type of namespace controller condition.
  NamespaceConditionType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Status of the condition, one of True, False, Unknown.
  ConditionStatus                                     status               = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
  optional string                                     reason               = 4 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  optional string                                     message              = 5 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message NamespaceList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // Items is the list of Namespace objects in the list.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  repeated Namespace items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message NamespaceSpec {
  // Finalizers is an opaque list of values that must be empty to permanently remove object from storage.
  // More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
  repeated FinalizerName finalizers = 1 [(dev.f110.kubeproto.field) = { go_name: "Finalizers", api_field_name: "finalizers", inline: false }];
}

message NamespaceStatus {
  // Phase is the current lifecycle phase of the namespace.
  // More info: https://kubernetes.io/docs/tasks/administer-cluster/namespaces/
  optional NamespacePhase phase = 1 [(dev.f110.kubeproto.field) = { go_name: "Phase", api_field_name: "phase", inline: false }];
  // Represents the latest available observations of a namespace's current state.
  repeated NamespaceCondition conditions = 2 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
}

message Node {
  // Spec defines the behavior of a node.
  // https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional NodeSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Most recently observed status of the node.
  // Populated by the system.
  // Read-only.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional NodeStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", sub_resource: true, inline: false }];

  option (dev.f110.kubeproto.kind) = {
    scope: SCOPE_CLUSTER
  };
}

message NodeAddress {
  // Node address type, one of Hostname, ExternalIP or InternalIP.
  NodeAddressType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // The node address.
  string address = 2 [(dev.f110.kubeproto.field) = { go_name: "Address", api_field_name: "address", inline: false }];
}

message NodeAffinity {
  // If the affinity requirements specified by this field are not met at
  // scheduling time, the pod will not be scheduled onto the node.
  // If the affinity requirements specified by this field cease to be met
  // at some point during pod execution (e.g. due to an update), the system
  // may or may not try to eventually evict the pod from its node.
  optional NodeSelector required_during_scheduling_ignored_during_execution = 1 [(dev.f110.kubeproto.field) = { go_name: "RequiredDuringSchedulingIgnoredDuringExecution", api_field_name: "requiredDuringSchedulingIgnoredDuringExecution", inline: false }];
  // The scheduler will prefer to schedule pods to nodes that satisfy
  // the affinity expressions specified by this field, but it may choose
  // a node that violates one or more of the expressions. The node that is
  // most preferred is the one with the greatest sum of weights, i.e.
  // for each node that meets all of the scheduling requirements (resource
  // request, requiredDuringScheduling affinity expressions, etc.),
  // compute a sum by iterating through the elements of this field and adding
  // "weight" to the sum if the node matches the corresponding matchExpressions; the
  // node(s) with the highest sum are the most preferred.
  repeated PreferredSchedulingTerm preferred_during_scheduling_ignored_during_execution = 2 [(dev.f110.kubeproto.field) = { go_name: "PreferredDuringSchedulingIgnoredDuringExecution", api_field_name: "preferredDuringSchedulingIgnoredDuringExecution", inline: false }];
}

message NodeCondition {
  // Type of node condition.
  NodeConditionType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Status of the condition, one of True, False, Unknown.
  ConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // Last time we got an update on a given condition.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_heartbeat_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastHeartbeatTime", api_field_name: "lastHeartbeatTime", inline: false }];
  // Last time the condition transit from one status to another.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 4 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
  // (brief) reason for the condition's last transition.
  optional string reason = 5 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // Human readable message indicating details about last transition.
  optional string message = 6 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message NodeConfigSource {
  // ConfigMap is a reference to a Node's ConfigMap
  optional ConfigMapNodeConfigSource config_map = 1 [(dev.f110.kubeproto.field) = { go_name: "ConfigMap", api_field_name: "configMap", inline: false }];
}

message NodeConfigStatus {
  // Assigned reports the checkpointed config the node will try to use.
  // When Node.Spec.ConfigSource is updated, the node checkpoints the associated
  // config payload to local disk, along with a record indicating intended
  // config. The node refers to this record to choose its config checkpoint, and
  // reports this record in Assigned. Assigned only updates in the status after
  // the record has been checkpointed to disk. When the Kubelet is restarted,
  // it tries to make the Assigned config the Active config by loading and
  // validating the checkpointed payload identified by Assigned.
  optional NodeConfigSource assigned = 1 [(dev.f110.kubeproto.field) = { go_name: "Assigned", api_field_name: "assigned", inline: false }];
  // Active reports the checkpointed config the node is actively using.
  // Active will represent either the current version of the Assigned config,
  // or the current LastKnownGood config, depending on whether attempting to use the
  // Assigned config results in an error.
  optional NodeConfigSource active = 2 [(dev.f110.kubeproto.field) = { go_name: "Active", api_field_name: "active", inline: false }];
  // LastKnownGood reports the checkpointed config the node will fall back to
  // when it encounters an error attempting to use the Assigned config.
  // The Assigned config becomes the LastKnownGood config when the node determines
  // that the Assigned config is stable and correct.
  // This is currently implemented as a 10-minute soak period starting when the local
  // record of Assigned config is updated. If the Assigned config is Active at the end
  // of this period, it becomes the LastKnownGood. Note that if Spec.ConfigSource is
  // reset to nil (use local defaults), the LastKnownGood is also immediately reset to nil,
  // because the local default config is always assumed good.
  // You should not make assumptions about the node's method of determining config stability
  // and correctness, as this may change or become configurable in the future.
  optional NodeConfigSource last_known_good = 3 [(dev.f110.kubeproto.field) = { go_name: "LastKnownGood", api_field_name: "lastKnownGood", inline: false }];
  // Error describes any problems reconciling the Spec.ConfigSource to the Active config.
  // Errors may occur, for example, attempting to checkpoint Spec.ConfigSource to the local Assigned
  // record, attempting to checkpoint the payload associated with Spec.ConfigSource, attempting
  // to load or validate the Assigned config, etc.
  // Errors may occur at different points while syncing config. Earlier errors (e.g. download or
  // checkpointing errors) will not result in a rollback to LastKnownGood, and may resolve across
  // Kubelet retries. Later errors (e.g. loading or validating a checkpointed config) will result in
  // a rollback to LastKnownGood. In the latter case, it is usually possible to resolve the error
  // by fixing the config assigned in Spec.ConfigSource.
  // You can find additional information for debugging by searching the error message in the Kubelet log.
  // Error is a human-readable description of the error state; machines can check whether or not Error
  // is empty, but should not rely on the stability of the Error text across Kubelet versions.
  optional string error = 4 [(dev.f110.kubeproto.field) = { go_name: "Error", api_field_name: "error", inline: false }];
}

message NodeDaemonEndpoints {
  // Endpoint on which Kubelet is listening.
  optional DaemonEndpoint kubelet_endpoint = 1 [(dev.f110.kubeproto.field) = { go_name: "KubeletEndpoint", api_field_name: "kubeletEndpoint", inline: false }];
}

message NodeList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of nodes
  repeated Node items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message NodeProxyOptions {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Path is the URL path to use for the current proxy request to node.
  optional string path = 2 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
}

message NodeResources {
  // Capacity represents the available resources of a node
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1 [(dev.f110.kubeproto.field) = { go_name: "Capacity", inline: false }];
}

message NodeSelector {
  // Required. A list of node selector terms. The terms are ORed.
  repeated NodeSelectorTerm node_selector_terms = 1 [(dev.f110.kubeproto.field) = { go_name: "NodeSelectorTerms", api_field_name: "nodeSelectorTerms", inline: false }];
}

message NodeSelectorRequirement {
  // The label key that the selector applies to.
  string key = 1 [(dev.f110.kubeproto.field) = { go_name: "Key", api_field_name: "key", inline: false }];
  // Represents a key's relationship to a set of values.
  // Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
  NodeSelectorOperator operator = 2 [(dev.f110.kubeproto.field) = { go_name: "Operator", api_field_name: "operator", inline: false }];
  // An array of string values. If the operator is In or NotIn,
  // the values array must be non-empty. If the operator is Exists or DoesNotExist,
  // the values array must be empty. If the operator is Gt or Lt, the values
  // array must have a single element, which will be interpreted as an integer.
  // This array is replaced during a strategic merge patch.
  repeated string values = 3 [(dev.f110.kubeproto.field) = { go_name: "Values", api_field_name: "values", inline: false }];
}

message NodeSelectorTerm {
  // A list of node selector requirements by node's labels.
  repeated NodeSelectorRequirement match_expressions = 1 [(dev.f110.kubeproto.field) = { go_name: "MatchExpressions", api_field_name: "matchExpressions", inline: false }];
  // A list of node selector requirements by node's fields.
  repeated NodeSelectorRequirement match_fields = 2 [(dev.f110.kubeproto.field) = { go_name: "MatchFields", api_field_name: "matchFields", inline: false }];
}

message NodeSpec {
  // PodCIDR represents the pod IP range assigned to the node.
  optional string pod_cidr = 1 [(dev.f110.kubeproto.field) = { go_name: "PodCIDR", api_field_name: "podCIDR", inline: false }];
  // podCIDRs represents the IP ranges assigned to the node for usage by Pods on that node. If this
  // field is specified, the 0th entry must match the podCIDR field. It may contain at most 1 value for
  // each of IPv4 and IPv6.
  repeated string pod_cidrs = 2 [(dev.f110.kubeproto.field) = { go_name: "PodCIDRs", api_field_name: "podCIDRs", inline: false }];
  // ID of the node assigned by the cloud provider in the format: <ProviderName>://<ProviderSpecificNodeID>
  optional string provider_id = 3 [(dev.f110.kubeproto.field) = { go_name: "ProviderID", api_field_name: "providerID", inline: false }];
  // Unschedulable controls node schedulability of new pods. By default, node is schedulable.
  // More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
  optional bool unschedulable = 4 [(dev.f110.kubeproto.field) = { go_name: "Unschedulable", api_field_name: "unschedulable", inline: false }];
  // If specified, the node's taints.
  repeated Taint taints = 5 [(dev.f110.kubeproto.field) = { go_name: "Taints", api_field_name: "taints", inline: false }];
  // Deprecated: Previously used to specify the source of the node's configuration for the DynamicKubeletConfig feature. This feature is removed.
  optional NodeConfigSource config_source = 6 [(dev.f110.kubeproto.field) = { go_name: "ConfigSource", api_field_name: "configSource", inline: false }];
  // Deprecated. Not all kubelets will set this field. Remove field after 1.13.
  // see: https://issues.k8s.io/61966
  optional string do_not_use_external_id = 7 [(dev.f110.kubeproto.field) = { go_name: "DoNotUseExternalID", api_field_name: "externalID", inline: false }];
}

message NodeStatus {
  // Capacity represents the total resources of a node.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1 [(dev.f110.kubeproto.field) = { go_name: "Capacity", api_field_name: "capacity", inline: false }];
  // Allocatable represents the resources of a node that are available for scheduling.
  // Defaults to Capacity.
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> allocatable = 2 [(dev.f110.kubeproto.field) = { go_name: "Allocatable", api_field_name: "allocatable", inline: false }];
  // NodePhase is the recently observed lifecycle phase of the node.
  // More info: https://kubernetes.io/docs/concepts/nodes/node/#phase
  // The field is never populated, and now is deprecated.
  optional NodePhase phase = 3 [(dev.f110.kubeproto.field) = { go_name: "Phase", api_field_name: "phase", inline: false }];
  // Conditions is an array of current observed node conditions.
  // More info: https://kubernetes.io/docs/concepts/nodes/node/#condition
  repeated NodeCondition conditions = 4 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
  // List of addresses reachable to the node.
  // Queried from cloud provider, if available.
  // More info: https://kubernetes.io/docs/concepts/nodes/node/#addresses
  // Note: This field is declared as mergeable, but the merge key is not sufficiently
  // unique, which can cause data corruption when it is merged. Callers should instead
  // use a full-replacement patch. See https://pr.k8s.io/79391 for an example.
  // Consumers should assume that addresses can change during the
  // lifetime of a Node. However, there are some exceptions where this may not
  // be possible, such as Pods that inherit a Node's address in its own status or
  // consumers of the downward API (status.hostIP).
  repeated NodeAddress addresses = 5 [(dev.f110.kubeproto.field) = { go_name: "Addresses", api_field_name: "addresses", inline: false }];
  // Endpoints of daemons running on the Node.
  optional NodeDaemonEndpoints daemon_endpoints = 6 [(dev.f110.kubeproto.field) = { go_name: "DaemonEndpoints", api_field_name: "daemonEndpoints", inline: false }];
  // Set of ids/uuids to uniquely identify the node.
  // More info: https://kubernetes.io/docs/concepts/nodes/node/#info
  optional NodeSystemInfo node_info = 7 [(dev.f110.kubeproto.field) = { go_name: "NodeInfo", api_field_name: "nodeInfo", inline: false }];
  // List of container images on this node
  repeated ContainerImage images = 8 [(dev.f110.kubeproto.field) = { go_name: "Images", api_field_name: "images", inline: false }];
  // List of attachable volumes in use (mounted) by the node.
  repeated string volumes_in_use = 9 [(dev.f110.kubeproto.field) = { go_name: "VolumesInUse", api_field_name: "volumesInUse", inline: false }];
  // List of volumes that are attached to the node.
  repeated AttachedVolume volumes_attached = 10 [(dev.f110.kubeproto.field) = { go_name: "VolumesAttached", api_field_name: "volumesAttached", inline: false }];
  // Status of the config assigned to the node via the dynamic Kubelet config feature.
  optional NodeConfigStatus config = 11 [(dev.f110.kubeproto.field) = { go_name: "Config", api_field_name: "config", inline: false }];
}

message NodeSystemInfo {
  // MachineID reported by the node. For unique machine identification
  // in the cluster this field is preferred. Learn more from man(5)
  // machine-id: http://man7.org/linux/man-pages/man5/machine-id.5.html
  string machine_id = 1 [(dev.f110.kubeproto.field) = { go_name: "MachineID", api_field_name: "machineID", inline: false }];
  // SystemUUID reported by the node. For unique machine identification
  // MachineID is preferred. This field is specific to Red Hat hosts
  // https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html/rhsm/uuid
  string system_uuid = 2 [(dev.f110.kubeproto.field) = { go_name: "SystemUUID", api_field_name: "systemUUID", inline: false }];
  // Boot ID reported by the node.
  string boot_id = 3 [(dev.f110.kubeproto.field) = { go_name: "BootID", api_field_name: "bootID", inline: false }];
  // Kernel Version reported by the node from 'uname -r' (e.g. 3.16.0-0.bpo.4-amd64).
  string kernel_version = 4 [(dev.f110.kubeproto.field) = { go_name: "KernelVersion", api_field_name: "kernelVersion", inline: false }];
  // OS Image reported by the node from /etc/os-release (e.g. Debian GNU/Linux 7 (wheezy)).
  string os_image = 5 [(dev.f110.kubeproto.field) = { go_name: "OSImage", api_field_name: "osImage", inline: false }];
  // ContainerRuntime Version reported by the node through runtime remote API (e.g. containerd://1.4.2).
  string container_runtime_version = 6 [(dev.f110.kubeproto.field) = { go_name: "ContainerRuntimeVersion", api_field_name: "containerRuntimeVersion", inline: false }];
  // Kubelet Version reported by the node.
  string kubelet_version = 7 [(dev.f110.kubeproto.field) = { go_name: "KubeletVersion", api_field_name: "kubeletVersion", inline: false }];
  // KubeProxy Version reported by the node.
  string kube_proxy_version = 8 [(dev.f110.kubeproto.field) = { go_name: "KubeProxyVersion", api_field_name: "kubeProxyVersion", inline: false }];
  // The Operating System reported by the node
  string operating_system = 9 [(dev.f110.kubeproto.field) = { go_name: "OperatingSystem", api_field_name: "operatingSystem", inline: false }];
  // The Architecture reported by the node
  string architecture = 10 [(dev.f110.kubeproto.field) = { go_name: "Architecture", api_field_name: "architecture", inline: false }];
}

message ObjectFieldSelector {
  // Version of the schema the FieldPath is written in terms of, defaults to "v1".
  optional string api_version = 1 [(dev.f110.kubeproto.field) = { go_name: "APIVersion", api_field_name: "apiVersion", inline: false }];
  // Path of the field to select in the specified API version.
  string field_path = 2 [(dev.f110.kubeproto.field) = { go_name: "FieldPath", api_field_name: "fieldPath", inline: false }];
}

message ObjectReference {
  // Kind of the referent.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional string kind = 1 [(dev.f110.kubeproto.field) = { go_name: "Kind", api_field_name: "kind", inline: false }];
  // Namespace of the referent.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
  optional string namespace = 2 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
  // Name of the referent.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  optional string name = 3 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // UID of the referent.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
  optional string uid = 4 [(dev.f110.kubeproto.field) = { go_name: "UID", api_field_name: "uid", inline: false }];
  // API version of the referent.
  optional string api_version = 5 [(dev.f110.kubeproto.field) = { go_name: "APIVersion", api_field_name: "apiVersion", inline: false }];
  // Specific resourceVersion to which this reference is made, if any.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
  optional string resource_version = 6 [(dev.f110.kubeproto.field) = { go_name: "ResourceVersion", api_field_name: "resourceVersion", inline: false }];
  // If referring to a piece of an object instead of an entire object, this string
  // should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2].
  // For example, if the object reference is to a container within a pod, this would take on a value like:
  // "spec.containers{name}" (where "name" refers to the name of the container that triggered
  // the event) or if no container name is specified "spec.containers[2]" (container with
  // index 2 in this pod). This syntax is chosen only to have some well-defined way of
  // referencing a part of an object.
  optional string field_path = 7 [(dev.f110.kubeproto.field) = { go_name: "FieldPath", api_field_name: "fieldPath", inline: false }];
}

message PersistentVolume {
  // spec defines a specification of a persistent volume owned by the cluster.
  // Provisioned by an administrator.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
  optional PersistentVolumeSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // status represents the current information/status for the persistent volume.
  // Populated by the system.
  // Read-only.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
  optional PersistentVolumeStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", sub_resource: true, inline: false }];

  option (dev.f110.kubeproto.kind) = {
    scope: SCOPE_CLUSTER
  };
}

message PersistentVolumeClaim {
  // spec defines the desired characteristics of a volume requested by a pod author.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  optional PersistentVolumeClaimSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // status represents the current information/status of a persistent volume claim.
  // Read-only.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  optional PersistentVolumeClaimStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", sub_resource: true, inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message PersistentVolumeClaimCondition {
  PersistentVolumeClaimConditionType type   = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  ConditionStatus                    status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // lastProbeTime is the time we probed the condition.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_probe_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastProbeTime", api_field_name: "lastProbeTime", inline: false }];
  // lastTransitionTime is the time the condition transitioned from one status to another.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 4 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
  // reason is a unique, this should be a short, machine understandable string that gives the reason
  // for condition's last transition. If it reports "ResizeStarted" that means the underlying
  // persistent volume is being resized.
  optional string reason = 5 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // message is the human-readable message indicating details about last transition.
  optional string message = 6 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message PersistentVolumeClaimList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is a list of persistent volume claims.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  repeated PersistentVolumeClaim items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message PersistentVolumeClaimSpec {
  // accessModes contains the desired access modes the volume should have.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
  repeated PersistentVolumeAccessMode access_modes = 1 [(dev.f110.kubeproto.field) = { go_name: "AccessModes", api_field_name: "accessModes", inline: false }];
  // selector is a label query over volumes to consider for binding.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // resources represents the minimum resources the volume should have.
  // If RecoverVolumeExpansionFailure feature is enabled users are allowed to specify resource requirements
  // that are lower than previous value but must still be higher than capacity recorded in the
  // status field of the claim.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
  optional ResourceRequirements resources = 3 [(dev.f110.kubeproto.field) = { go_name: "Resources", api_field_name: "resources", inline: false }];
  // volumeName is the binding reference to the PersistentVolume backing this claim.
  optional string volume_name = 4 [(dev.f110.kubeproto.field) = { go_name: "VolumeName", api_field_name: "volumeName", inline: false }];
  // storageClassName is the name of the StorageClass required by the claim.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
  optional string storage_class_name = 5 [(dev.f110.kubeproto.field) = { go_name: "StorageClassName", api_field_name: "storageClassName", inline: false }];
  // volumeMode defines what type of volume is required by the claim.
  // Value of Filesystem is implied when not included in claim spec.
  optional PersistentVolumeMode volume_mode = 6 [(dev.f110.kubeproto.field) = { go_name: "VolumeMode", api_field_name: "volumeMode", inline: false }];
  // dataSource field can be used to specify either:
  // * An existing VolumeSnapshot object (snapshot.storage.k8s.io/VolumeSnapshot)
  // * An existing PVC (PersistentVolumeClaim)
  // If the provisioner or an external controller can support the specified data source,
  // it will create a new volume based on the contents of the specified data source.
  // When the AnyVolumeDataSource feature gate is enabled, dataSource contents will be copied to dataSourceRef,
  // and dataSourceRef contents will be copied to dataSource when dataSourceRef.namespace is not specified.
  // If the namespace is specified, then dataSourceRef will not be copied to dataSource.
  optional TypedLocalObjectReference data_source = 7 [(dev.f110.kubeproto.field) = { go_name: "DataSource", api_field_name: "dataSource", inline: false }];
  // dataSourceRef specifies the object from which to populate the volume with data, if a non-empty
  // volume is desired. This may be any object from a non-empty API group (non
  // core object) or a PersistentVolumeClaim object.
  // When this field is specified, volume binding will only succeed if the type of
  // the specified object matches some installed volume populator or dynamic
  // provisioner.
  // This field will replace the functionality of the dataSource field and as such
  // if both fields are non-empty, they must have the same value. For backwards
  // compatibility, when namespace isn't specified in dataSourceRef,
  // both fields (dataSource and dataSourceRef) will be set to the same
  // value automatically if one of them is empty and the other is non-empty.
  // When namespace is specified in dataSourceRef,
  // dataSource isn't set to the same value and must be empty.
  // There are three important differences between dataSource and dataSourceRef:
  // * While dataSource only allows two specific types of objects, dataSourceRef
  //   allows any non-core object, as well as PersistentVolumeClaim objects.
  // * While dataSource ignores disallowed values (dropping them), dataSourceRef
  //   preserves all values, and generates an error if a disallowed value is
  //   specified.
  // * While dataSource only allows local objects, dataSourceRef allows objects
  //   in any namespaces.
  // (Beta) Using this field requires the AnyVolumeDataSource feature gate to be enabled.
  // (Alpha) Using the namespace field of dataSourceRef requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
  optional TypedObjectReference data_source_ref = 8 [(dev.f110.kubeproto.field) = { go_name: "DataSourceRef", api_field_name: "dataSourceRef", inline: false }];
}

message PersistentVolumeClaimStatus {
  // phase represents the current phase of PersistentVolumeClaim.
  optional PersistentVolumeClaimPhase phase = 1 [(dev.f110.kubeproto.field) = { go_name: "Phase", api_field_name: "phase", inline: false }];
  // accessModes contains the actual access modes the volume backing the PVC has.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
  repeated PersistentVolumeAccessMode access_modes = 2 [(dev.f110.kubeproto.field) = { go_name: "AccessModes", api_field_name: "accessModes", inline: false }];
  // capacity represents the actual resources of the underlying volume.
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 3 [(dev.f110.kubeproto.field) = { go_name: "Capacity", api_field_name: "capacity", inline: false }];
  // conditions is the current Condition of persistent volume claim. If underlying persistent volume is being
  // resized then the Condition will be set to 'ResizeStarted'.
  repeated PersistentVolumeClaimCondition conditions = 4 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
  // allocatedResources is the storage resource within AllocatedResources tracks the capacity allocated to a PVC. It may
  // be larger than the actual capacity when a volume expansion operation is requested.
  // For storage quota, the larger value from allocatedResources and PVC.spec.resources is used.
  // If allocatedResources is not set, PVC.spec.resources alone is used for quota calculation.
  // If a volume expansion capacity request is lowered, allocatedResources is only
  // lowered if there are no expansion operations in progress and if the actual volume capacity
  // is equal or lower than the requested capacity.
  // This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> allocated_resources = 5 [(dev.f110.kubeproto.field) = { go_name: "AllocatedResources", api_field_name: "allocatedResources", inline: false }];
  // resizeStatus stores status of resize operation.
  // ResizeStatus is not set by default but when expansion is complete resizeStatus is set to empty
  // string by resize controller or kubelet.
  // This is an alpha field and requires enabling RecoverVolumeExpansionFailure feature.
  optional PersistentVolumeClaimResizeStatus resize_status = 6 [(dev.f110.kubeproto.field) = { go_name: "ResizeStatus", api_field_name: "resizeStatus", inline: false }];
}

message PersistentVolumeClaimTemplate {
  // May contain labels and annotations that will be copied into the PVC
  // when creating it. No other fields are allowed and will be rejected during
  // validation.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta object_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "ObjectMeta", api_field_name: "metadata", inline: false }];
  // The specification for the PersistentVolumeClaim. The entire content is
  // copied unchanged into the PVC that gets created from this
  // template. The same fields as in a PersistentVolumeClaim
  // are also valid here.
  PersistentVolumeClaimSpec spec = 2 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
}

message PersistentVolumeClaimVolumeSource {
  // claimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  string claim_name = 1 [(dev.f110.kubeproto.field) = { go_name: "ClaimName", api_field_name: "claimName", inline: false }];
  // readOnly Will force the ReadOnly setting in VolumeMounts.
  // Default false.
  optional bool read_only = 2 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
}

message PersistentVolumeList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is a list of persistent volumes.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
  repeated PersistentVolume items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message PersistentVolumeSource {
  // gcePersistentDisk represents a GCE Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod. Provisioned by an admin.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  optional GCEPersistentDiskVolumeSource gce_persistent_disk = 1 [(dev.f110.kubeproto.field) = { go_name: "GCEPersistentDisk", api_field_name: "gcePersistentDisk", inline: false }];
  // awsElasticBlockStore represents an AWS Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  optional AWSElasticBlockStoreVolumeSource aws_elastic_block_store = 2 [(dev.f110.kubeproto.field) = { go_name: "AWSElasticBlockStore", api_field_name: "awsElasticBlockStore", inline: false }];
  // hostPath represents a directory on the host.
  // Provisioned by a developer or tester.
  // This is useful for single-node development and testing only!
  // On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  optional HostPathVolumeSource host_path = 3 [(dev.f110.kubeproto.field) = { go_name: "HostPath", api_field_name: "hostPath", inline: false }];
  // glusterfs represents a Glusterfs volume that is attached to a host and
  // exposed to the pod. Provisioned by an admin.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md
  optional GlusterfsPersistentVolumeSource glusterfs = 4 [(dev.f110.kubeproto.field) = { go_name: "Glusterfs", api_field_name: "glusterfs", inline: false }];
  // nfs represents an NFS mount on the host. Provisioned by an admin.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  optional NFSVolumeSource nfs = 5 [(dev.f110.kubeproto.field) = { go_name: "NFS", api_field_name: "nfs", inline: false }];
  // rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
  // More info: https://examples.k8s.io/volumes/rbd/README.md
  optional RBDPersistentVolumeSource rbd = 6 [(dev.f110.kubeproto.field) = { go_name: "RBD", api_field_name: "rbd", inline: false }];
  // iscsi represents an ISCSI Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod. Provisioned by an admin.
  optional ISCSIPersistentVolumeSource iscsi = 7 [(dev.f110.kubeproto.field) = { go_name: "ISCSI", api_field_name: "iscsi", inline: false }];
  // cinder represents a cinder volume attached and mounted on kubelets host machine.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  optional CinderPersistentVolumeSource cinder = 8 [(dev.f110.kubeproto.field) = { go_name: "Cinder", api_field_name: "cinder", inline: false }];
  // cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
  optional CephFSPersistentVolumeSource ceph_fs = 9 [(dev.f110.kubeproto.field) = { go_name: "CephFS", api_field_name: "cephfs", inline: false }];
  // fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
  optional FCVolumeSource fc = 10 [(dev.f110.kubeproto.field) = { go_name: "FC", api_field_name: "fc", inline: false }];
  // flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
  optional FlockerVolumeSource flocker = 11 [(dev.f110.kubeproto.field) = { go_name: "Flocker", api_field_name: "flocker", inline: false }];
  // flexVolume represents a generic volume resource that is
  // provisioned/attached using an exec based plugin.
  optional FlexPersistentVolumeSource flex_volume = 12 [(dev.f110.kubeproto.field) = { go_name: "FlexVolume", api_field_name: "flexVolume", inline: false }];
  // azureFile represents an Azure File Service mount on the host and bind mount to the pod.
  optional AzureFilePersistentVolumeSource azure_file = 13 [(dev.f110.kubeproto.field) = { go_name: "AzureFile", api_field_name: "azureFile", inline: false }];
  // vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
  optional VsphereVirtualDiskVolumeSource vsphere_volume = 14 [(dev.f110.kubeproto.field) = { go_name: "VsphereVolume", api_field_name: "vsphereVolume", inline: false }];
  // quobyte represents a Quobyte mount on the host that shares a pod's lifetime
  optional QuobyteVolumeSource quobyte = 15 [(dev.f110.kubeproto.field) = { go_name: "Quobyte", api_field_name: "quobyte", inline: false }];
  // azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
  optional AzureDiskVolumeSource azure_disk = 16 [(dev.f110.kubeproto.field) = { go_name: "AzureDisk", api_field_name: "azureDisk", inline: false }];
  // photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
  optional PhotonPersistentDiskVolumeSource photon_persistent_disk = 17 [(dev.f110.kubeproto.field) = { go_name: "PhotonPersistentDisk", api_field_name: "photonPersistentDisk", inline: false }];
  // portworxVolume represents a portworx volume attached and mounted on kubelets host machine
  optional PortworxVolumeSource portworx_volume = 18 [(dev.f110.kubeproto.field) = { go_name: "PortworxVolume", api_field_name: "portworxVolume", inline: false }];
  // scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
  optional ScaleIOPersistentVolumeSource scale_io = 19 [(dev.f110.kubeproto.field) = { go_name: "ScaleIO", api_field_name: "scaleIO", inline: false }];
  // local represents directly-attached storage with node affinity
  optional LocalVolumeSource local = 20 [(dev.f110.kubeproto.field) = { go_name: "Local", api_field_name: "local", inline: false }];
  // storageOS represents a StorageOS volume that is attached to the kubelet's host machine and mounted into the pod
  // More info: https://examples.k8s.io/volumes/storageos/README.md
  optional StorageOSPersistentVolumeSource storage_os = 21 [(dev.f110.kubeproto.field) = { go_name: "StorageOS", api_field_name: "storageos", inline: false }];
  // csi represents storage that is handled by an external CSI driver (Beta feature).
  optional CSIPersistentVolumeSource csi = 22 [(dev.f110.kubeproto.field) = { go_name: "CSI", api_field_name: "csi", inline: false }];
}

message PersistentVolumeSpec {
  // capacity is the description of the persistent volume's resources and capacity.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> capacity = 1 [(dev.f110.kubeproto.field) = { go_name: "Capacity", api_field_name: "capacity", inline: false }];
  // persistentVolumeSource is the actual volume backing the persistent volume.
  PersistentVolumeSource persistent_volume_source = 2 [(dev.f110.kubeproto.field) = { go_name: "PersistentVolumeSource", inline: true }];
  // accessModes contains all ways the volume can be mounted.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
  repeated PersistentVolumeAccessMode access_modes = 3 [(dev.f110.kubeproto.field) = { go_name: "AccessModes", api_field_name: "accessModes", inline: false }];
  // claimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim.
  // Expected to be non-nil when bound.
  // claim.VolumeName is the authoritative bind between PV and PVC.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
  optional ObjectReference claim_ref = 4 [(dev.f110.kubeproto.field) = { go_name: "ClaimRef", api_field_name: "claimRef", inline: false }];
  // persistentVolumeReclaimPolicy defines what happens to a persistent volume when released from its claim.
  // Valid options are Retain (default for manually created PersistentVolumes), Delete (default
  // for dynamically provisioned PersistentVolumes), and Recycle (deprecated).
  // Recycle must be supported by the volume plugin underlying this PersistentVolume.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
  optional PersistentVolumeReclaimPolicy persistent_volume_reclaim_policy = 5 [(dev.f110.kubeproto.field) = { go_name: "PersistentVolumeReclaimPolicy", api_field_name: "persistentVolumeReclaimPolicy", inline: false }];
  // storageClassName is the name of StorageClass to which this persistent volume belongs. Empty value
  // means that this volume does not belong to any StorageClass.
  optional string storage_class_name = 6 [(dev.f110.kubeproto.field) = { go_name: "StorageClassName", api_field_name: "storageClassName", inline: false }];
  // mountOptions is the list of mount options, e.g. ["ro", "soft"]. Not validated - mount will
  // simply fail if one is invalid.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
  repeated string mount_options = 7 [(dev.f110.kubeproto.field) = { go_name: "MountOptions", api_field_name: "mountOptions", inline: false }];
  // volumeMode defines if a volume is intended to be used with a formatted filesystem
  // or to remain in raw block state. Value of Filesystem is implied when not included in spec.
  optional PersistentVolumeMode volume_mode = 8 [(dev.f110.kubeproto.field) = { go_name: "VolumeMode", api_field_name: "volumeMode", inline: false }];
  // nodeAffinity defines constraints that limit what nodes this volume can be accessed from.
  // This field influences the scheduling of pods that use this volume.
  optional VolumeNodeAffinity node_affinity = 9 [(dev.f110.kubeproto.field) = { go_name: "NodeAffinity", api_field_name: "nodeAffinity", inline: false }];
}

message PersistentVolumeStatus {
  // phase indicates if a volume is available, bound to a claim, or released by a claim.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#phase
  optional PersistentVolumePhase phase = 1 [(dev.f110.kubeproto.field) = { go_name: "Phase", api_field_name: "phase", inline: false }];
  // message is a human-readable message indicating details about why the volume is in this state.
  optional string message = 2 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
  // reason is a brief CamelCase string that describes any failure and is meant
  // for machine parsing and tidy display in the CLI.
  optional string reason = 3 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
}

message PhotonPersistentDiskVolumeSource {
  // pdID is the ID that identifies Photon Controller persistent disk
  string pd_id = 1 [(dev.f110.kubeproto.field) = { go_name: "PdID", api_field_name: "pdID", inline: false }];
  // fsType is the filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  optional string fs_type = 2 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
}

message Pod {
  // Specification of the desired behavior of the pod.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional PodSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Most recently observed status of the pod.
  // This data may not be up to date.
  // Populated by the system.
  // Read-only.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional PodStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", sub_resource: true, inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message PodAffinity {
  // If the affinity requirements specified by this field are not met at
  // scheduling time, the pod will not be scheduled onto the node.
  // If the affinity requirements specified by this field cease to be met
  // at some point during pod execution (e.g. due to a pod label update), the
  // system may or may not try to eventually evict the pod from its node.
  // When there are multiple elements, the lists of nodes corresponding to each
  // podAffinityTerm are intersected, i.e. all terms must be satisfied.
  repeated PodAffinityTerm required_during_scheduling_ignored_during_execution = 1 [(dev.f110.kubeproto.field) = { go_name: "RequiredDuringSchedulingIgnoredDuringExecution", api_field_name: "requiredDuringSchedulingIgnoredDuringExecution", inline: false }];
  // The scheduler will prefer to schedule pods to nodes that satisfy
  // the affinity expressions specified by this field, but it may choose
  // a node that violates one or more of the expressions. The node that is
  // most preferred is the one with the greatest sum of weights, i.e.
  // for each node that meets all of the scheduling requirements (resource
  // request, requiredDuringScheduling affinity expressions, etc.),
  // compute a sum by iterating through the elements of this field and adding
  // "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
  // node(s) with the highest sum are the most preferred.
  repeated WeightedPodAffinityTerm preferred_during_scheduling_ignored_during_execution = 2 [(dev.f110.kubeproto.field) = { go_name: "PreferredDuringSchedulingIgnoredDuringExecution", api_field_name: "preferredDuringSchedulingIgnoredDuringExecution", inline: false }];
}

message PodAffinityTerm {
  // A label query over a set of resources, in this case pods.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector label_selector = 1 [(dev.f110.kubeproto.field) = { go_name: "LabelSelector", api_field_name: "labelSelector", inline: false }];
  // namespaces specifies a static list of namespace names that the term applies to.
  // The term is applied to the union of the namespaces listed in this field
  // and the ones selected by namespaceSelector.
  // null or empty namespaces list and null namespaceSelector means "this pod's namespace".
  repeated string namespaces = 2 [(dev.f110.kubeproto.field) = { go_name: "Namespaces", api_field_name: "namespaces", inline: false }];
  // This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
  // the labelSelector in the specified namespaces, where co-located is defined as running on a node
  // whose value of the label with key topologyKey matches that of any node on which any of the
  // selected pods is running.
  // Empty topologyKey is not allowed.
  string topology_key = 3 [(dev.f110.kubeproto.field) = { go_name: "TopologyKey", api_field_name: "topologyKey", inline: false }];
  // A label query over the set of namespaces that the term applies to.
  // The term is applied to the union of the namespaces selected by this field
  // and the ones listed in the namespaces field.
  // null selector and null or empty namespaces list means "this pod's namespace".
  // An empty selector ({}) matches all namespaces.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespace_selector = 4 [(dev.f110.kubeproto.field) = { go_name: "NamespaceSelector", api_field_name: "namespaceSelector", inline: false }];
}

message PodAntiAffinity {
  // If the anti-affinity requirements specified by this field are not met at
  // scheduling time, the pod will not be scheduled onto the node.
  // If the anti-affinity requirements specified by this field cease to be met
  // at some point during pod execution (e.g. due to a pod label update), the
  // system may or may not try to eventually evict the pod from its node.
  // When there are multiple elements, the lists of nodes corresponding to each
  // podAffinityTerm are intersected, i.e. all terms must be satisfied.
  repeated PodAffinityTerm required_during_scheduling_ignored_during_execution = 1 [(dev.f110.kubeproto.field) = { go_name: "RequiredDuringSchedulingIgnoredDuringExecution", api_field_name: "requiredDuringSchedulingIgnoredDuringExecution", inline: false }];
  // The scheduler will prefer to schedule pods to nodes that satisfy
  // the anti-affinity expressions specified by this field, but it may choose
  // a node that violates one or more of the expressions. The node that is
  // most preferred is the one with the greatest sum of weights, i.e.
  // for each node that meets all of the scheduling requirements (resource
  // request, requiredDuringScheduling anti-affinity expressions, etc.),
  // compute a sum by iterating through the elements of this field and adding
  // "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
  // node(s) with the highest sum are the most preferred.
  repeated WeightedPodAffinityTerm preferred_during_scheduling_ignored_during_execution = 2 [(dev.f110.kubeproto.field) = { go_name: "PreferredDuringSchedulingIgnoredDuringExecution", api_field_name: "preferredDuringSchedulingIgnoredDuringExecution", inline: false }];
}

message PodAttachOptions {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Stdin if true, redirects the standard input stream of the pod for this call.
  // Defaults to false.
  optional bool stdin = 2 [(dev.f110.kubeproto.field) = { go_name: "Stdin", api_field_name: "stdin", inline: false }];
  // Stdout if true indicates that stdout is to be redirected for the attach call.
  // Defaults to true.
  optional bool stdout = 3 [(dev.f110.kubeproto.field) = { go_name: "Stdout", api_field_name: "stdout", inline: false }];
  // Stderr if true indicates that stderr is to be redirected for the attach call.
  // Defaults to true.
  optional bool stderr = 4 [(dev.f110.kubeproto.field) = { go_name: "Stderr", api_field_name: "stderr", inline: false }];
  // TTY if true indicates that a tty will be allocated for the attach call.
  // This is passed through the container runtime so the tty
  // is allocated on the worker node by the container runtime.
  // Defaults to false.
  optional bool tty = 5 [(dev.f110.kubeproto.field) = { go_name: "TTY", api_field_name: "tty", inline: false }];
  // The container in which to execute the command.
  // Defaults to only container if there is only one container in the pod.
  optional string container = 6 [(dev.f110.kubeproto.field) = { go_name: "Container", api_field_name: "container", inline: false }];
}

message PodCondition {
  // Type is the type of the condition.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
  PodConditionType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Status is the status of the condition.
  // Can be True, False, Unknown.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
  ConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // Last time we probed the condition.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_probe_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastProbeTime", api_field_name: "lastProbeTime", inline: false }];
  // Last time the condition transitioned from one status to another.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 4 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
  // Unique, one-word, CamelCase reason for the condition's last transition.
  optional string reason = 5 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // Human-readable message indicating details about last transition.
  optional string message = 6 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message PodDNSConfig {
  // A list of DNS name server IP addresses.
  // This will be appended to the base nameservers generated from DNSPolicy.
  // Duplicated nameservers will be removed.
  repeated string nameservers = 1 [(dev.f110.kubeproto.field) = { go_name: "Nameservers", api_field_name: "nameservers", inline: false }];
  // A list of DNS search domains for host-name lookup.
  // This will be appended to the base search paths generated from DNSPolicy.
  // Duplicated search paths will be removed.
  repeated string searches = 2 [(dev.f110.kubeproto.field) = { go_name: "Searches", api_field_name: "searches", inline: false }];
  // A list of DNS resolver options.
  // This will be merged with the base options generated from DNSPolicy.
  // Duplicated entries will be removed. Resolution options given in Options
  // will override those that appear in the base DNSPolicy.
  repeated PodDNSConfigOption options = 3 [(dev.f110.kubeproto.field) = { go_name: "Options", api_field_name: "options", inline: false }];
}

message PodDNSConfigOption {
  // Required.
  optional string name  = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  optional string value = 2 [(dev.f110.kubeproto.field) = { go_name: "Value", api_field_name: "value", inline: false }];
}

message PodExecOptions {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Redirect the standard input stream of the pod for this call.
  // Defaults to false.
  optional bool stdin = 2 [(dev.f110.kubeproto.field) = { go_name: "Stdin", api_field_name: "stdin", inline: false }];
  // Redirect the standard output stream of the pod for this call.
  optional bool stdout = 3 [(dev.f110.kubeproto.field) = { go_name: "Stdout", api_field_name: "stdout", inline: false }];
  // Redirect the standard error stream of the pod for this call.
  optional bool stderr = 4 [(dev.f110.kubeproto.field) = { go_name: "Stderr", api_field_name: "stderr", inline: false }];
  // TTY if true indicates that a tty will be allocated for the exec call.
  // Defaults to false.
  optional bool tty = 5 [(dev.f110.kubeproto.field) = { go_name: "TTY", api_field_name: "tty", inline: false }];
  // Container in which to execute the command.
  // Defaults to only container if there is only one container in the pod.
  optional string container = 6 [(dev.f110.kubeproto.field) = { go_name: "Container", api_field_name: "container", inline: false }];
  // Command is the remote command to execute. argv array. Not executed within a shell.
  repeated string command = 7 [(dev.f110.kubeproto.field) = { go_name: "Command", api_field_name: "command", inline: false }];
}

message PodIP {
  // ip is an IP address (IPv4 or IPv6) assigned to the pod
  optional string ip = 1 [(dev.f110.kubeproto.field) = { go_name: "IP", api_field_name: "ip", inline: false }];
}

message PodList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of pods.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md
  repeated Pod items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message PodLogOptions {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // The container for which to stream logs. Defaults to only container if there is one container in the pod.
  optional string container = 2 [(dev.f110.kubeproto.field) = { go_name: "Container", api_field_name: "container", inline: false }];
  // Follow the log stream of the pod. Defaults to false.
  optional bool follow = 3 [(dev.f110.kubeproto.field) = { go_name: "Follow", api_field_name: "follow", inline: false }];
  // Return previous terminated container logs. Defaults to false.
  optional bool previous = 4 [(dev.f110.kubeproto.field) = { go_name: "Previous", api_field_name: "previous", inline: false }];
  // A relative time in seconds before the current time from which to show logs. If this value
  // precedes the time a pod was started, only logs since the pod start will be returned.
  // If this value is in the future, no logs will be returned.
  // Only one of sinceSeconds or sinceTime may be specified.
  optional int64 since_seconds = 5 [(dev.f110.kubeproto.field) = { go_name: "SinceSeconds", api_field_name: "sinceSeconds", inline: false }];
  // An RFC3339 timestamp from which to show logs. If this value
  // precedes the time a pod was started, only logs since the pod start will be returned.
  // If this value is in the future, no logs will be returned.
  // Only one of sinceSeconds or sinceTime may be specified.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time since_time = 6 [(dev.f110.kubeproto.field) = { go_name: "SinceTime", api_field_name: "sinceTime", inline: false }];
  // If true, add an RFC3339 or RFC3339Nano timestamp at the beginning of every line
  // of log output. Defaults to false.
  optional bool timestamps = 7 [(dev.f110.kubeproto.field) = { go_name: "Timestamps", api_field_name: "timestamps", inline: false }];
  // If set, the number of lines from the end of the logs to show. If not specified,
  // logs are shown from the creation of the container or sinceSeconds or sinceTime
  optional int64 tail_lines = 8 [(dev.f110.kubeproto.field) = { go_name: "TailLines", api_field_name: "tailLines", inline: false }];
  // If set, the number of bytes to read from the server before terminating the
  // log output. This may not display a complete final line of logging, and may return
  // slightly more or slightly less than the specified limit.
  optional int64 limit_bytes = 9 [(dev.f110.kubeproto.field) = { go_name: "LimitBytes", api_field_name: "limitBytes", inline: false }];
  // insecureSkipTLSVerifyBackend indicates that the apiserver should not confirm the validity of the
  // serving certificate of the backend it is connecting to.  This will make the HTTPS connection between the apiserver
  // and the backend insecure. This means the apiserver cannot verify the log data it is receiving came from the real
  // kubelet.  If the kubelet is configured to verify the apiserver's TLS credentials, it does not mean the
  // connection to the real kubelet is vulnerable to a man in the middle attack (e.g. an attacker could not intercept
  // the actual log data coming from the real kubelet).
  optional bool insecure_skip_tls_verify_backend = 10 [(dev.f110.kubeproto.field) = { go_name: "InsecureSkipTLSVerifyBackend", api_field_name: "insecureSkipTLSVerifyBackend", inline: false }];
}

message PodOS {
  // Name is the name of the operating system. The currently supported values are linux and windows.
  // Additional value may be defined in future and can be one of:
  // https://github.com/opencontainers/runtime-spec/blob/master/config.md#platform-specific-configuration
  // Clients should expect to handle additional values and treat unrecognized values in this field as os: null
  OSName name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
}

message PodPortForwardOptions {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // List of ports to forward
  // Required when using WebSockets
  repeated int32 ports = 2 [(dev.f110.kubeproto.field) = { go_name: "Ports", api_field_name: "ports", inline: false }];
}

message PodProxyOptions {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Path is the URL path to use for the current proxy request to pod.
  optional string path = 2 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
}

message PodReadinessGate {
  // ConditionType refers to a condition in the pod's condition list with matching type.
  PodConditionType condition_type = 1 [(dev.f110.kubeproto.field) = { go_name: "ConditionType", api_field_name: "conditionType", inline: false }];
}

message PodResourceClaim {
  // Name uniquely identifies this resource claim inside the pod.
  // This must be a DNS_LABEL.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Source describes where to find the ResourceClaim.
  optional ClaimSource source = 2 [(dev.f110.kubeproto.field) = { go_name: "Source", api_field_name: "source", inline: false }];
}

message PodSchedulingGate {
  // Name of the scheduling gate.
  // Each scheduling gate must have a unique name field.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
}

message PodSecurityContext {
  // The SELinux context to be applied to all containers.
  // If unspecified, the container runtime will allocate a random SELinux context for each
  // container.  May also be set in SecurityContext.  If set in
  // both SecurityContext and PodSecurityContext, the value specified in SecurityContext
  // takes precedence for that container.
  // Note that this field cannot be set when spec.os.name is windows.
  optional SELinuxOptions selinux_options = 1 [(dev.f110.kubeproto.field) = { go_name: "SELinuxOptions", api_field_name: "seLinuxOptions", inline: false }];
  // The Windows specific settings applied to all containers.
  // If unspecified, the options within a container's SecurityContext will be used.
  // If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  // Note that this field cannot be set when spec.os.name is linux.
  optional WindowsSecurityContextOptions windows_options = 2 [(dev.f110.kubeproto.field) = { go_name: "WindowsOptions", api_field_name: "windowsOptions", inline: false }];
  // The UID to run the entrypoint of the container process.
  // Defaults to user specified in image metadata if unspecified.
  // May also be set in SecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence
  // for that container.
  // Note that this field cannot be set when spec.os.name is windows.
  optional int64 run_as_user = 3 [(dev.f110.kubeproto.field) = { go_name: "RunAsUser", api_field_name: "runAsUser", inline: false }];
  // The GID to run the entrypoint of the container process.
  // Uses runtime default if unset.
  // May also be set in SecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence
  // for that container.
  // Note that this field cannot be set when spec.os.name is windows.
  optional int64 run_as_group = 4 [(dev.f110.kubeproto.field) = { go_name: "RunAsGroup", api_field_name: "runAsGroup", inline: false }];
  // Indicates that the container must run as a non-root user.
  // If true, the Kubelet will validate the image at runtime to ensure that it
  // does not run as UID 0 (root) and fail to start the container if it does.
  // If unset or false, no such validation will be performed.
  // May also be set in SecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  optional bool run_as_non_root = 5 [(dev.f110.kubeproto.field) = { go_name: "RunAsNonRoot", api_field_name: "runAsNonRoot", inline: false }];
  // A list of groups applied to the first process run in each container, in addition
  // to the container's primary GID, the fsGroup (if specified), and group memberships
  // defined in the container image for the uid of the container process. If unspecified,
  // no additional groups are added to any container. Note that group memberships
  // defined in the container image for the uid of the container process are still effective,
  // even if they are not included in this list.
  // Note that this field cannot be set when spec.os.name is windows.
  repeated int64 supplemental_groups = 6 [(dev.f110.kubeproto.field) = { go_name: "SupplementalGroups", api_field_name: "supplementalGroups", inline: false }];
  // A special supplemental group that applies to all containers in a pod.
  // Some volume types allow the Kubelet to change the ownership of that volume
  // to be owned by the pod:
  // 1. The owning GID will be the FSGroup
  // 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
  // 3. The permission bits are OR'd with rw-rw----
  // If unset, the Kubelet will not modify the ownership and permissions of any volume.
  // Note that this field cannot be set when spec.os.name is windows.
  optional int64 fs_group = 7 [(dev.f110.kubeproto.field) = { go_name: "FSGroup", api_field_name: "fsGroup", inline: false }];
  // Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
  // sysctls (by the container runtime) might fail to launch.
  // Note that this field cannot be set when spec.os.name is windows.
  repeated Sysctl sysctls = 8 [(dev.f110.kubeproto.field) = { go_name: "Sysctls", api_field_name: "sysctls", inline: false }];
  // fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
  // before being exposed inside Pod. This field will only apply to
  // volume types which support fsGroup based ownership(and permissions).
  // It will have no effect on ephemeral volume types such as: secret, configmaps
  // and emptydir.
  // Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
  // Note that this field cannot be set when spec.os.name is windows.
  optional PodFSGroupChangePolicy fs_group_change_policy = 9 [(dev.f110.kubeproto.field) = { go_name: "FSGroupChangePolicy", api_field_name: "fsGroupChangePolicy", inline: false }];
  // The seccomp options to use by the containers in this pod.
  // Note that this field cannot be set when spec.os.name is windows.
  optional SeccompProfile seccomp_profile = 10 [(dev.f110.kubeproto.field) = { go_name: "SeccompProfile", api_field_name: "seccompProfile", inline: false }];
}

message PodSignature {
  // Reference to controller whose pods should avoid this node.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference pod_controller = 1 [(dev.f110.kubeproto.field) = { go_name: "PodController", api_field_name: "podController", inline: false }];
}

message PodSpec {
  // List of volumes that can be mounted by containers belonging to the pod.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes
  repeated Volume volumes = 1 [(dev.f110.kubeproto.field) = { go_name: "Volumes", api_field_name: "volumes", inline: false }];
  // List of initialization containers belonging to the pod.
  // Init containers are executed in order prior to containers being started. If any
  // init container fails, the pod is considered to have failed and is handled according
  // to its restartPolicy. The name for an init container or normal container must be
  // unique among all containers.
  // Init containers may not have Lifecycle actions, Readiness probes, Liveness probes, or Startup probes.
  // The resourceRequirements of an init container are taken into account during scheduling
  // by finding the highest request/limit for each resource type, and then using the max of
  // of that value or the sum of the normal containers. Limits are applied to init containers
  // in a similar fashion.
  // Init containers cannot currently be added or removed.
  // Cannot be updated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  repeated Container init_containers = 2 [(dev.f110.kubeproto.field) = { go_name: "InitContainers", api_field_name: "initContainers", inline: false }];
  // List of containers belonging to the pod.
  // Containers cannot currently be added or removed.
  // There must be at least one container in a Pod.
  // Cannot be updated.
  repeated Container containers = 3 [(dev.f110.kubeproto.field) = { go_name: "Containers", api_field_name: "containers", inline: false }];
  // List of ephemeral containers run in this pod. Ephemeral containers may be run in an existing
  // pod to perform user-initiated actions such as debugging. This list cannot be specified when
  // creating a pod, and it cannot be modified by updating the pod spec. In order to add an
  // ephemeral container to an existing pod, use the pod's ephemeralcontainers subresource.
  repeated EphemeralContainer ephemeral_containers = 4 [(dev.f110.kubeproto.field) = { go_name: "EphemeralContainers", api_field_name: "ephemeralContainers", inline: false }];
  // Restart policy for all containers within the pod.
  // One of Always, OnFailure, Never. In some contexts, only a subset of those values may be permitted.
  // Default to Always.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
  optional RestartPolicy restart_policy = 5 [(dev.f110.kubeproto.field) = { go_name: "RestartPolicy", api_field_name: "restartPolicy", inline: false }];
  // Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request.
  // Value must be non-negative integer. The value zero indicates stop immediately via
  // the kill signal (no opportunity to shut down).
  // If this value is nil, the default grace period will be used instead.
  // The grace period is the duration in seconds after the processes running in the pod are sent
  // a termination signal and the time when the processes are forcibly halted with a kill signal.
  // Set this value longer than the expected cleanup time for your process.
  // Defaults to 30 seconds.
  optional int64 termination_grace_period_seconds = 6 [(dev.f110.kubeproto.field) = { go_name: "TerminationGracePeriodSeconds", api_field_name: "terminationGracePeriodSeconds", inline: false }];
  // Optional duration in seconds the pod may be active on the node relative to
  // StartTime before the system will actively try to mark it failed and kill associated containers.
  // Value must be a positive integer.
  optional int64 active_deadline_seconds = 7 [(dev.f110.kubeproto.field) = { go_name: "ActiveDeadlineSeconds", api_field_name: "activeDeadlineSeconds", inline: false }];
  // Set DNS policy for the pod.
  // Defaults to "ClusterFirst".
  // Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
  // DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
  // To have DNS options set along with hostNetwork, you have to specify DNS policy
  // explicitly to 'ClusterFirstWithHostNet'.
  optional DNSPolicy dns_policy = 8 [(dev.f110.kubeproto.field) = { go_name: "DNSPolicy", api_field_name: "dnsPolicy", inline: false }];
  // NodeSelector is a selector which must be true for the pod to fit on a node.
  // Selector which must match a node's labels for the pod to be scheduled on that node.
  // More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
  map<string, string> node_selector = 9 [(dev.f110.kubeproto.field) = { go_name: "NodeSelector", api_field_name: "nodeSelector", inline: false }];
  // ServiceAccountName is the name of the ServiceAccount to use to run this pod.
  // More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  optional string service_account_name = 10 [(dev.f110.kubeproto.field) = { go_name: "ServiceAccountName", api_field_name: "serviceAccountName", inline: false }];
  // DeprecatedServiceAccount is a depreciated alias for ServiceAccountName.
  // Deprecated: Use serviceAccountName instead.
  optional string deprecated_service_account = 11 [(dev.f110.kubeproto.field) = { go_name: "DeprecatedServiceAccount", api_field_name: "serviceAccount", inline: false }];
  // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
  optional bool automount_service_account_token = 12 [(dev.f110.kubeproto.field) = { go_name: "AutomountServiceAccountToken", api_field_name: "automountServiceAccountToken", inline: false }];
  // NodeName is a request to schedule this pod onto a specific node. If it is non-empty,
  // the scheduler simply schedules this pod onto that node, assuming that it fits resource
  // requirements.
  optional string node_name = 13 [(dev.f110.kubeproto.field) = { go_name: "NodeName", api_field_name: "nodeName", inline: false }];
  // Host networking requested for this pod. Use the host's network namespace.
  // If this option is set, the ports that will be used must be specified.
  // Default to false.
  optional bool host_network = 14 [(dev.f110.kubeproto.field) = { go_name: "HostNetwork", api_field_name: "hostNetwork", inline: false }];
  // Use the host's pid namespace.
  // Optional: Default to false.
  optional bool host_pid = 15 [(dev.f110.kubeproto.field) = { go_name: "HostPID", api_field_name: "hostPID", inline: false }];
  // Use the host's ipc namespace.
  // Optional: Default to false.
  optional bool host_ipc = 16 [(dev.f110.kubeproto.field) = { go_name: "HostIPC", api_field_name: "hostIPC", inline: false }];
  // Share a single process namespace between all of the containers in a pod.
  // When this is set containers will be able to view and signal processes from other containers
  // in the same pod, and the first process in each container will not be assigned PID 1.
  // HostPID and ShareProcessNamespace cannot both be set.
  // Optional: Default to false.
  optional bool share_process_namespace = 17 [(dev.f110.kubeproto.field) = { go_name: "ShareProcessNamespace", api_field_name: "shareProcessNamespace", inline: false }];
  // SecurityContext holds pod-level security attributes and common container settings.
  // Optional: Defaults to empty.  See type description for default values of each field.
  optional PodSecurityContext security_context = 18 [(dev.f110.kubeproto.field) = { go_name: "SecurityContext", api_field_name: "securityContext", inline: false }];
  // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec.
  // If specified, these secrets will be passed to individual puller implementations for them to use.
  // More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
  repeated LocalObjectReference image_pull_secrets = 19 [(dev.f110.kubeproto.field) = { go_name: "ImagePullSecrets", api_field_name: "imagePullSecrets", inline: false }];
  // Specifies the hostname of the Pod
  // If not specified, the pod's hostname will be set to a system-defined value.
  optional string hostname = 20 [(dev.f110.kubeproto.field) = { go_name: "Hostname", api_field_name: "hostname", inline: false }];
  // If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>".
  // If not specified, the pod will not have a domainname at all.
  optional string subdomain = 21 [(dev.f110.kubeproto.field) = { go_name: "Subdomain", api_field_name: "subdomain", inline: false }];
  // If specified, the pod's scheduling constraints
  optional Affinity affinity = 22 [(dev.f110.kubeproto.field) = { go_name: "Affinity", api_field_name: "affinity", inline: false }];
  // If specified, the pod will be dispatched by specified scheduler.
  // If not specified, the pod will be dispatched by default scheduler.
  optional string scheduler_name = 23 [(dev.f110.kubeproto.field) = { go_name: "SchedulerName", api_field_name: "schedulerName", inline: false }];
  // If specified, the pod's tolerations.
  repeated Toleration tolerations = 24 [(dev.f110.kubeproto.field) = { go_name: "Tolerations", api_field_name: "tolerations", inline: false }];
  // HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts
  // file if specified. This is only valid for non-hostNetwork pods.
  repeated HostAlias host_aliases = 25 [(dev.f110.kubeproto.field) = { go_name: "HostAliases", api_field_name: "hostAliases", inline: false }];
  // If specified, indicates the pod's priority. "system-node-critical" and
  // "system-cluster-critical" are two special keywords which indicate the
  // highest priorities with the former being the highest priority. Any other
  // name must be defined by creating a PriorityClass object with that name.
  // If not specified, the pod priority will be default or zero if there is no
  // default.
  optional string priority_class_name = 26 [(dev.f110.kubeproto.field) = { go_name: "PriorityClassName", api_field_name: "priorityClassName", inline: false }];
  // The priority value. Various system components use this field to find the
  // priority of the pod. When Priority Admission Controller is enabled, it
  // prevents users from setting this field. The admission controller populates
  // this field from PriorityClassName.
  // The higher the value, the higher the priority.
  optional int32 priority = 27 [(dev.f110.kubeproto.field) = { go_name: "Priority", api_field_name: "priority", inline: false }];
  // Specifies the DNS parameters of a pod.
  // Parameters specified here will be merged to the generated DNS
  // configuration based on DNSPolicy.
  optional PodDNSConfig dns_config = 28 [(dev.f110.kubeproto.field) = { go_name: "DNSConfig", api_field_name: "dnsConfig", inline: false }];
  // If specified, all readiness gates will be evaluated for pod readiness.
  // A pod is ready when all its containers are ready AND
  // all conditions specified in the readiness gates have status equal to "True"
  // More info: https://git.k8s.io/enhancements/keps/sig-network/580-pod-readiness-gates
  repeated PodReadinessGate readiness_gates = 29 [(dev.f110.kubeproto.field) = { go_name: "ReadinessGates", api_field_name: "readinessGates", inline: false }];
  // RuntimeClassName refers to a RuntimeClass object in the node.k8s.io group, which should be used
  // to run this pod.  If no RuntimeClass resource matches the named class, the pod will not be run.
  // If unset or empty, the "legacy" RuntimeClass will be used, which is an implicit class with an
  // empty definition that uses the default runtime handler.
  // More info: https://git.k8s.io/enhancements/keps/sig-node/585-runtime-class
  optional string runtime_class_name = 30 [(dev.f110.kubeproto.field) = { go_name: "RuntimeClassName", api_field_name: "runtimeClassName", inline: false }];
  // EnableServiceLinks indicates whether information about services should be injected into pod's
  // environment variables, matching the syntax of Docker links.
  // Optional: Defaults to true.
  optional bool enable_service_links = 31 [(dev.f110.kubeproto.field) = { go_name: "EnableServiceLinks", api_field_name: "enableServiceLinks", inline: false }];
  // PreemptionPolicy is the Policy for preempting pods with lower priority.
  // One of Never, PreemptLowerPriority.
  // Defaults to PreemptLowerPriority if unset.
  optional PreemptionPolicy preemption_policy = 32 [(dev.f110.kubeproto.field) = { go_name: "PreemptionPolicy", api_field_name: "preemptionPolicy", inline: false }];
  // Overhead represents the resource overhead associated with running a pod for a given RuntimeClass.
  // This field will be autopopulated at admission time by the RuntimeClass admission controller. If
  // the RuntimeClass admission controller is enabled, overhead must not be set in Pod create requests.
  // The RuntimeClass admission controller will reject Pod create requests which have the overhead already
  // set. If RuntimeClass is configured and selected in the PodSpec, Overhead will be set to the value
  // defined in the corresponding RuntimeClass, otherwise it will remain unset and treated as zero.
  // More info: https://git.k8s.io/enhancements/keps/sig-node/688-pod-overhead/README.md
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> overhead = 33 [(dev.f110.kubeproto.field) = { go_name: "Overhead", api_field_name: "overhead", inline: false }];
  // TopologySpreadConstraints describes how a group of pods ought to spread across topology
  // domains. Scheduler will schedule pods in a way which abides by the constraints.
  // All topologySpreadConstraints are ANDed.
  repeated TopologySpreadConstraint topology_spread_constraints = 34 [(dev.f110.kubeproto.field) = { go_name: "TopologySpreadConstraints", api_field_name: "topologySpreadConstraints", inline: false }];
  // If true the pod's hostname will be configured as the pod's FQDN, rather than the leaf name (the default).
  // In Linux containers, this means setting the FQDN in the hostname field of the kernel (the nodename field of struct utsname).
  // In Windows containers, this means setting the registry value of hostname for the registry key HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters to FQDN.
  // If a pod does not have FQDN, this has no effect.
  // Default to false.
  optional bool set_hostname_as_fqdn = 35 [(dev.f110.kubeproto.field) = { go_name: "SetHostnameAsFQDN", api_field_name: "setHostnameAsFQDN", inline: false }];
  // Specifies the OS of the containers in the pod.
  // Some pod and container fields are restricted if this is set.
  // If the OS field is set to linux, the following fields must be unset:
  // -securityContext.windowsOptions
  // If the OS field is set to windows, following fields must be unset:
  // - spec.hostPID
  // - spec.hostIPC
  // - spec.hostUsers
  // - spec.securityContext.seLinuxOptions
  // - spec.securityContext.seccompProfile
  // - spec.securityContext.fsGroup
  // - spec.securityContext.fsGroupChangePolicy
  // - spec.securityContext.sysctls
  // - spec.shareProcessNamespace
  // - spec.securityContext.runAsUser
  // - spec.securityContext.runAsGroup
  // - spec.securityContext.supplementalGroups
  // - spec.containers[*].securityContext.seLinuxOptions
  // - spec.containers[*].securityContext.seccompProfile
  // - spec.containers[*].securityContext.capabilities
  // - spec.containers[*].securityContext.readOnlyRootFilesystem
  // - spec.containers[*].securityContext.privileged
  // - spec.containers[*].securityContext.allowPrivilegeEscalation
  // - spec.containers[*].securityContext.procMount
  // - spec.containers[*].securityContext.runAsUser
  // - spec.containers[*].securityContext.runAsGroup
  optional PodOS os = 36 [(dev.f110.kubeproto.field) = { go_name: "OS", api_field_name: "os", inline: false }];
  // Use the host's user namespace.
  // Optional: Default to true.
  // If set to true or not present, the pod will be run in the host user namespace, useful
  // for when the pod needs a feature only available to the host user namespace, such as
  // loading a kernel module with CAP_SYS_MODULE.
  // When set to false, a new userns is created for the pod. Setting false is useful for
  // mitigating container breakout vulnerabilities even allowing users to run their
  // containers as root without actually having root privileges on the host.
  // This field is alpha-level and is only honored by servers that enable the UserNamespacesSupport feature.
  optional bool host_users = 37 [(dev.f110.kubeproto.field) = { go_name: "HostUsers", api_field_name: "hostUsers", inline: false }];
  // SchedulingGates is an opaque list of values that if specified will block scheduling the pod.
  // If schedulingGates is not empty, the pod will stay in the SchedulingGated state and the
  // scheduler will not attempt to schedule the pod.
  // SchedulingGates can only be set at pod creation time, and be removed only afterwards.
  // This is a beta feature enabled by the PodSchedulingReadiness feature gate.
  repeated PodSchedulingGate scheduling_gates = 38 [(dev.f110.kubeproto.field) = { go_name: "SchedulingGates", api_field_name: "schedulingGates", inline: false }];
  // ResourceClaims defines which ResourceClaims must be allocated
  // and reserved before the Pod is allowed to start. The resources
  // will be made available to those containers which consume them
  // by name.
  // This is an alpha field and requires enabling the
  // DynamicResourceAllocation feature gate.
  // This field is immutable.
  repeated PodResourceClaim resource_claims = 39 [(dev.f110.kubeproto.field) = { go_name: "ResourceClaims", api_field_name: "resourceClaims", inline: false }];
}

message PodStatus {
  // The phase of a Pod is a simple, high-level summary of where the Pod is in its lifecycle.
  // The conditions array, the reason and message fields, and the individual container status
  // arrays contain more detail about the pod's status.
  // There are five possible phase values:
  // Pending: The pod has been accepted by the Kubernetes system, but one or more of the
  // container images has not been created. This includes time before being scheduled as
  // well as time spent downloading images over the network, which could take a while.
  // Running: The pod has been bound to a node, and all of the containers have been created.
  // At least one container is still running, or is in the process of starting or restarting.
  // Succeeded: All containers in the pod have terminated in success, and will not be restarted.
  // Failed: All containers in the pod have terminated, and at least one container has
  // terminated in failure. The container either exited with non-zero status or was terminated
  // by the system.
  // Unknown: For some reason the state of the pod could not be obtained, typically due to an
  // error in communicating with the host of the pod.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase
  optional PodPhase phase = 1 [(dev.f110.kubeproto.field) = { go_name: "Phase", api_field_name: "phase", inline: false }];
  // Current service state of pod.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-conditions
  repeated PodCondition conditions = 2 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
  // A human readable message indicating details about why the pod is in this condition.
  optional string message = 3 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
  // A brief CamelCase message indicating details about why the pod is in this state.
  // e.g. 'Evicted'
  optional string reason = 4 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // nominatedNodeName is set only when this pod preempts other pods on the node, but it cannot be
  // scheduled right away as preemption victims receive their graceful termination periods.
  // This field does not guarantee that the pod will be scheduled on this node. Scheduler may decide
  // to place the pod elsewhere if other nodes become available sooner. Scheduler may also decide to
  // give the resources on this node to a higher priority pod that is created after preemption.
  // As a result, this field may be different than PodSpec.nodeName when the pod is
  // scheduled.
  optional string nominated_node_name = 5 [(dev.f110.kubeproto.field) = { go_name: "NominatedNodeName", api_field_name: "nominatedNodeName", inline: false }];
  // IP address of the host to which the pod is assigned. Empty if not yet scheduled.
  optional string host_ip = 6 [(dev.f110.kubeproto.field) = { go_name: "HostIP", api_field_name: "hostIP", inline: false }];
  // IP address allocated to the pod. Routable at least within the cluster.
  // Empty if not yet allocated.
  optional string pod_ip = 7 [(dev.f110.kubeproto.field) = { go_name: "PodIP", api_field_name: "podIP", inline: false }];
  // podIPs holds the IP addresses allocated to the pod. If this field is specified, the 0th entry must
  // match the podIP field. Pods may be allocated at most 1 value for each of IPv4 and IPv6. This list
  // is empty if no IPs have been allocated yet.
  repeated PodIP pod_ips = 8 [(dev.f110.kubeproto.field) = { go_name: "PodIPs", api_field_name: "podIPs", inline: false }];
  // RFC 3339 date and time at which the object was acknowledged by the Kubelet.
  // This is before the Kubelet pulled the container image(s) for the pod.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time start_time = 9 [(dev.f110.kubeproto.field) = { go_name: "StartTime", api_field_name: "startTime", inline: false }];
  // The list has one entry per init container in the manifest. The most recent successful
  // init container will have ready = true, the most recently started container will have
  // startTime set.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
  repeated ContainerStatus init_container_statuses = 10 [(dev.f110.kubeproto.field) = { go_name: "InitContainerStatuses", api_field_name: "initContainerStatuses", inline: false }];
  // The list has one entry per container in the manifest.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status
  repeated ContainerStatus container_statuses = 11 [(dev.f110.kubeproto.field) = { go_name: "ContainerStatuses", api_field_name: "containerStatuses", inline: false }];
  // The Quality of Service (QOS) classification assigned to the pod based on resource requirements
  // See PodQOSClass type for available QOS classes
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-qos/#quality-of-service-classes
  optional PodQOSClass qos_class = 12 [(dev.f110.kubeproto.field) = { go_name: "QOSClass", api_field_name: "qosClass", inline: false }];
  // Status for any ephemeral containers that have run in this pod.
  repeated ContainerStatus ephemeral_container_statuses = 13 [(dev.f110.kubeproto.field) = { go_name: "EphemeralContainerStatuses", api_field_name: "ephemeralContainerStatuses", inline: false }];
  // Status of resources resize desired for pod's containers.
  // It is empty if no resources resize is pending.
  // Any changes to container resources will automatically set this to "Proposed"
  optional PodResizeStatus resize = 14 [(dev.f110.kubeproto.field) = { go_name: "Resize", api_field_name: "resize", inline: false }];
}

message PodStatusResult {
  // Most recently observed status of the pod.
  // This data may not be up to date.
  // Populated by the system.
  // Read-only.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional PodStatus status = 3 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", sub_resource: true, inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message PodTemplate {
  // Template defines the pods that will be created from this pod template.
  // https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional PodTemplateSpec template = 3 [(dev.f110.kubeproto.field) = { go_name: "Template", api_field_name: "template", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message PodTemplateList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of pod templates
  repeated PodTemplate items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message PodTemplateSpec {
  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta object_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "ObjectMeta", api_field_name: "metadata", inline: false }];
  // Specification of the desired behavior of the pod.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional PodSpec spec = 2 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
}

message PortStatus {
  // Port is the port number of the service port of which status is recorded here
  int32 port = 1 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // Protocol is the protocol of the service port of which status is recorded here
  // The supported values are: "TCP", "UDP", "SCTP"
  Protocol protocol = 2 [(dev.f110.kubeproto.field) = { go_name: "Protocol", api_field_name: "protocol", inline: false }];
  // Error is to record the problem with the service port
  // The format of the error shall comply with the following rules:
  // - built-in error values shall be specified in this file and those shall use
  //   CamelCase names
  // - cloud provider specific error values must have names that comply with the
  //   format foo.example.com/CamelCase.
  // ---
  // The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
  optional string error = 3 [(dev.f110.kubeproto.field) = { go_name: "Error", api_field_name: "error", inline: false }];
}

message PortworxVolumeSource {
  // volumeID uniquely identifies a Portworx volume
  string volume_id = 1 [(dev.f110.kubeproto.field) = { go_name: "VolumeID", api_field_name: "volumeID", inline: false }];
  // fSType represents the filesystem type to mount
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
  optional string fs_type = 2 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // readOnly defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool read_only = 3 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
}

message Preconditions {
  // Specifies the target UID.
  optional string uid = 1 [(dev.f110.kubeproto.field) = { go_name: "UID", api_field_name: "uid", inline: false }];
}

message PreferAvoidPodsEntry {
  // The class of pods.
  PodSignature pod_signature = 1 [(dev.f110.kubeproto.field) = { go_name: "PodSignature", api_field_name: "podSignature", inline: false }];
  // Time at which this entry was added to the list.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time eviction_time = 2 [(dev.f110.kubeproto.field) = { go_name: "EvictionTime", api_field_name: "evictionTime", inline: false }];
  // (brief) reason why this entry was added to the list.
  optional string reason = 3 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // Human readable message indicating why this entry was added to the list.
  optional string message = 4 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message PreferredSchedulingTerm {
  // Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
  int32 weight = 1 [(dev.f110.kubeproto.field) = { go_name: "Weight", api_field_name: "weight", inline: false }];
  // A node selector term, associated with the corresponding weight.
  NodeSelectorTerm preference = 2 [(dev.f110.kubeproto.field) = { go_name: "Preference", api_field_name: "preference", inline: false }];
}

message Probe {
  // The action taken to determine the health of a container
  ProbeHandler probe_handler = 1 [(dev.f110.kubeproto.field) = { go_name: "ProbeHandler", inline: true }];
  // Number of seconds after the container has started before liveness probes are initiated.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  optional int32 initial_delay_seconds = 2 [(dev.f110.kubeproto.field) = { go_name: "InitialDelaySeconds", api_field_name: "initialDelaySeconds", inline: false }];
  // Number of seconds after which the probe times out.
  // Defaults to 1 second. Minimum value is 1.
  // More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
  optional int32 timeout_seconds = 3 [(dev.f110.kubeproto.field) = { go_name: "TimeoutSeconds", api_field_name: "timeoutSeconds", inline: false }];
  // How often (in seconds) to perform the probe.
  // Default to 10 seconds. Minimum value is 1.
  optional int32 period_seconds = 4 [(dev.f110.kubeproto.field) = { go_name: "PeriodSeconds", api_field_name: "periodSeconds", inline: false }];
  // Minimum consecutive successes for the probe to be considered successful after having failed.
  // Defaults to 1. Must be 1 for liveness and startup. Minimum value is 1.
  optional int32 success_threshold = 5 [(dev.f110.kubeproto.field) = { go_name: "SuccessThreshold", api_field_name: "successThreshold", inline: false }];
  // Minimum consecutive failures for the probe to be considered failed after having succeeded.
  // Defaults to 3. Minimum value is 1.
  optional int32 failure_threshold = 6 [(dev.f110.kubeproto.field) = { go_name: "FailureThreshold", api_field_name: "failureThreshold", inline: false }];
  // Optional duration in seconds the pod needs to terminate gracefully upon probe failure.
  // The grace period is the duration in seconds after the processes running in the pod are sent
  // a termination signal and the time when the processes are forcibly halted with a kill signal.
  // Set this value longer than the expected cleanup time for your process.
  // If this value is nil, the pod's terminationGracePeriodSeconds will be used. Otherwise, this
  // value overrides the value provided by the pod spec.
  // Value must be non-negative integer. The value zero indicates stop immediately via
  // the kill signal (no opportunity to shut down).
  // This is a beta field and requires enabling ProbeTerminationGracePeriod feature gate.
  // Minimum value is 1. spec.terminationGracePeriodSeconds is used if unset.
  optional int64 termination_grace_period_seconds = 7 [(dev.f110.kubeproto.field) = { go_name: "TerminationGracePeriodSeconds", api_field_name: "terminationGracePeriodSeconds", inline: false }];
}

message ProbeHandler {
  // Exec specifies the action to take.
  optional ExecAction exec = 1 [(dev.f110.kubeproto.field) = { go_name: "Exec", api_field_name: "exec", inline: false }];
  // HTTPGet specifies the http request to perform.
  optional HTTPGetAction http_get = 2 [(dev.f110.kubeproto.field) = { go_name: "HTTPGet", api_field_name: "httpGet", inline: false }];
  // TCPSocket specifies an action involving a TCP port.
  optional TCPSocketAction tcp_socket = 3 [(dev.f110.kubeproto.field) = { go_name: "TCPSocket", api_field_name: "tcpSocket", inline: false }];
  // GRPC specifies an action involving a GRPC port.
  optional GRPCAction grpc = 4 [(dev.f110.kubeproto.field) = { go_name: "GRPC", api_field_name: "grpc", inline: false }];
}

message ProjectedVolumeSource {
  // sources is the list of volume projections
  repeated VolumeProjection sources = 1 [(dev.f110.kubeproto.field) = { go_name: "Sources", api_field_name: "sources", inline: false }];
  // defaultMode are the mode bits used to set permissions on created files by default.
  // Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
  // YAML accepts both octal and decimal values, JSON requires decimal values for mode bits.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  optional int32 default_mode = 2 [(dev.f110.kubeproto.field) = { go_name: "DefaultMode", api_field_name: "defaultMode", inline: false }];
}

message QuobyteVolumeSource {
  // registry represents a single or multiple Quobyte Registry services
  // specified as a string as host:port pair (multiple entries are separated with commas)
  // which acts as the central registry for volumes
  string registry = 1 [(dev.f110.kubeproto.field) = { go_name: "Registry", api_field_name: "registry", inline: false }];
  // volume is a string that references an already created Quobyte volume by name.
  string volume = 2 [(dev.f110.kubeproto.field) = { go_name: "Volume", api_field_name: "volume", inline: false }];
  // readOnly here will force the Quobyte volume to be mounted with read-only permissions.
  // Defaults to false.
  optional bool read_only = 3 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // user to map volume access to
  // Defaults to serivceaccount user
  optional string user = 4 [(dev.f110.kubeproto.field) = { go_name: "User", api_field_name: "user", inline: false }];
  // group to map volume access to
  // Default is no group
  optional string group = 5 [(dev.f110.kubeproto.field) = { go_name: "Group", api_field_name: "group", inline: false }];
  // tenant owning the given Quobyte volume in the Backend
  // Used with dynamically provisioned Quobyte volumes, value is set by the plugin
  optional string tenant = 6 [(dev.f110.kubeproto.field) = { go_name: "Tenant", api_field_name: "tenant", inline: false }];
}

message RBDPersistentVolumeSource {
  // monitors is a collection of Ceph monitors.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  repeated string ceph_monitors = 1 [(dev.f110.kubeproto.field) = { go_name: "CephMonitors", api_field_name: "monitors", inline: false }];
  // image is the rados image name.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  string rbd_image = 2 [(dev.f110.kubeproto.field) = { go_name: "RBDImage", api_field_name: "image", inline: false }];
  // fsType is the filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
  optional string fs_type = 3 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // pool is the rados pool name.
  // Default is rbd.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  optional string rbd_pool = 4 [(dev.f110.kubeproto.field) = { go_name: "RBDPool", api_field_name: "pool", inline: false }];
  // user is the rados user name.
  // Default is admin.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  optional string rados_user = 5 [(dev.f110.kubeproto.field) = { go_name: "RadosUser", api_field_name: "user", inline: false }];
  // keyring is the path to key ring for RBDUser.
  // Default is /etc/ceph/keyring.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  optional string keyring = 6 [(dev.f110.kubeproto.field) = { go_name: "Keyring", api_field_name: "keyring", inline: false }];
  // secretRef is name of the authentication secret for RBDUser. If provided
  // overrides keyring.
  // Default is nil.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  optional SecretReference secret_ref = 7 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
  // readOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  optional bool read_only = 8 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
}

message RBDVolumeSource {
  // monitors is a collection of Ceph monitors.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  repeated string ceph_monitors = 1 [(dev.f110.kubeproto.field) = { go_name: "CephMonitors", api_field_name: "monitors", inline: false }];
  // image is the rados image name.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  string rbd_image = 2 [(dev.f110.kubeproto.field) = { go_name: "RBDImage", api_field_name: "image", inline: false }];
  // fsType is the filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
  optional string fs_type = 3 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // pool is the rados pool name.
  // Default is rbd.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  optional string rbd_pool = 4 [(dev.f110.kubeproto.field) = { go_name: "RBDPool", api_field_name: "pool", inline: false }];
  // user is the rados user name.
  // Default is admin.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  optional string rados_user = 5 [(dev.f110.kubeproto.field) = { go_name: "RadosUser", api_field_name: "user", inline: false }];
  // keyring is the path to key ring for RBDUser.
  // Default is /etc/ceph/keyring.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  optional string keyring = 6 [(dev.f110.kubeproto.field) = { go_name: "Keyring", api_field_name: "keyring", inline: false }];
  // secretRef is name of the authentication secret for RBDUser. If provided
  // overrides keyring.
  // Default is nil.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  optional LocalObjectReference secret_ref = 7 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
  // readOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // More info: https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it
  optional bool read_only = 8 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
}

message RangeAllocation {
  // Range is string that identifies the range represented by 'data'.
  string range = 3 [(dev.f110.kubeproto.field) = { go_name: "Range", api_field_name: "range", inline: false }];
  // Data is a bit array containing all allocated addresses in the previous segment.
  optional bytes data = 4 [(dev.f110.kubeproto.field) = { go_name: "Data", api_field_name: "data", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ReplicationController {
  // Spec defines the specification of the desired behavior of the replication controller.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional ReplicationControllerSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status is the most recently observed status of the replication controller.
  // This data may be out of date by some window of time.
  // Populated by the system.
  // Read-only.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional ReplicationControllerStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", sub_resource: true, inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ReplicationControllerCondition {
  // Type of replication controller condition.
  ReplicationControllerConditionType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Status of the condition, one of True, False, Unknown.
  ConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // The last time the condition transitioned from one status to another.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
  // The reason for the condition's last transition.
  optional string reason = 4 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // A human readable message indicating details about the transition.
  optional string message = 5 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message ReplicationControllerList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of replication controllers.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
  repeated ReplicationController items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ReplicationControllerSpec {
  // Replicas is the number of desired replicas.
  // This is a pointer to distinguish between explicit zero and unspecified.
  // Defaults to 1.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
  optional int32 replicas = 1 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // Minimum number of seconds for which a newly created pod should be ready
  // without any of its container crashing, for it to be considered available.
  // Defaults to 0 (pod will be considered available as soon as it is ready)
  optional int32 min_ready_seconds = 2 [(dev.f110.kubeproto.field) = { go_name: "MinReadySeconds", api_field_name: "minReadySeconds", inline: false }];
  // Selector is a label query over pods that should match the Replicas count.
  // If Selector is empty, it is defaulted to the labels present on the Pod template.
  // Label keys and values that must match in order to be controlled by this replication
  // controller, if empty defaulted to labels on Pod template.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
  map<string, string> selector = 3 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // Template is the object that describes the pod that will be created if
  // insufficient replicas are detected. This takes precedence over a TemplateRef.
  // The only allowed template.spec.restartPolicy value is "Always".
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
  optional PodTemplateSpec template = 4 [(dev.f110.kubeproto.field) = { go_name: "Template", api_field_name: "template", inline: false }];
}

message ReplicationControllerStatus {
  // Replicas is the most recently observed number of replicas.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
  int32 replicas = 1 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // The number of pods that have labels matching the labels of the pod template of the replication controller.
  optional int32 fully_labeled_replicas = 2 [(dev.f110.kubeproto.field) = { go_name: "FullyLabeledReplicas", api_field_name: "fullyLabeledReplicas", inline: false }];
  // The number of ready replicas for this replication controller.
  optional int32 ready_replicas = 3 [(dev.f110.kubeproto.field) = { go_name: "ReadyReplicas", api_field_name: "readyReplicas", inline: false }];
  // The number of available replicas (ready for at least minReadySeconds) for this replication controller.
  optional int32 available_replicas = 4 [(dev.f110.kubeproto.field) = { go_name: "AvailableReplicas", api_field_name: "availableReplicas", inline: false }];
  // ObservedGeneration reflects the generation of the most recently observed replication controller.
  optional int64 observed_generation = 5 [(dev.f110.kubeproto.field) = { go_name: "ObservedGeneration", api_field_name: "observedGeneration", inline: false }];
  // Represents the latest available observations of a replication controller's current state.
  repeated ReplicationControllerCondition conditions = 6 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
}

message ResourceClaim {
  // Name must match the name of one entry in pod.spec.resourceClaims of
  // the Pod where this field is used. It makes that resource available
  // inside a container.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
}

message ResourceFieldSelector {
  // Container name: required for volumes, optional for env vars
  optional string container_name = 1 [(dev.f110.kubeproto.field) = { go_name: "ContainerName", api_field_name: "containerName", inline: false }];
  // Required: resource to select
  string resource = 2 [(dev.f110.kubeproto.field) = { go_name: "Resource", api_field_name: "resource", inline: false }];
  // Specifies the output format of the exposed resources, defaults to "1"
  optional .k8s.io.apimachinery.pkg.api.resource.Quantity divisor = 3 [(dev.f110.kubeproto.field) = { go_name: "Divisor", api_field_name: "divisor", inline: false }];
}

message ResourceQuota {
  // Spec defines the desired quota.
  // https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional ResourceQuotaSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status defines the actual enforced quota and its current usage.
  // https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional ResourceQuotaStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", sub_resource: true, inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ResourceQuotaList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // Items is a list of ResourceQuota objects.
  // More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
  repeated ResourceQuota items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ResourceQuotaSpec {
  // hard is the set of desired hard limits for each named resource.
  // More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> hard = 1 [(dev.f110.kubeproto.field) = { go_name: "Hard", api_field_name: "hard", inline: false }];
  // A collection of filters that must match each object tracked by a quota.
  // If not specified, the quota matches all objects.
  repeated ResourceQuotaScope scopes = 2 [(dev.f110.kubeproto.field) = { go_name: "Scopes", api_field_name: "scopes", inline: false }];
  // scopeSelector is also a collection of filters like scopes that must match each object tracked by a quota
  // but expressed using ScopeSelectorOperator in combination with possible values.
  // For a resource to match, both scopes AND scopeSelector (if specified in spec), must be matched.
  optional ScopeSelector scope_selector = 3 [(dev.f110.kubeproto.field) = { go_name: "ScopeSelector", api_field_name: "scopeSelector", inline: false }];
}

message ResourceQuotaStatus {
  // Hard is the set of enforced hard limits for each named resource.
  // More info: https://kubernetes.io/docs/concepts/policy/resource-quotas/
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> hard = 1 [(dev.f110.kubeproto.field) = { go_name: "Hard", api_field_name: "hard", inline: false }];
  // Used is the current observed total usage of the resource in the namespace.
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> used = 2 [(dev.f110.kubeproto.field) = { go_name: "Used", api_field_name: "used", inline: false }];
}

message ResourceRequirements {
  // Limits describes the maximum amount of compute resources allowed.
  // More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> limits = 1 [(dev.f110.kubeproto.field) = { go_name: "Limits", api_field_name: "limits", inline: false }];
  // Requests describes the minimum amount of compute resources required.
  // If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
  // otherwise to an implementation-defined value. Requests cannot exceed Limits.
  // More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  map<string, .k8s.io.apimachinery.pkg.api.resource.Quantity> requests = 2 [(dev.f110.kubeproto.field) = { go_name: "Requests", api_field_name: "requests", inline: false }];
  // Claims lists the names of resources, defined in spec.resourceClaims,
  // that are used by this container.
  // This is an alpha field and requires enabling the
  // DynamicResourceAllocation feature gate.
  // This field is immutable. It can only be set for containers.
  repeated ResourceClaim claims = 3 [(dev.f110.kubeproto.field) = { go_name: "Claims", api_field_name: "claims", inline: false }];
}

message SELinuxOptions {
  // User is a SELinux user label that applies to the container.
  optional string user = 1 [(dev.f110.kubeproto.field) = { go_name: "User", api_field_name: "user", inline: false }];
  // Role is a SELinux role label that applies to the container.
  optional string role = 2 [(dev.f110.kubeproto.field) = { go_name: "Role", api_field_name: "role", inline: false }];
  // Type is a SELinux type label that applies to the container.
  optional string type = 3 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Level is SELinux level label that applies to the container.
  optional string level = 4 [(dev.f110.kubeproto.field) = { go_name: "Level", api_field_name: "level", inline: false }];
}

message ScaleIOPersistentVolumeSource {
  // gateway is the host address of the ScaleIO API Gateway.
  string gateway = 1 [(dev.f110.kubeproto.field) = { go_name: "Gateway", api_field_name: "gateway", inline: false }];
  // system is the name of the storage system as configured in ScaleIO.
  string system = 2 [(dev.f110.kubeproto.field) = { go_name: "System", api_field_name: "system", inline: false }];
  // secretRef references to the secret for ScaleIO user and other
  // sensitive information. If this is not provided, Login operation will fail.
  optional SecretReference secret_ref = 3 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
  // sslEnabled is the flag to enable/disable SSL communication with Gateway, default false
  optional bool ssl_enabled = 4 [(dev.f110.kubeproto.field) = { go_name: "SSLEnabled", api_field_name: "sslEnabled", inline: false }];
  // protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
  optional string protection_domain = 5 [(dev.f110.kubeproto.field) = { go_name: "ProtectionDomain", api_field_name: "protectionDomain", inline: false }];
  // storagePool is the ScaleIO Storage Pool associated with the protection domain.
  optional string storage_pool = 6 [(dev.f110.kubeproto.field) = { go_name: "StoragePool", api_field_name: "storagePool", inline: false }];
  // storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
  // Default is ThinProvisioned.
  optional string storage_mode = 7 [(dev.f110.kubeproto.field) = { go_name: "StorageMode", api_field_name: "storageMode", inline: false }];
  // volumeName is the name of a volume already created in the ScaleIO system
  // that is associated with this volume source.
  optional string volume_name = 8 [(dev.f110.kubeproto.field) = { go_name: "VolumeName", api_field_name: "volumeName", inline: false }];
  // fsType is the filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs".
  // Default is "xfs"
  optional string fs_type = 9 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // readOnly defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool read_only = 10 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
}

message ScaleIOVolumeSource {
  // gateway is the host address of the ScaleIO API Gateway.
  string gateway = 1 [(dev.f110.kubeproto.field) = { go_name: "Gateway", api_field_name: "gateway", inline: false }];
  // system is the name of the storage system as configured in ScaleIO.
  string system = 2 [(dev.f110.kubeproto.field) = { go_name: "System", api_field_name: "system", inline: false }];
  // secretRef references to the secret for ScaleIO user and other
  // sensitive information. If this is not provided, Login operation will fail.
  optional LocalObjectReference secret_ref = 3 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
  // sslEnabled Flag enable/disable SSL communication with Gateway, default false
  optional bool ssl_enabled = 4 [(dev.f110.kubeproto.field) = { go_name: "SSLEnabled", api_field_name: "sslEnabled", inline: false }];
  // protectionDomain is the name of the ScaleIO Protection Domain for the configured storage.
  optional string protection_domain = 5 [(dev.f110.kubeproto.field) = { go_name: "ProtectionDomain", api_field_name: "protectionDomain", inline: false }];
  // storagePool is the ScaleIO Storage Pool associated with the protection domain.
  optional string storage_pool = 6 [(dev.f110.kubeproto.field) = { go_name: "StoragePool", api_field_name: "storagePool", inline: false }];
  // storageMode indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned.
  // Default is ThinProvisioned.
  optional string storage_mode = 7 [(dev.f110.kubeproto.field) = { go_name: "StorageMode", api_field_name: "storageMode", inline: false }];
  // volumeName is the name of a volume already created in the ScaleIO system
  // that is associated with this volume source.
  optional string volume_name = 8 [(dev.f110.kubeproto.field) = { go_name: "VolumeName", api_field_name: "volumeName", inline: false }];
  // fsType is the filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs".
  // Default is "xfs".
  optional string fs_type = 9 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // readOnly Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool read_only = 10 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
}

message ScopeSelector {
  // A list of scope selector requirements by scope of the resources.
  repeated ScopedResourceSelectorRequirement match_expressions = 1 [(dev.f110.kubeproto.field) = { go_name: "MatchExpressions", api_field_name: "matchExpressions", inline: false }];
}

message ScopedResourceSelectorRequirement {
  // The name of the scope that the selector applies to.
  ResourceQuotaScope scope_name = 1 [(dev.f110.kubeproto.field) = { go_name: "ScopeName", api_field_name: "scopeName", inline: false }];
  // Represents a scope's relationship to a set of values.
  // Valid operators are In, NotIn, Exists, DoesNotExist.
  ScopeSelectorOperator operator = 2 [(dev.f110.kubeproto.field) = { go_name: "Operator", api_field_name: "operator", inline: false }];
  // An array of string values. If the operator is In or NotIn,
  // the values array must be non-empty. If the operator is Exists or DoesNotExist,
  // the values array must be empty.
  // This array is replaced during a strategic merge patch.
  repeated string values = 3 [(dev.f110.kubeproto.field) = { go_name: "Values", api_field_name: "values", inline: false }];
}

message SeccompProfile {
  // type indicates which kind of seccomp profile will be applied.
  // Valid options are:
  // Localhost - a profile defined in a file on the node should be used.
  // RuntimeDefault - the container runtime default profile should be used.
  // Unconfined - no profile should be applied.
  SeccompProfileType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // localhostProfile indicates a profile defined in a file on the node should be used.
  // The profile must be preconfigured on the node to work.
  // Must be a descending path, relative to the kubelet's configured seccomp profile location.
  // Must only be set if type is "Localhost".
  optional string localhost_profile = 2 [(dev.f110.kubeproto.field) = { go_name: "LocalhostProfile", api_field_name: "localhostProfile", inline: false }];
}

message Secret {
  // Immutable, if set to true, ensures that data stored in the Secret cannot
  // be updated (only object metadata can be modified).
  // If not set to true, the field can be modified at any time.
  // Defaulted to nil.
  optional bool immutable = 3 [(dev.f110.kubeproto.field) = { go_name: "Immutable", api_field_name: "immutable", inline: false }];
  // Data contains the secret data. Each key must consist of alphanumeric
  // characters, '-', '_' or '.'. The serialized form of the secret data is a
  // base64 encoded string, representing the arbitrary (possibly non-string)
  // data value here. Described in https://tools.ietf.org/html/rfc4648#section-4
  map<string, bytes> data = 4 [(dev.f110.kubeproto.field) = { go_name: "Data", api_field_name: "data", inline: false }];
  // stringData allows specifying non-binary secret data in string form.
  // It is provided as a write-only input field for convenience.
  // All keys and values are merged into the data field on write, overwriting any existing values.
  // The stringData field is never output when reading from the API.
  map<string, string> string_data = 5 [(dev.f110.kubeproto.field) = { go_name: "StringData", api_field_name: "stringData", inline: false }];
  // Used to facilitate programmatic handling of secret data.
  // More info: https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
  optional SecretType type = 6 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message SecretEnvSource {
  // The Secret to select from.
  LocalObjectReference local_object_reference = 1 [(dev.f110.kubeproto.field) = { go_name: "LocalObjectReference", inline: true }];
  // Specify whether the Secret must be defined
  optional bool optional = 2 [(dev.f110.kubeproto.field) = { go_name: "Optional", api_field_name: "optional", inline: false }];
}

message SecretKeySelector {
  // The name of the secret in the pod's namespace to select from.
  LocalObjectReference local_object_reference = 1 [(dev.f110.kubeproto.field) = { go_name: "LocalObjectReference", inline: true }];
  // The key of the secret to select from.  Must be a valid secret key.
  string key = 2 [(dev.f110.kubeproto.field) = { go_name: "Key", api_field_name: "key", inline: false }];
  // Specify whether the Secret or its key must be defined
  optional bool optional = 3 [(dev.f110.kubeproto.field) = { go_name: "Optional", api_field_name: "optional", inline: false }];
}

message SecretList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // Items is a list of secret objects.
  // More info: https://kubernetes.io/docs/concepts/configuration/secret
  repeated Secret items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message SecretProjection {
  LocalObjectReference local_object_reference = 1 [(dev.f110.kubeproto.field) = { go_name: "LocalObjectReference", inline: true }];
  // items if unspecified, each key-value pair in the Data field of the referenced
  // Secret will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the Secret,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  repeated KeyToPath items = 2 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
  // optional field specify whether the Secret or its key must be defined
  optional bool optional = 3 [(dev.f110.kubeproto.field) = { go_name: "Optional", api_field_name: "optional", inline: false }];
}

message SecretReference {
  // name is unique within a namespace to reference a secret resource.
  optional string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // namespace defines the space within which the secret name must be unique.
  optional string namespace = 2 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
}

message SecretVolumeSource {
  // secretName is the name of the secret in the pod's namespace to use.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
  optional string secret_name = 1 [(dev.f110.kubeproto.field) = { go_name: "SecretName", api_field_name: "secretName", inline: false }];
  // items If unspecified, each key-value pair in the Data field of the referenced
  // Secret will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the Secret,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  repeated KeyToPath items = 2 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
  // defaultMode is Optional: mode bits used to set permissions on created files by default.
  // Must be an octal value between 0000 and 0777 or a decimal value between 0 and 511.
  // YAML accepts both octal and decimal values, JSON requires decimal values
  // for mode bits. Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  optional int32 default_mode = 3 [(dev.f110.kubeproto.field) = { go_name: "DefaultMode", api_field_name: "defaultMode", inline: false }];
  // optional field specify whether the Secret or its keys must be defined
  optional bool optional = 4 [(dev.f110.kubeproto.field) = { go_name: "Optional", api_field_name: "optional", inline: false }];
}

message SecurityContext {
  // The capabilities to add/drop when running containers.
  // Defaults to the default set of capabilities granted by the container runtime.
  // Note that this field cannot be set when spec.os.name is windows.
  optional Capabilities capabilities = 1 [(dev.f110.kubeproto.field) = { go_name: "Capabilities", api_field_name: "capabilities", inline: false }];
  // Run container in privileged mode.
  // Processes in privileged containers are essentially equivalent to root on the host.
  // Defaults to false.
  // Note that this field cannot be set when spec.os.name is windows.
  optional bool privileged = 2 [(dev.f110.kubeproto.field) = { go_name: "Privileged", api_field_name: "privileged", inline: false }];
  // The SELinux context to be applied to the container.
  // If unspecified, the container runtime will allocate a random SELinux context for each
  // container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // Note that this field cannot be set when spec.os.name is windows.
  optional SELinuxOptions selinux_options = 3 [(dev.f110.kubeproto.field) = { go_name: "SELinuxOptions", api_field_name: "seLinuxOptions", inline: false }];
  // The Windows specific settings applied to all containers.
  // If unspecified, the options from the PodSecurityContext will be used.
  // If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
  // Note that this field cannot be set when spec.os.name is linux.
  optional WindowsSecurityContextOptions windows_options = 4 [(dev.f110.kubeproto.field) = { go_name: "WindowsOptions", api_field_name: "windowsOptions", inline: false }];
  // The UID to run the entrypoint of the container process.
  // Defaults to user specified in image metadata if unspecified.
  // May also be set in PodSecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // Note that this field cannot be set when spec.os.name is windows.
  optional int64 run_as_user = 5 [(dev.f110.kubeproto.field) = { go_name: "RunAsUser", api_field_name: "runAsUser", inline: false }];
  // The GID to run the entrypoint of the container process.
  // Uses runtime default if unset.
  // May also be set in PodSecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  // Note that this field cannot be set when spec.os.name is windows.
  optional int64 run_as_group = 6 [(dev.f110.kubeproto.field) = { go_name: "RunAsGroup", api_field_name: "runAsGroup", inline: false }];
  // Indicates that the container must run as a non-root user.
  // If true, the Kubelet will validate the image at runtime to ensure that it
  // does not run as UID 0 (root) and fail to start the container if it does.
  // If unset or false, no such validation will be performed.
  // May also be set in PodSecurityContext.  If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  optional bool run_as_non_root = 7 [(dev.f110.kubeproto.field) = { go_name: "RunAsNonRoot", api_field_name: "runAsNonRoot", inline: false }];
  // Whether this container has a read-only root filesystem.
  // Default is false.
  // Note that this field cannot be set when spec.os.name is windows.
  optional bool read_only_root_filesystem = 8 [(dev.f110.kubeproto.field) = { go_name: "ReadOnlyRootFilesystem", api_field_name: "readOnlyRootFilesystem", inline: false }];
  // AllowPrivilegeEscalation controls whether a process can gain more
  // privileges than its parent process. This bool directly controls if
  // the no_new_privs flag will be set on the container process.
  // AllowPrivilegeEscalation is true always when the container is:
  // 1) run as Privileged
  // 2) has CAP_SYS_ADMIN
  // Note that this field cannot be set when spec.os.name is windows.
  optional bool allow_privilege_escalation = 9 [(dev.f110.kubeproto.field) = { go_name: "AllowPrivilegeEscalation", api_field_name: "allowPrivilegeEscalation", inline: false }];
  // procMount denotes the type of proc mount to use for the containers.
  // The default is DefaultProcMount which uses the container runtime defaults for
  // readonly paths and masked paths.
  // This requires the ProcMountType feature flag to be enabled.
  // Note that this field cannot be set when spec.os.name is windows.
  optional ProcMountType proc_mount = 10 [(dev.f110.kubeproto.field) = { go_name: "ProcMount", api_field_name: "procMount", inline: false }];
  // The seccomp options to use by this container. If seccomp options are
  // provided at both the pod & container level, the container options
  // override the pod options.
  // Note that this field cannot be set when spec.os.name is windows.
  optional SeccompProfile seccomp_profile = 11 [(dev.f110.kubeproto.field) = { go_name: "SeccompProfile", api_field_name: "seccompProfile", inline: false }];
}

message SerializedReference {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // The reference to an object in the system.
  optional ObjectReference reference = 2 [(dev.f110.kubeproto.field) = { go_name: "Reference", api_field_name: "reference", inline: false }];
}

message Service {
  // Spec defines the behavior of a service.
  // https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional ServiceSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Most recently observed status of the service.
  // Populated by the system.
  // Read-only.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional ServiceStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", sub_resource: true, inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ServiceAccount {
  // Secrets is a list of the secrets in the same namespace that pods running using this ServiceAccount are allowed to use.
  // Pods are only limited to this list if this service account has a "kubernetes.io/enforce-mountable-secrets" annotation set to "true".
  // This field should not be used to find auto-generated service account token secrets for use outside of pods.
  // Instead, tokens can be requested directly using the TokenRequest API, or service account token secrets can be manually created.
  // More info: https://kubernetes.io/docs/concepts/configuration/secret
  repeated ObjectReference secrets = 3 [(dev.f110.kubeproto.field) = { go_name: "Secrets", api_field_name: "secrets", inline: false }];
  // ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images
  // in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets
  // can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet.
  // More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
  repeated LocalObjectReference image_pull_secrets = 4 [(dev.f110.kubeproto.field) = { go_name: "ImagePullSecrets", api_field_name: "imagePullSecrets", inline: false }];
  // AutomountServiceAccountToken indicates whether pods running as this service account should have an API token automatically mounted.
  // Can be overridden at the pod level.
  optional bool automount_service_account_token = 5 [(dev.f110.kubeproto.field) = { go_name: "AutomountServiceAccountToken", api_field_name: "automountServiceAccountToken", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ServiceAccountList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of ServiceAccounts.
  // More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
  repeated ServiceAccount items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ServiceAccountTokenProjection {
  // audience is the intended audience of the token. A recipient of a token
  // must identify itself with an identifier specified in the audience of the
  // token, and otherwise should reject the token. The audience defaults to the
  // identifier of the apiserver.
  optional string audience = 1 [(dev.f110.kubeproto.field) = { go_name: "Audience", api_field_name: "audience", inline: false }];
  // expirationSeconds is the requested duration of validity of the service
  // account token. As the token approaches expiration, the kubelet volume
  // plugin will proactively rotate the service account token. The kubelet will
  // start trying to rotate the token if the token is older than 80 percent of
  // its time to live or if the token is older than 24 hours.Defaults to 1 hour
  // and must be at least 10 minutes.
  optional int64 expiration_seconds = 2 [(dev.f110.kubeproto.field) = { go_name: "ExpirationSeconds", api_field_name: "expirationSeconds", inline: false }];
  // path is the path relative to the mount point of the file to project the
  // token into.
  string path = 3 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
}

message ServiceList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of services
  repeated Service items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ServicePort {
  // The name of this port within the service. This must be a DNS_LABEL.
  // All ports within a ServiceSpec must have unique names. When considering
  // the endpoints for a Service, this must match the 'name' field in the
  // EndpointPort.
  // Optional if only one ServicePort is defined on this service.
  optional string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // The IP protocol for this port. Supports "TCP", "UDP", and "SCTP".
  // Default is TCP.
  optional Protocol protocol = 2 [(dev.f110.kubeproto.field) = { go_name: "Protocol", api_field_name: "protocol", inline: false }];
  // The application protocol for this port.
  // This field follows standard Kubernetes label syntax.
  // Un-prefixed names are reserved for IANA standard service names (as per
  // RFC-6335 and https://www.iana.org/assignments/service-names).
  // Non-standard protocols should use prefixed names such as
  // mycompany.com/my-custom-protocol.
  optional string app_protocol = 3 [(dev.f110.kubeproto.field) = { go_name: "AppProtocol", api_field_name: "appProtocol", inline: false }];
  // The port that will be exposed by this service.
  int32 port = 4 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // Number or name of the port to access on the pods targeted by the service.
  // Number must be in the range 1 to 65535. Name must be an IANA_SVC_NAME.
  // If this is a string, it will be looked up as a named port in the
  // target Pod's container ports. If this is not specified, the value
  // of the 'port' field is used (an identity map).
  // This field is ignored for services with clusterIP=None, and should be
  // omitted or set equal to the 'port' field.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
  optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString target_port = 5 [(dev.f110.kubeproto.field) = { go_name: "TargetPort", api_field_name: "targetPort", inline: false }];
  // The port on each node on which this service is exposed when type is
  // NodePort or LoadBalancer.  Usually assigned by the system. If a value is
  // specified, in-range, and not in use it will be used, otherwise the
  // operation will fail.  If not specified, a port will be allocated if this
  // Service requires one.  If this field is specified when creating a
  // Service which does not need it, creation will fail. This field will be
  // wiped when updating a Service to no longer need it (e.g. changing type
  // from NodePort to ClusterIP).
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
  optional int32 node_port = 6 [(dev.f110.kubeproto.field) = { go_name: "NodePort", api_field_name: "nodePort", inline: false }];
}

message ServiceProxyOptions {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Path is the part of URLs that include service endpoints, suffixes,
  // and parameters to use for the current proxy request to service.
  // For example, the whole request URL is
  // http://localhost/api/v1/namespaces/kube-system/services/elasticsearch-logging/_search?q=user:kimchy.
  // Path is _search?q=user:kimchy.
  optional string path = 2 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
}

message ServiceSpec {
  // The list of ports that are exposed by this service.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  repeated ServicePort ports = 1 [(dev.f110.kubeproto.field) = { go_name: "Ports", api_field_name: "ports", inline: false }];
  // Route service traffic to pods with label keys and values matching this
  // selector. If empty or not present, the service is assumed to have an
  // external process managing its endpoints, which Kubernetes will not
  // modify. Only applies to types ClusterIP, NodePort, and LoadBalancer.
  // Ignored if type is ExternalName.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/
  map<string, string> selector = 2 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // clusterIP is the IP address of the service and is usually assigned
  // randomly. If an address is specified manually, is in-range (as per
  // system configuration), and is not in use, it will be allocated to the
  // service; otherwise creation of the service will fail. This field may not
  // be changed through updates unless the type field is also being changed
  // to ExternalName (which requires this field to be blank) or the type
  // field is being changed from ExternalName (in which case this field may
  // optionally be specified, as describe above).  Valid values are "None",
  // empty string (""), or a valid IP address. Setting this to "None" makes a
  // "headless service" (no virtual IP), which is useful when direct endpoint
  // connections are preferred and proxying is not required.  Only applies to
  // types ClusterIP, NodePort, and LoadBalancer. If this field is specified
  // when creating a Service of type ExternalName, creation will fail. This
  // field will be wiped when updating a Service to type ExternalName.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  optional string cluster_ip = 3 [(dev.f110.kubeproto.field) = { go_name: "ClusterIP", api_field_name: "clusterIP", inline: false }];
  // ClusterIPs is a list of IP addresses assigned to this service, and are
  // usually assigned randomly.  If an address is specified manually, is
  // in-range (as per system configuration), and is not in use, it will be
  // allocated to the service; otherwise creation of the service will fail.
  // This field may not be changed through updates unless the type field is
  // also being changed to ExternalName (which requires this field to be
  // empty) or the type field is being changed from ExternalName (in which
  // case this field may optionally be specified, as describe above).  Valid
  // values are "None", empty string (""), or a valid IP address.  Setting
  // this to "None" makes a "headless service" (no virtual IP), which is
  // useful when direct endpoint connections are preferred and proxying is
  // not required.  Only applies to types ClusterIP, NodePort, and
  // LoadBalancer. If this field is specified when creating a Service of type
  // ExternalName, creation will fail. This field will be wiped when updating
  // a Service to type ExternalName.  If this field is not specified, it will
  // be initialized from the clusterIP field.  If this field is specified,
  // clients must ensure that clusterIPs[0] and clusterIP have the same
  // value.
  // This field may hold a maximum of two entries (dual-stack IPs, in either order).
  // These IPs must correspond to the values of the ipFamilies field. Both
  // clusterIPs and ipFamilies are governed by the ipFamilyPolicy field.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  repeated string cluster_ips = 4 [(dev.f110.kubeproto.field) = { go_name: "ClusterIPs", api_field_name: "clusterIPs", inline: false }];
  // type determines how the Service is exposed. Defaults to ClusterIP. Valid
  // options are ExternalName, ClusterIP, NodePort, and LoadBalancer.
  // "ClusterIP" allocates a cluster-internal IP address for load-balancing
  // to endpoints. Endpoints are determined by the selector or if that is not
  // specified, by manual construction of an Endpoints object or
  // EndpointSlice objects. If clusterIP is "None", no virtual IP is
  // allocated and the endpoints are published as a set of endpoints rather
  // than a virtual IP.
  // "NodePort" builds on ClusterIP and allocates a port on every node which
  // routes to the same endpoints as the clusterIP.
  // "LoadBalancer" builds on NodePort and creates an external load-balancer
  // (if supported in the current cloud) which routes to the same endpoints
  // as the clusterIP.
  // "ExternalName" aliases this service to the specified externalName.
  // Several other fields do not apply to ExternalName services.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  optional ServiceType type = 5 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // externalIPs is a list of IP addresses for which nodes in the cluster
  // will also accept traffic for this service.  These IPs are not managed by
  // Kubernetes.  The user is responsible for ensuring that traffic arrives
  // at a node with this IP.  A common example is external load-balancers
  // that are not part of the Kubernetes system.
  repeated string external_ips = 6 [(dev.f110.kubeproto.field) = { go_name: "ExternalIPs", api_field_name: "externalIPs", inline: false }];
  // Supports "ClientIP" and "None". Used to maintain session affinity.
  // Enable client IP based session affinity.
  // Must be ClientIP or None.
  // Defaults to None.
  // More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
  optional ServiceAffinity session_affinity = 7 [(dev.f110.kubeproto.field) = { go_name: "SessionAffinity", api_field_name: "sessionAffinity", inline: false }];
  // Only applies to Service Type: LoadBalancer.
  // This feature depends on whether the underlying cloud-provider supports specifying
  // the loadBalancerIP when a load balancer is created.
  // This field will be ignored if the cloud-provider does not support the feature.
  // Deprecated: This field was under-specified and its meaning varies across implementations,
  // and it cannot support dual-stack.
  // As of Kubernetes v1.24, users are encouraged to use implementation-specific annotations when available.
  // This field may be removed in a future API version.
  optional string load_balancer_ip = 8 [(dev.f110.kubeproto.field) = { go_name: "LoadBalancerIP", api_field_name: "loadBalancerIP", inline: false }];
  // If specified and supported by the platform, this will restrict traffic through the cloud-provider
  // load-balancer will be restricted to the specified client IPs. This field will be ignored if the
  // cloud-provider does not support the feature."
  // More info: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/
  repeated string load_balancer_source_ranges = 9 [(dev.f110.kubeproto.field) = { go_name: "LoadBalancerSourceRanges", api_field_name: "loadBalancerSourceRanges", inline: false }];
  // externalName is the external reference that discovery mechanisms will
  // return as an alias for this service (e.g. a DNS CNAME record). No
  // proxying will be involved.  Must be a lowercase RFC-1123 hostname
  // (https://tools.ietf.org/html/rfc1123) and requires `type` to be "ExternalName".
  optional string external_name = 10 [(dev.f110.kubeproto.field) = { go_name: "ExternalName", api_field_name: "externalName", inline: false }];
  // externalTrafficPolicy describes how nodes distribute service traffic they
  // receive on one of the Service's "externally-facing" addresses (NodePorts,
  // ExternalIPs, and LoadBalancer IPs). If set to "Local", the proxy will configure
  // the service in a way that assumes that external load balancers will take care
  // of balancing the service traffic between nodes, and so each node will deliver
  // traffic only to the node-local endpoints of the service, without masquerading
  // the client source IP. (Traffic mistakenly sent to a node with no endpoints will
  // be dropped.) The default value, "Cluster", uses the standard behavior of
  // routing to all endpoints evenly (possibly modified by topology and other
  // features). Note that traffic sent to an External IP or LoadBalancer IP from
  // within the cluster will always get "Cluster" semantics, but clients sending to
  // a NodePort from within the cluster may need to take traffic policy into account
  // when picking a node.
  optional ServiceExternalTrafficPolicy external_traffic_policy = 11 [(dev.f110.kubeproto.field) = { go_name: "ExternalTrafficPolicy", api_field_name: "externalTrafficPolicy", inline: false }];
  // healthCheckNodePort specifies the healthcheck nodePort for the service.
  // This only applies when type is set to LoadBalancer and
  // externalTrafficPolicy is set to Local. If a value is specified, is
  // in-range, and is not in use, it will be used.  If not specified, a value
  // will be automatically allocated.  External systems (e.g. load-balancers)
  // can use this port to determine if a given node holds endpoints for this
  // service or not.  If this field is specified when creating a Service
  // which does not need it, creation will fail. This field will be wiped
  // when updating a Service to no longer need it (e.g. changing type).
  // This field cannot be updated once set.
  optional int32 health_check_node_port = 12 [(dev.f110.kubeproto.field) = { go_name: "HealthCheckNodePort", api_field_name: "healthCheckNodePort", inline: false }];
  // publishNotReadyAddresses indicates that any agent which deals with endpoints for this
  // Service should disregard any indications of ready/not-ready.
  // The primary use case for setting this field is for a StatefulSet's Headless Service to
  // propagate SRV DNS records for its Pods for the purpose of peer discovery.
  // The Kubernetes controllers that generate Endpoints and EndpointSlice resources for
  // Services interpret this to mean that all endpoints are considered "ready" even if the
  // Pods themselves are not. Agents which consume only Kubernetes generated endpoints
  // through the Endpoints or EndpointSlice resources can safely assume this behavior.
  optional bool publish_not_ready_addresses = 13 [(dev.f110.kubeproto.field) = { go_name: "PublishNotReadyAddresses", api_field_name: "publishNotReadyAddresses", inline: false }];
  // sessionAffinityConfig contains the configurations of session affinity.
  optional SessionAffinityConfig session_affinity_config = 14 [(dev.f110.kubeproto.field) = { go_name: "SessionAffinityConfig", api_field_name: "sessionAffinityConfig", inline: false }];
  // IPFamilies is a list of IP families (e.g. IPv4, IPv6) assigned to this
  // service. This field is usually assigned automatically based on cluster
  // configuration and the ipFamilyPolicy field. If this field is specified
  // manually, the requested family is available in the cluster,
  // and ipFamilyPolicy allows it, it will be used; otherwise creation of
  // the service will fail. This field is conditionally mutable: it allows
  // for adding or removing a secondary IP family, but it does not allow
  // changing the primary IP family of the Service. Valid values are "IPv4"
  // and "IPv6".  This field only applies to Services of types ClusterIP,
  // NodePort, and LoadBalancer, and does apply to "headless" services.
  // This field will be wiped when updating a Service to type ExternalName.
  // This field may hold a maximum of two entries (dual-stack families, in
  // either order).  These families must correspond to the values of the
  // clusterIPs field, if specified. Both clusterIPs and ipFamilies are
  // governed by the ipFamilyPolicy field.
  repeated IPFamily ip_families = 15 [(dev.f110.kubeproto.field) = { go_name: "IPFamilies", api_field_name: "ipFamilies", inline: false }];
  // IPFamilyPolicy represents the dual-stack-ness requested or required by
  // this Service. If there is no value provided, then this field will be set
  // to SingleStack. Services can be "SingleStack" (a single IP family),
  // "PreferDualStack" (two IP families on dual-stack configured clusters or
  // a single IP family on single-stack clusters), or "RequireDualStack"
  // (two IP families on dual-stack configured clusters, otherwise fail). The
  // ipFamilies and clusterIPs fields depend on the value of this field. This
  // field will be wiped when updating a service to type ExternalName.
  optional IPFamilyPolicy ip_family_policy = 16 [(dev.f110.kubeproto.field) = { go_name: "IPFamilyPolicy", api_field_name: "ipFamilyPolicy", inline: false }];
  // allocateLoadBalancerNodePorts defines if NodePorts will be automatically
  // allocated for services with type LoadBalancer.  Default is "true". It
  // may be set to "false" if the cluster load-balancer does not rely on
  // NodePorts.  If the caller requests specific NodePorts (by specifying a
  // value), those requests will be respected, regardless of this field.
  // This field may only be set for services with type LoadBalancer and will
  // be cleared if the type is changed to any other type.
  optional bool allocate_load_balancer_node_ports = 17 [(dev.f110.kubeproto.field) = { go_name: "AllocateLoadBalancerNodePorts", api_field_name: "allocateLoadBalancerNodePorts", inline: false }];
  // loadBalancerClass is the class of the load balancer implementation this Service belongs to.
  // If specified, the value of this field must be a label-style identifier, with an optional prefix,
  // e.g. "internal-vip" or "example.com/internal-vip". Unprefixed names are reserved for end-users.
  // This field can only be set when the Service type is 'LoadBalancer'. If not set, the default load
  // balancer implementation is used, today this is typically done through the cloud provider integration,
  // but should apply for any default implementation. If set, it is assumed that a load balancer
  // implementation is watching for Services with a matching class. Any default load balancer
  // implementation (e.g. cloud providers) should ignore Services that set this field.
  // This field can only be set when creating or updating a Service to type 'LoadBalancer'.
  // Once set, it can not be changed. This field will be wiped when a service is updated to a non 'LoadBalancer' type.
  optional string load_balancer_class = 18 [(dev.f110.kubeproto.field) = { go_name: "LoadBalancerClass", api_field_name: "loadBalancerClass", inline: false }];
  // InternalTrafficPolicy describes how nodes distribute service traffic they
  // receive on the ClusterIP. If set to "Local", the proxy will assume that pods
  // only want to talk to endpoints of the service on the same node as the pod,
  // dropping the traffic if there are no local endpoints. The default value,
  // "Cluster", uses the standard behavior of routing to all endpoints evenly
  // (possibly modified by topology and other features).
  optional ServiceInternalTrafficPolicy internal_traffic_policy = 19 [(dev.f110.kubeproto.field) = { go_name: "InternalTrafficPolicy", api_field_name: "internalTrafficPolicy", inline: false }];
}

message ServiceStatus {
  // LoadBalancer contains the current status of the load-balancer,
  // if one is present.
  optional LoadBalancerStatus load_balancer = 1 [(dev.f110.kubeproto.field) = { go_name: "LoadBalancer", api_field_name: "loadBalancer", inline: false }];
  // Current service state
  repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 2 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
}

message SessionAffinityConfig {
  // clientIP contains the configurations of Client IP based session affinity.
  optional ClientIPConfig client_ip = 1 [(dev.f110.kubeproto.field) = { go_name: "ClientIP", api_field_name: "clientIP", inline: false }];
}

message StorageOSPersistentVolumeSource {
  // volumeName is the human-readable name of the StorageOS volume.  Volume
  // names are only unique within a namespace.
  optional string volume_name = 1 [(dev.f110.kubeproto.field) = { go_name: "VolumeName", api_field_name: "volumeName", inline: false }];
  // volumeNamespace specifies the scope of the volume within StorageOS.  If no
  // namespace is specified then the Pod's namespace will be used.  This allows the
  // Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
  // Set VolumeName to any name to override the default behaviour.
  // Set to "default" if you are not using namespaces within StorageOS.
  // Namespaces that do not pre-exist within StorageOS will be created.
  optional string volume_namespace = 2 [(dev.f110.kubeproto.field) = { go_name: "VolumeNamespace", api_field_name: "volumeNamespace", inline: false }];
  // fsType is the filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  optional string fs_type = 3 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // readOnly defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool read_only = 4 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // secretRef specifies the secret to use for obtaining the StorageOS API
  // credentials.  If not specified, default values will be attempted.
  optional ObjectReference secret_ref = 5 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
}

message StorageOSVolumeSource {
  // volumeName is the human-readable name of the StorageOS volume.  Volume
  // names are only unique within a namespace.
  optional string volume_name = 1 [(dev.f110.kubeproto.field) = { go_name: "VolumeName", api_field_name: "volumeName", inline: false }];
  // volumeNamespace specifies the scope of the volume within StorageOS.  If no
  // namespace is specified then the Pod's namespace will be used.  This allows the
  // Kubernetes name scoping to be mirrored within StorageOS for tighter integration.
  // Set VolumeName to any name to override the default behaviour.
  // Set to "default" if you are not using namespaces within StorageOS.
  // Namespaces that do not pre-exist within StorageOS will be created.
  optional string volume_namespace = 2 [(dev.f110.kubeproto.field) = { go_name: "VolumeNamespace", api_field_name: "volumeNamespace", inline: false }];
  // fsType is the filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  optional string fs_type = 3 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // readOnly defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  optional bool read_only = 4 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // secretRef specifies the secret to use for obtaining the StorageOS API
  // credentials.  If not specified, default values will be attempted.
  optional LocalObjectReference secret_ref = 5 [(dev.f110.kubeproto.field) = { go_name: "SecretRef", api_field_name: "secretRef", inline: false }];
}

message Sysctl {
  // Name of a property to set
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Value of a property to set
  string value = 2 [(dev.f110.kubeproto.field) = { go_name: "Value", api_field_name: "value", inline: false }];
}

message TCPSocketAction {
  // Number or name of the port to access on the container.
  // Number must be in the range 1 to 65535.
  // Name must be an IANA_SVC_NAME.
  .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 1 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // Optional: Host name to connect to, defaults to the pod IP.
  optional string host = 2 [(dev.f110.kubeproto.field) = { go_name: "Host", api_field_name: "host", inline: false }];
}

message Taint {
  // Required. The taint key to be applied to a node.
  string key = 1 [(dev.f110.kubeproto.field) = { go_name: "Key", api_field_name: "key", inline: false }];
  // The taint value corresponding to the taint key.
  optional string value = 2 [(dev.f110.kubeproto.field) = { go_name: "Value", api_field_name: "value", inline: false }];
  // Required. The effect of the taint on pods
  // that do not tolerate the taint.
  // Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
  TaintEffect effect = 3 [(dev.f110.kubeproto.field) = { go_name: "Effect", api_field_name: "effect", inline: false }];
  // TimeAdded represents the time at which the taint was added.
  // It is only written for NoExecute taints.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time_added = 4 [(dev.f110.kubeproto.field) = { go_name: "TimeAdded", api_field_name: "timeAdded", inline: false }];
}

message Toleration {
  // Key is the taint key that the toleration applies to. Empty means match all taint keys.
  // If the key is empty, operator must be Exists; this combination means to match all values and all keys.
  optional string key = 1 [(dev.f110.kubeproto.field) = { go_name: "Key", api_field_name: "key", inline: false }];
  // Operator represents a key's relationship to the value.
  // Valid operators are Exists and Equal. Defaults to Equal.
  // Exists is equivalent to wildcard for value, so that a pod can
  // tolerate all taints of a particular category.
  optional TolerationOperator operator = 2 [(dev.f110.kubeproto.field) = { go_name: "Operator", api_field_name: "operator", inline: false }];
  // Value is the taint value the toleration matches to.
  // If the operator is Exists, the value should be empty, otherwise just a regular string.
  optional string value = 3 [(dev.f110.kubeproto.field) = { go_name: "Value", api_field_name: "value", inline: false }];
  // Effect indicates the taint effect to match. Empty means match all taint effects.
  // When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
  optional TaintEffect effect = 4 [(dev.f110.kubeproto.field) = { go_name: "Effect", api_field_name: "effect", inline: false }];
  // TolerationSeconds represents the period of time the toleration (which must be
  // of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
  // it is not set, which means tolerate the taint forever (do not evict). Zero and
  // negative values will be treated as 0 (evict immediately) by the system.
  optional int64 toleration_seconds = 5 [(dev.f110.kubeproto.field) = { go_name: "TolerationSeconds", api_field_name: "tolerationSeconds", inline: false }];
}

message TopologySelectorLabelRequirement {
  // The label key that the selector applies to.
  string key = 1 [(dev.f110.kubeproto.field) = { go_name: "Key", api_field_name: "key", inline: false }];
  // An array of string values. One value must match the label to be selected.
  // Each entry in Values is ORed.
  repeated string values = 2 [(dev.f110.kubeproto.field) = { go_name: "Values", api_field_name: "values", inline: false }];
}

message TopologySelectorTerm {
  // A list of topology selector requirements by labels.
  repeated TopologySelectorLabelRequirement match_label_expressions = 1 [(dev.f110.kubeproto.field) = { go_name: "MatchLabelExpressions", api_field_name: "matchLabelExpressions", inline: false }];
}

message TopologySpreadConstraint {
  // MaxSkew describes the degree to which pods may be unevenly distributed.
  // When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
  // between the number of matching pods in the target topology and the global minimum.
  // The global minimum is the minimum number of matching pods in an eligible domain
  // or zero if the number of eligible domains is less than MinDomains.
  // For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
  // labelSelector spread as 2/2/1:
  // In this case, the global minimum is 1.
  // | zone1 | zone2 | zone3 |
  // |  P P  |  P P  |   P   |
  // - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
  // scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
  // violate MaxSkew(1).
  // - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
  // When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
  // to topologies that satisfy it.
  // It's a required field. Default value is 1 and 0 is not allowed.
  int32 max_skew = 1 [(dev.f110.kubeproto.field) = { go_name: "MaxSkew", api_field_name: "maxSkew", inline: false }];
  // TopologyKey is the key of node labels. Nodes that have a label with this key
  // and identical values are considered to be in the same topology.
  // We consider each <key, value> as a "bucket", and try to put balanced number
  // of pods into each bucket.
  // We define a domain as a particular instance of a topology.
  // Also, we define an eligible domain as a domain whose nodes meet the requirements of
  // nodeAffinityPolicy and nodeTaintsPolicy.
  // e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
  // And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
  // It's a required field.
  string topology_key = 2 [(dev.f110.kubeproto.field) = { go_name: "TopologyKey", api_field_name: "topologyKey", inline: false }];
  // WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
  // the spread constraint.
  // - DoNotSchedule (default) tells the scheduler not to schedule it.
  // - ScheduleAnyway tells the scheduler to schedule the pod in any location,
  //   but giving higher precedence to topologies that would help reduce the
  //   skew.
  // A constraint is considered "Unsatisfiable" for an incoming pod
  // if and only if every possible node assignment for that pod would violate
  // "MaxSkew" on some topology.
  // For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
  // labelSelector spread as 3/1/1:
  // | zone1 | zone2 | zone3 |
  // | P P P |   P   |   P   |
  // If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
  // to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
  // MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
  // won't make it *more* imbalanced.
  // It's a required field.
  UnsatisfiableConstraintAction when_unsatisfiable = 3 [(dev.f110.kubeproto.field) = { go_name: "WhenUnsatisfiable", api_field_name: "whenUnsatisfiable", inline: false }];
  // LabelSelector is used to find matching pods.
  // Pods that match this label selector are counted to determine the number of pods
  // in their corresponding topology domain.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector label_selector = 4 [(dev.f110.kubeproto.field) = { go_name: "LabelSelector", api_field_name: "labelSelector", inline: false }];
  // MinDomains indicates a minimum number of eligible domains.
  // When the number of eligible domains with matching topology keys is less than minDomains,
  // Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
  // And when the number of eligible domains with matching topology keys equals or greater than minDomains,
  // this value has no effect on scheduling.
  // As a result, when the number of eligible domains is less than minDomains,
  // scheduler won't schedule more than maxSkew Pods to those domains.
  // If value is nil, the constraint behaves as if MinDomains is equal to 1.
  // Valid values are integers greater than 0.
  // When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
  // For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
  // labelSelector spread as 2/2/2:
  // | zone1 | zone2 | zone3 |
  // |  P P  |  P P  |  P P  |
  // The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
  // In this situation, new pod with the same labelSelector cannot be scheduled,
  // because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
  // it will violate MaxSkew.
  // This is a beta field and requires the MinDomainsInPodTopologySpread feature gate to be enabled (enabled by default).
  optional int32 min_domains = 5 [(dev.f110.kubeproto.field) = { go_name: "MinDomains", api_field_name: "minDomains", inline: false }];
  // NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
  // when calculating pod topology spread skew. Options are:
  // - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
  // - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
  // If this value is nil, the behavior is equivalent to the Honor policy.
  // This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
  optional NodeInclusionPolicy node_affinity_policy = 6 [(dev.f110.kubeproto.field) = { go_name: "NodeAffinityPolicy", api_field_name: "nodeAffinityPolicy", inline: false }];
  // NodeTaintsPolicy indicates how we will treat node taints when calculating
  // pod topology spread skew. Options are:
  // - Honor: nodes without taints, along with tainted nodes for which the incoming pod
  // has a toleration, are included.
  // - Ignore: node taints are ignored. All nodes are included.
  // If this value is nil, the behavior is equivalent to the Ignore policy.
  // This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
  optional NodeInclusionPolicy node_taints_policy = 7 [(dev.f110.kubeproto.field) = { go_name: "NodeTaintsPolicy", api_field_name: "nodeTaintsPolicy", inline: false }];
  // MatchLabelKeys is a set of pod label keys to select the pods over which
  // spreading will be calculated. The keys are used to lookup values from the
  // incoming pod labels, those key-value labels are ANDed with labelSelector
  // to select the group of existing pods over which spreading will be calculated
  // for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
  // MatchLabelKeys cannot be set when LabelSelector isn't set.
  // Keys that don't exist in the incoming pod labels will
  // be ignored. A null or empty list means only match against labelSelector.
  // This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
  repeated string match_label_keys = 8 [(dev.f110.kubeproto.field) = { go_name: "MatchLabelKeys", api_field_name: "matchLabelKeys", inline: false }];
}

message TypedLocalObjectReference {
  // APIGroup is the group for the resource being referenced.
  // If APIGroup is not specified, the specified Kind must be in the core API group.
  // For any other third-party types, APIGroup is required.
  optional string api_group = 1 [(dev.f110.kubeproto.field) = { go_name: "APIGroup", api_field_name: "apiGroup", inline: false }];
  // Kind is the type of resource being referenced
  string kind = 2 [(dev.f110.kubeproto.field) = { go_name: "Kind", api_field_name: "kind", inline: false }];
  // Name is the name of resource being referenced
  string name = 3 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
}

message TypedObjectReference {
  // APIGroup is the group for the resource being referenced.
  // If APIGroup is not specified, the specified Kind must be in the core API group.
  // For any other third-party types, APIGroup is required.
  optional string api_group = 1 [(dev.f110.kubeproto.field) = { go_name: "APIGroup", api_field_name: "apiGroup", inline: false }];
  // Kind is the type of resource being referenced
  string kind = 2 [(dev.f110.kubeproto.field) = { go_name: "Kind", api_field_name: "kind", inline: false }];
  // Name is the name of resource being referenced
  string name = 3 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Namespace is the namespace of resource being referenced
  // Note that when a namespace is specified, a gateway.networking.k8s.io/ReferenceGrant object is required in the referent namespace to allow that namespace's owner to accept the reference. See the ReferenceGrant documentation for details.
  // (Alpha) This field requires the CrossNamespaceVolumeDataSource feature gate to be enabled.
  optional string namespace = 4 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
}

message Volume {
  // name of the volume.
  // Must be a DNS_LABEL and unique within the pod.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // volumeSource represents the location and type of the mounted volume.
  // If not specified, the Volume is implied to be an EmptyDir.
  // This implied behavior is deprecated and will be removed in a future version.
  VolumeSource volume_source = 2 [(dev.f110.kubeproto.field) = { go_name: "VolumeSource", inline: true }];
}

message VolumeDevice {
  // name must match the name of a persistentVolumeClaim in the pod
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // devicePath is the path inside of the container that the device will be mapped to.
  string device_path = 2 [(dev.f110.kubeproto.field) = { go_name: "DevicePath", api_field_name: "devicePath", inline: false }];
}

message VolumeMount {
  // This must match the Name of a Volume.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Mounted read-only if true, read-write otherwise (false or unspecified).
  // Defaults to false.
  optional bool read_only = 2 [(dev.f110.kubeproto.field) = { go_name: "ReadOnly", api_field_name: "readOnly", inline: false }];
  // Path within the container at which the volume should be mounted.  Must
  // not contain ':'.
  string mount_path = 3 [(dev.f110.kubeproto.field) = { go_name: "MountPath", api_field_name: "mountPath", inline: false }];
  // Path within the volume from which the container's volume should be mounted.
  // Defaults to "" (volume's root).
  optional string sub_path = 4 [(dev.f110.kubeproto.field) = { go_name: "SubPath", api_field_name: "subPath", inline: false }];
  // mountPropagation determines how mounts are propagated from the host
  // to container and the other way around.
  // When not set, MountPropagationNone is used.
  // This field is beta in 1.10.
  optional MountPropagationMode mount_propagation = 5 [(dev.f110.kubeproto.field) = { go_name: "MountPropagation", api_field_name: "mountPropagation", inline: false }];
  // Expanded path within the volume from which the container's volume should be mounted.
  // Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment.
  // Defaults to "" (volume's root).
  // SubPathExpr and SubPath are mutually exclusive.
  optional string sub_path_expr = 6 [(dev.f110.kubeproto.field) = { go_name: "SubPathExpr", api_field_name: "subPathExpr", inline: false }];
}

message VolumeNodeAffinity {
  // required specifies hard node constraints that must be met.
  optional NodeSelector required = 1 [(dev.f110.kubeproto.field) = { go_name: "Required", api_field_name: "required", inline: false }];
}

message VolumeProjection {
  // secret information about the secret data to project
  optional SecretProjection secret = 1 [(dev.f110.kubeproto.field) = { go_name: "Secret", api_field_name: "secret", inline: false }];
  // downwardAPI information about the downwardAPI data to project
  optional DownwardAPIProjection downward_api = 2 [(dev.f110.kubeproto.field) = { go_name: "DownwardAPI", api_field_name: "downwardAPI", inline: false }];
  // configMap information about the configMap data to project
  optional ConfigMapProjection config_map = 3 [(dev.f110.kubeproto.field) = { go_name: "ConfigMap", api_field_name: "configMap", inline: false }];
  // serviceAccountToken is information about the serviceAccountToken data to project
  optional ServiceAccountTokenProjection service_account_token = 4 [(dev.f110.kubeproto.field) = { go_name: "ServiceAccountToken", api_field_name: "serviceAccountToken", inline: false }];
}

message VolumeSource {
  // hostPath represents a pre-existing file or directory on the host
  // machine that is directly exposed to the container. This is generally
  // used for system agents or other privileged things that are allowed
  // to see the host machine. Most containers will NOT need this.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
  // ---
  // TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
  // mount host directories as read/write.
  optional HostPathVolumeSource host_path = 1 [(dev.f110.kubeproto.field) = { go_name: "HostPath", api_field_name: "hostPath", inline: false }];
  // emptyDir represents a temporary directory that shares a pod's lifetime.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
  optional EmptyDirVolumeSource empty_dir = 2 [(dev.f110.kubeproto.field) = { go_name: "EmptyDir", api_field_name: "emptyDir", inline: false }];
  // gcePersistentDisk represents a GCE Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
  optional GCEPersistentDiskVolumeSource gce_persistent_disk = 3 [(dev.f110.kubeproto.field) = { go_name: "GCEPersistentDisk", api_field_name: "gcePersistentDisk", inline: false }];
  // awsElasticBlockStore represents an AWS Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
  optional AWSElasticBlockStoreVolumeSource aws_elastic_block_store = 4 [(dev.f110.kubeproto.field) = { go_name: "AWSElasticBlockStore", api_field_name: "awsElasticBlockStore", inline: false }];
  // gitRepo represents a git repository at a particular revision.
  // DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an
  // EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir
  // into the Pod's container.
  optional GitRepoVolumeSource git_repo = 5 [(dev.f110.kubeproto.field) = { go_name: "GitRepo", api_field_name: "gitRepo", inline: false }];
  // secret represents a secret that should populate this volume.
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
  optional SecretVolumeSource secret = 6 [(dev.f110.kubeproto.field) = { go_name: "Secret", api_field_name: "secret", inline: false }];
  // nfs represents an NFS mount on the host that shares a pod's lifetime
  // More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
  optional NFSVolumeSource nfs = 7 [(dev.f110.kubeproto.field) = { go_name: "NFS", api_field_name: "nfs", inline: false }];
  // iscsi represents an ISCSI Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: https://examples.k8s.io/volumes/iscsi/README.md
  optional ISCSIVolumeSource iscsi = 8 [(dev.f110.kubeproto.field) = { go_name: "ISCSI", api_field_name: "iscsi", inline: false }];
  // glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
  // More info: https://examples.k8s.io/volumes/glusterfs/README.md
  optional GlusterfsVolumeSource glusterfs = 9 [(dev.f110.kubeproto.field) = { go_name: "Glusterfs", api_field_name: "glusterfs", inline: false }];
  // persistentVolumeClaimVolumeSource represents a reference to a
  // PersistentVolumeClaim in the same namespace.
  // More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
  optional PersistentVolumeClaimVolumeSource persistent_volume_claim = 10 [(dev.f110.kubeproto.field) = { go_name: "PersistentVolumeClaim", api_field_name: "persistentVolumeClaim", inline: false }];
  // rbd represents a Rados Block Device mount on the host that shares a pod's lifetime.
  // More info: https://examples.k8s.io/volumes/rbd/README.md
  optional RBDVolumeSource rbd = 11 [(dev.f110.kubeproto.field) = { go_name: "RBD", api_field_name: "rbd", inline: false }];
  // flexVolume represents a generic volume resource that is
  // provisioned/attached using an exec based plugin.
  optional FlexVolumeSource flex_volume = 12 [(dev.f110.kubeproto.field) = { go_name: "FlexVolume", api_field_name: "flexVolume", inline: false }];
  // cinder represents a cinder volume attached and mounted on kubelets host machine.
  // More info: https://examples.k8s.io/mysql-cinder-pd/README.md
  optional CinderVolumeSource cinder = 13 [(dev.f110.kubeproto.field) = { go_name: "Cinder", api_field_name: "cinder", inline: false }];
  // cephFS represents a Ceph FS mount on the host that shares a pod's lifetime
  optional CephFSVolumeSource ceph_fs = 14 [(dev.f110.kubeproto.field) = { go_name: "CephFS", api_field_name: "cephfs", inline: false }];
  // flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
  optional FlockerVolumeSource flocker = 15 [(dev.f110.kubeproto.field) = { go_name: "Flocker", api_field_name: "flocker", inline: false }];
  // downwardAPI represents downward API about the pod that should populate this volume
  optional DownwardAPIVolumeSource downward_api = 16 [(dev.f110.kubeproto.field) = { go_name: "DownwardAPI", api_field_name: "downwardAPI", inline: false }];
  // fc represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
  optional FCVolumeSource fc = 17 [(dev.f110.kubeproto.field) = { go_name: "FC", api_field_name: "fc", inline: false }];
  // azureFile represents an Azure File Service mount on the host and bind mount to the pod.
  optional AzureFileVolumeSource azure_file = 18 [(dev.f110.kubeproto.field) = { go_name: "AzureFile", api_field_name: "azureFile", inline: false }];
  // configMap represents a configMap that should populate this volume
  optional ConfigMapVolumeSource config_map = 19 [(dev.f110.kubeproto.field) = { go_name: "ConfigMap", api_field_name: "configMap", inline: false }];
  // vsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
  optional VsphereVirtualDiskVolumeSource vsphere_volume = 20 [(dev.f110.kubeproto.field) = { go_name: "VsphereVolume", api_field_name: "vsphereVolume", inline: false }];
  // quobyte represents a Quobyte mount on the host that shares a pod's lifetime
  optional QuobyteVolumeSource quobyte = 21 [(dev.f110.kubeproto.field) = { go_name: "Quobyte", api_field_name: "quobyte", inline: false }];
  // azureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
  optional AzureDiskVolumeSource azure_disk = 22 [(dev.f110.kubeproto.field) = { go_name: "AzureDisk", api_field_name: "azureDisk", inline: false }];
  // photonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
  optional PhotonPersistentDiskVolumeSource photon_persistent_disk = 23 [(dev.f110.kubeproto.field) = { go_name: "PhotonPersistentDisk", api_field_name: "photonPersistentDisk", inline: false }];
  // projected items for all in one resources secrets, configmaps, and downward API
  optional ProjectedVolumeSource projected = 24 [(dev.f110.kubeproto.field) = { go_name: "Projected", api_field_name: "projected", inline: false }];
  // portworxVolume represents a portworx volume attached and mounted on kubelets host machine
  optional PortworxVolumeSource portworx_volume = 25 [(dev.f110.kubeproto.field) = { go_name: "PortworxVolume", api_field_name: "portworxVolume", inline: false }];
  // scaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
  optional ScaleIOVolumeSource scale_io = 26 [(dev.f110.kubeproto.field) = { go_name: "ScaleIO", api_field_name: "scaleIO", inline: false }];
  // storageOS represents a StorageOS volume attached and mounted on Kubernetes nodes.
  optional StorageOSVolumeSource storage_os = 27 [(dev.f110.kubeproto.field) = { go_name: "StorageOS", api_field_name: "storageos", inline: false }];
  // csi (Container Storage Interface) represents ephemeral storage that is handled by certain external CSI drivers (Beta feature).
  optional CSIVolumeSource csi = 28 [(dev.f110.kubeproto.field) = { go_name: "CSI", api_field_name: "csi", inline: false }];
  // ephemeral represents a volume that is handled by a cluster storage driver.
  // The volume's lifecycle is tied to the pod that defines it - it will be created before the pod starts,
  // and deleted when the pod is removed.
  // Use this if:
  // a) the volume is only needed while the pod runs,
  // b) features of normal volumes like restoring from snapshot or capacity
  //    tracking are needed,
  // c) the storage driver is specified through a storage class, and
  // d) the storage driver supports dynamic volume provisioning through
  //    a PersistentVolumeClaim (see EphemeralVolumeSource for more
  //    information on the connection between this volume type
  //    and PersistentVolumeClaim).
  // Use PersistentVolumeClaim or one of the vendor-specific
  // APIs for volumes that persist for longer than the lifecycle
  // of an individual pod.
  // Use CSI for light-weight local ephemeral volumes if the CSI driver is meant to
  // be used that way - see the documentation of the driver for
  // more information.
  // A pod can use both types of ephemeral volumes and
  // persistent volumes at the same time.
  optional EphemeralVolumeSource ephemeral = 29 [(dev.f110.kubeproto.field) = { go_name: "Ephemeral", api_field_name: "ephemeral", inline: false }];
}

message VsphereVirtualDiskVolumeSource {
  // volumePath is the path that identifies vSphere volume vmdk
  string volume_path = 1 [(dev.f110.kubeproto.field) = { go_name: "VolumePath", api_field_name: "volumePath", inline: false }];
  // fsType is filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  optional string fs_type = 2 [(dev.f110.kubeproto.field) = { go_name: "FSType", api_field_name: "fsType", inline: false }];
  // storagePolicyName is the storage Policy Based Management (SPBM) profile name.
  optional string storage_policy_name = 3 [(dev.f110.kubeproto.field) = { go_name: "StoragePolicyName", api_field_name: "storagePolicyName", inline: false }];
  // storagePolicyID is the storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
  optional string storage_policy_id = 4 [(dev.f110.kubeproto.field) = { go_name: "StoragePolicyID", api_field_name: "storagePolicyID", inline: false }];
}

message WeightedPodAffinityTerm {
  // weight associated with matching the corresponding podAffinityTerm,
  // in the range 1-100.
  int32 weight = 1 [(dev.f110.kubeproto.field) = { go_name: "Weight", api_field_name: "weight", inline: false }];
  // Required. A pod affinity term, associated with the corresponding weight.
  PodAffinityTerm pod_affinity_term = 2 [(dev.f110.kubeproto.field) = { go_name: "PodAffinityTerm", api_field_name: "podAffinityTerm", inline: false }];
}

message WindowsSecurityContextOptions {
  // GMSACredentialSpecName is the name of the GMSA credential spec to use.
  optional string gmsa_credential_spec_name = 1 [(dev.f110.kubeproto.field) = { go_name: "GMSACredentialSpecName", api_field_name: "gmsaCredentialSpecName", inline: false }];
  // GMSACredentialSpec is where the GMSA admission webhook
  // (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
  // GMSA credential spec named by the GMSACredentialSpecName field.
  optional string gmsa_credential_spec = 2 [(dev.f110.kubeproto.field) = { go_name: "GMSACredentialSpec", api_field_name: "gmsaCredentialSpec", inline: false }];
  // The UserName in Windows to run the entrypoint of the container process.
  // Defaults to the user specified in image metadata if unspecified.
  // May also be set in PodSecurityContext. If set in both SecurityContext and
  // PodSecurityContext, the value specified in SecurityContext takes precedence.
  optional string run_as_user_name = 3 [(dev.f110.kubeproto.field) = { go_name: "RunAsUserName", api_field_name: "runAsUserName", inline: false }];
  // HostProcess determines if a container should be run as a 'Host Process' container.
  // This field is alpha-level and will only be honored by components that enable the
  // WindowsHostProcessContainers feature flag. Setting this field without the feature
  // flag will result in errors when validating the Pod. All of a Pod's containers must
  // have the same effective HostProcess value (it is not allowed to have a mix of HostProcess
  // containers and non-HostProcess containers).  In addition, if HostProcess is true
  // then HostNetwork must also be set to true.
  optional bool host_process = 4 [(dev.f110.kubeproto.field) = { go_name: "HostProcess", api_field_name: "hostProcess", inline: false }];
}
