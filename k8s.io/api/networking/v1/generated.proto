// Generated by: gen-go-to-protobuf
syntax = "proto3";
package k8s.io.api.networking.v1;
option  go_package              = "k8s.io/api/networking/v1";
option (dev.f110.kubeproto.k8s) = {
  domain: "networking.k8s.io",
  version: "v1",
};
option (dev.f110.kubeproto.kubeproto_go_package) = "go.f110.dev/kubeproto/go/apis/networkingv1";

import "kube.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";

enum NetworkPolicyConditionReason {
  NETWORK_POLICY_CONDITION_REASON_FEATURE_NOT_SUPPORTED = 0;
}

enum NetworkPolicyConditionType {
  NETWORK_POLICY_CONDITION_TYPE_ACCEPTED        = 0 [(dev.f110.kubeproto.value) = { value: "Accepted" }];
  NETWORK_POLICY_CONDITION_TYPE_PARTIAL_FAILURE = 1;
  NETWORK_POLICY_CONDITION_TYPE_FAILURE         = 2 [(dev.f110.kubeproto.value) = { value: "Failure" }];
}

enum PolicyType {
  POLICY_TYPE_INGRESS = 0 [(dev.f110.kubeproto.value) = { value: "Ingress" }];
  POLICY_TYPE_EGRESS  = 1 [(dev.f110.kubeproto.value) = { value: "Egress" }];
}

message HTTPIngressPath {
  // path is matched against the path of an incoming request. Currently it can
  // contain characters disallowed from the conventional "path" part of a URL
  // as defined by RFC 3986. Paths must begin with a '/' and must be present
  // when using PathType with value "Exact" or "Prefix".
  optional string path = 1 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // pathType determines the interpretation of the path matching. PathType can
  // be one of the following values:
  // * Exact: Matches the URL path exactly.
  // * Prefix: Matches based on a URL path prefix split by '/'. Matching is
  //   done on a path element by element basis. A path element refers is the
  //   list of labels in the path split by the '/' separator. A request is a
  //   match for path p if every p is an element-wise prefix of p of the
  //   request path. Note that if the last element of the path is a substring
  //   of the last element in request path, it is not a match (e.g. /foo/bar
  //   matches /foo/bar/baz, but does not match /foo/barbaz).
  // * ImplementationSpecific: Interpretation of the Path matching is up to
  //   the IngressClass. Implementations can treat this as a separate PathType
  //   or treat it identically to Prefix or Exact path types.
  // Implementations are required to support all path types.
  string path_type = 2 [(dev.f110.kubeproto.field) = { go_name: "PathType", api_field_name: "pathType", inline: false }];
  // backend defines the referenced service endpoint to which the traffic
  // will be forwarded to.
  IngressBackend backend = 3 [(dev.f110.kubeproto.field) = { go_name: "Backend", api_field_name: "backend", inline: false }];
}

message HTTPIngressRuleValue {
  // paths is a collection of paths that map requests to backends.
  repeated HTTPIngressPath paths = 1 [(dev.f110.kubeproto.field) = { go_name: "Paths", api_field_name: "paths", inline: false }];
}

message IPBlock {
  // cidr is a string representing the IPBlock
  // Valid examples are "192.168.1.0/24" or "2001:db8::/64"
  string cidr = 1 [(dev.f110.kubeproto.field) = { go_name: "CIDR", api_field_name: "cidr", inline: false }];
  // except is a slice of CIDRs that should not be included within an IPBlock
  // Valid examples are "192.168.1.0/24" or "2001:db8::/64"
  // Except values will be rejected if they are outside the cidr range
  repeated string except = 2 [(dev.f110.kubeproto.field) = { go_name: "Except", api_field_name: "except", inline: false }];
}

message Ingress {
  // spec is the desired state of the Ingress.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional IngressSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // status is the current state of the Ingress.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional IngressStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message IngressBackend {
  // service references a service as a backend.
  // This is a mutually exclusive setting with "Resource".
  optional IngressServiceBackend service = 1 [(dev.f110.kubeproto.field) = { go_name: "Service", api_field_name: "service", inline: false }];
  // resource is an ObjectRef to another Kubernetes resource in the namespace
  // of the Ingress object. If resource is specified, a service.Name and
  // service.Port must not be specified.
  // This is a mutually exclusive setting with "Service".
  optional .k8s.io.api.core.v1.TypedLocalObjectReference resource = 2 [(dev.f110.kubeproto.field) = { go_name: "Resource", api_field_name: "resource", inline: false }];
}

message IngressClass {
  // spec is the desired state of the IngressClass.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional IngressClassSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];

  option (dev.f110.kubeproto.kind) = {
    scope: SCOPE_CLUSTER
  };
}

message IngressClassList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is the list of IngressClasses.
  repeated IngressClass items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message IngressClassParametersReference {
  // apiGroup is the group for the resource being referenced. If APIGroup is
  // not specified, the specified Kind must be in the core API group. For any
  // other third-party types, APIGroup is required.
  optional string api_group = 1 [(dev.f110.kubeproto.field) = { go_name: "APIGroup", api_field_name: "apiGroup", inline: false }];
  // kind is the type of resource being referenced.
  string kind = 2 [(dev.f110.kubeproto.field) = { go_name: "Kind", api_field_name: "kind", inline: false }];
  // name is the name of resource being referenced.
  string name = 3 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // scope represents if this refers to a cluster or namespace scoped resource.
  // This may be set to "Cluster" (default) or "Namespace".
  optional string scope = 4 [(dev.f110.kubeproto.field) = { go_name: "Scope", api_field_name: "scope", inline: false }];
  // namespace is the namespace of the resource being referenced. This field is
  // required when scope is set to "Namespace" and must be unset when scope is set to
  // "Cluster".
  optional string namespace = 5 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
}

message IngressClassSpec {
  // controller refers to the name of the controller that should handle this
  // class. This allows for different "flavors" that are controlled by the
  // same controller. For example, you may have different parameters for the
  // same implementing controller. This should be specified as a
  // domain-prefixed path no more than 250 characters in length, e.g.
  // "acme.io/ingress-controller". This field is immutable.
  optional string controller = 1 [(dev.f110.kubeproto.field) = { go_name: "Controller", api_field_name: "controller", inline: false }];
  // parameters is a link to a custom resource containing additional
  // configuration for the controller. This is optional if the controller does
  // not require extra parameters.
  optional IngressClassParametersReference parameters = 2 [(dev.f110.kubeproto.field) = { go_name: "Parameters", api_field_name: "parameters", inline: false }];
}

message IngressList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard object's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is the list of Ingress.
  repeated Ingress items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message IngressLoadBalancerIngress {
  // ip is set for load-balancer ingress points that are IP based.
  optional string ip = 1 [(dev.f110.kubeproto.field) = { go_name: "IP", api_field_name: "ip", inline: false }];
  // hostname is set for load-balancer ingress points that are DNS based.
  optional string hostname = 2 [(dev.f110.kubeproto.field) = { go_name: "Hostname", api_field_name: "hostname", inline: false }];
  // ports provides information about the ports exposed by this LoadBalancer.
  repeated IngressPortStatus ports = 3 [(dev.f110.kubeproto.field) = { go_name: "Ports", api_field_name: "ports", inline: false }];
}

message IngressLoadBalancerStatus {
  // ingress is a list containing ingress points for the load-balancer.
  repeated IngressLoadBalancerIngress ingress = 1 [(dev.f110.kubeproto.field) = { go_name: "Ingress", api_field_name: "ingress", inline: false }];
}

message IngressPortStatus {
  // port is the port number of the ingress port.
  int32 port = 1 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // protocol is the protocol of the ingress port.
  // The supported values are: "TCP", "UDP", "SCTP"
  .k8s.io.api.core.v1.Protocol protocol = 2 [(dev.f110.kubeproto.field) = { go_name: "Protocol", api_field_name: "protocol", inline: false }];
  // error is to record the problem with the service port
  // The format of the error shall comply with the following rules:
  // - built-in error values shall be specified in this file and those shall use
  //   CamelCase names
  // - cloud provider specific error values must have names that comply with the
  //   format foo.example.com/CamelCase.
  // ---
  // The regex it matches is (dns1123SubdomainFmt/)?(qualifiedNameFmt)
  optional string error = 3 [(dev.f110.kubeproto.field) = { go_name: "Error", api_field_name: "error", inline: false }];
}

message IngressRule {
  // host is the fully qualified domain name of a network host, as defined by RFC 3986.
  // Note the following deviations from the "host" part of the
  // URI as defined in RFC 3986:
  // 1. IPs are not allowed. Currently an IngressRuleValue can only apply to
  //    the IP in the Spec of the parent Ingress.
  // 2. The `:` delimiter is not respected because ports are not allowed.
  // 	  Currently the port of an Ingress is implicitly :80 for http and
  // 	  :443 for https.
  // Both these may change in the future.
  // Incoming requests are matched against the host before the
  // IngressRuleValue. If the host is unspecified, the Ingress routes all
  // traffic based on the specified IngressRuleValue.
  // host can be "precise" which is a domain name without the terminating dot of
  // a network host (e.g. "foo.bar.com") or "wildcard", which is a domain name
  // prefixed with a single wildcard label (e.g. "*.foo.com").
  // The wildcard character '*' must appear by itself as the first DNS label and
  // matches only a single label. You cannot have a wildcard label by itself (e.g. Host == "*").
  // Requests will be matched against the Host field in the following way:
  // 1. If host is precise, the request matches this rule if the http host header is equal to Host.
  // 2. If host is a wildcard, then the request matches this rule if the http host header
  // is to equal to the suffix (removing the first label) of the wildcard rule.
  optional string host = 1 [(dev.f110.kubeproto.field) = { go_name: "Host", api_field_name: "host", inline: false }];
  // IngressRuleValue represents a rule to route requests for this IngressRule.
  // If unspecified, the rule defaults to a http catch-all. Whether that sends
  // just traffic matching the host to the default backend or all traffic to the
  // default backend, is left to the controller fulfilling the Ingress. Http is
  // currently the only supported IngressRuleValue.
  IngressRuleValue ingress_rule_value = 2 [(dev.f110.kubeproto.field) = { go_name: "IngressRuleValue", inline: false }];
}

message IngressRuleValue {
  optional HTTPIngressRuleValue http = 1 [(dev.f110.kubeproto.field) = { go_name: "HTTP", api_field_name: "http", inline: false }];
}

message IngressServiceBackend {
  // name is the referenced service. The service must exist in
  // the same namespace as the Ingress object.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // port of the referenced service. A port name or port number
  // is required for a IngressServiceBackend.
  optional ServiceBackendPort port = 2 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
}

message IngressSpec {
  // ingressClassName is the name of an IngressClass cluster resource. Ingress
  // controller implementations use this field to know whether they should be
  // serving this Ingress resource, by a transitive connection
  // (controller -> IngressClass -> Ingress resource). Although the
  // `kubernetes.io/ingress.class` annotation (simple constant name) was never
  // formally defined, it was widely supported by Ingress controllers to create
  // a direct binding between Ingress controller and Ingress resources. Newly
  // created Ingress resources should prefer using the field. However, even
  // though the annotation is officially deprecated, for backwards compatibility
  // reasons, ingress controllers should still honor that annotation if present.
  optional string ingress_class_name = 1 [(dev.f110.kubeproto.field) = { go_name: "IngressClassName", api_field_name: "ingressClassName", inline: false }];
  // defaultBackend is the backend that should handle requests that don't
  // match any rule. If Rules are not specified, DefaultBackend must be specified.
  // If DefaultBackend is not set, the handling of requests that do not match any
  // of the rules will be up to the Ingress controller.
  optional IngressBackend default_backend = 2 [(dev.f110.kubeproto.field) = { go_name: "DefaultBackend", api_field_name: "defaultBackend", inline: false }];
  // tls represents the TLS configuration. Currently the Ingress only supports a
  // single TLS port, 443. If multiple members of this list specify different hosts,
  // they will be multiplexed on the same port according to the hostname specified
  // through the SNI TLS extension, if the ingress controller fulfilling the
  // ingress supports SNI.
  repeated IngressTLS tls = 3 [(dev.f110.kubeproto.field) = { go_name: "TLS", api_field_name: "tls", inline: false }];
  // rules is a list of host rules used to configure the Ingress. If unspecified,
  // or no rule matches, all traffic is sent to the default backend.
  repeated IngressRule rules = 4 [(dev.f110.kubeproto.field) = { go_name: "Rules", api_field_name: "rules", inline: false }];
}

message IngressStatus {
  // loadBalancer contains the current status of the load-balancer.
  optional IngressLoadBalancerStatus load_balancer = 1 [(dev.f110.kubeproto.field) = { go_name: "LoadBalancer", api_field_name: "loadBalancer", inline: false }];
}

message IngressTLS {
  // hosts is a list of hosts included in the TLS certificate. The values in
  // this list must match the name/s used in the tlsSecret. Defaults to the
  // wildcard host setting for the loadbalancer controller fulfilling this
  // Ingress, if left unspecified.
  repeated string hosts = 1 [(dev.f110.kubeproto.field) = { go_name: "Hosts", api_field_name: "hosts", inline: false }];
  // secretName is the name of the secret used to terminate TLS traffic on
  // port 443. Field is left optional to allow TLS routing based on SNI
  // hostname alone. If the SNI host in a listener conflicts with the "Host"
  // header field used by an IngressRule, the SNI host is used for termination
  // and value of the "Host" header is used for routing.
  optional string secret_name = 2 [(dev.f110.kubeproto.field) = { go_name: "SecretName", api_field_name: "secretName", inline: false }];
}

message NetworkPolicy {
  // spec represents the specification of the desired behavior for this NetworkPolicy.
  optional NetworkPolicySpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // status represents the current state of the NetworkPolicy.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional NetworkPolicyStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message NetworkPolicyEgressRule {
  // ports is a list of destination ports for outgoing traffic.
  // Each item in this list is combined using a logical OR. If this field is
  // empty or missing, this rule matches all ports (traffic not restricted by port).
  // If this field is present and contains at least one item, then this rule allows
  // traffic only if the traffic matches at least one port in the list.
  repeated NetworkPolicyPort ports = 1 [(dev.f110.kubeproto.field) = { go_name: "Ports", api_field_name: "ports", inline: false }];
  // to is a list of destinations for outgoing traffic of pods selected for this rule.
  // Items in this list are combined using a logical OR operation. If this field is
  // empty or missing, this rule matches all destinations (traffic not restricted by
  // destination). If this field is present and contains at least one item, this rule
  // allows traffic only if the traffic matches at least one item in the to list.
  repeated NetworkPolicyPeer to = 2 [(dev.f110.kubeproto.field) = { go_name: "To", api_field_name: "to", inline: false }];
}

message NetworkPolicyIngressRule {
  // ports is a list of ports which should be made accessible on the pods selected for
  // this rule. Each item in this list is combined using a logical OR. If this field is
  // empty or missing, this rule matches all ports (traffic not restricted by port).
  // If this field is present and contains at least one item, then this rule allows
  // traffic only if the traffic matches at least one port in the list.
  repeated NetworkPolicyPort ports = 1 [(dev.f110.kubeproto.field) = { go_name: "Ports", api_field_name: "ports", inline: false }];
  // from is a list of sources which should be able to access the pods selected for this rule.
  // Items in this list are combined using a logical OR operation. If this field is
  // empty or missing, this rule matches all sources (traffic not restricted by
  // source). If this field is present and contains at least one item, this rule
  // allows traffic only if the traffic matches at least one item in the from list.
  repeated NetworkPolicyPeer from = 2 [(dev.f110.kubeproto.field) = { go_name: "From", api_field_name: "from", inline: false }];
}

message NetworkPolicyList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is a list of schema objects.
  repeated NetworkPolicy items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message NetworkPolicyPeer {
  // podSelector is a label selector which selects pods. This field follows standard label
  // selector semantics; if present but empty, it selects all pods.
  // If namespaceSelector is also set, then the NetworkPolicyPeer as a whole selects
  // the pods matching podSelector in the Namespaces selected by NamespaceSelector.
  // Otherwise it selects the pods matching podSelector in the policy's own namespace.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector pod_selector = 1 [(dev.f110.kubeproto.field) = { go_name: "PodSelector", api_field_name: "podSelector", inline: false }];
  // namespaceSelector selects namespaces using cluster-scoped labels. This field follows
  // standard label selector semantics; if present but empty, it selects all namespaces.
  // If podSelector is also set, then the NetworkPolicyPeer as a whole selects
  // the pods matching podSelector in the namespaces selected by namespaceSelector.
  // Otherwise it selects all pods in the namespaces selected by namespaceSelector.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespace_selector = 2 [(dev.f110.kubeproto.field) = { go_name: "NamespaceSelector", api_field_name: "namespaceSelector", inline: false }];
  // ipBlock defines policy on a particular IPBlock. If this field is set then
  // neither of the other fields can be.
  optional IPBlock ip_block = 3 [(dev.f110.kubeproto.field) = { go_name: "IPBlock", api_field_name: "ipBlock", inline: false }];
}

message NetworkPolicyPort {
  // protocol represents the protocol (TCP, UDP, or SCTP) which traffic must match.
  // If not specified, this field defaults to TCP.
  optional .k8s.io.api.core.v1.Protocol protocol = 1 [(dev.f110.kubeproto.field) = { go_name: "Protocol", api_field_name: "protocol", inline: false }];
  // port represents the port on the given protocol. This can either be a numerical or named
  // port on a pod. If this field is not provided, this matches all port names and
  // numbers.
  // If present, only traffic on the specified protocol AND port will be matched.
  optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // endPort indicates that the range of ports from port to endPort if set, inclusive,
  // should be allowed by the policy. This field cannot be defined if the port field
  // is not defined or if the port field is defined as a named (string) port.
  // The endPort must be equal or greater than port.
  optional int32 end_port = 3 [(dev.f110.kubeproto.field) = { go_name: "EndPort", api_field_name: "endPort", inline: false }];
}

message NetworkPolicySpec {
  // podSelector selects the pods to which this NetworkPolicy object applies.
  // The array of ingress rules is applied to any pods selected by this field.
  // Multiple network policies can select the same set of pods. In this case,
  // the ingress rules for each are combined additively.
  // This field is NOT optional and follows standard label selector semantics.
  // An empty podSelector matches all pods in this namespace.
  .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector pod_selector = 1 [(dev.f110.kubeproto.field) = { go_name: "PodSelector", api_field_name: "podSelector", inline: false }];
  // ingress is a list of ingress rules to be applied to the selected pods.
  // Traffic is allowed to a pod if there are no NetworkPolicies selecting the pod
  // (and cluster policy otherwise allows the traffic), OR if the traffic source is
  // the pod's local node, OR if the traffic matches at least one ingress rule
  // across all of the NetworkPolicy objects whose podSelector matches the pod. If
  // this field is empty then this NetworkPolicy does not allow any traffic (and serves
  // solely to ensure that the pods it selects are isolated by default)
  repeated NetworkPolicyIngressRule ingress = 2 [(dev.f110.kubeproto.field) = { go_name: "Ingress", api_field_name: "ingress", inline: false }];
  // egress is a list of egress rules to be applied to the selected pods. Outgoing traffic
  // is allowed if there are no NetworkPolicies selecting the pod (and cluster policy
  // otherwise allows the traffic), OR if the traffic matches at least one egress rule
  // across all of the NetworkPolicy objects whose podSelector matches the pod. If
  // this field is empty then this NetworkPolicy limits all outgoing traffic (and serves
  // solely to ensure that the pods it selects are isolated by default).
  // This field is beta-level in 1.8
  repeated NetworkPolicyEgressRule egress = 3 [(dev.f110.kubeproto.field) = { go_name: "Egress", api_field_name: "egress", inline: false }];
  // policyTypes is a list of rule types that the NetworkPolicy relates to.
  // Valid options are ["Ingress"], ["Egress"], or ["Ingress", "Egress"].
  // If this field is not specified, it will default based on the existence of ingress or egress rules;
  // policies that contain an egress section are assumed to affect egress, and all policies
  // (whether or not they contain an ingress section) are assumed to affect ingress.
  // If you want to write an egress-only policy, you must explicitly specify policyTypes [ "Egress" ].
  // Likewise, if you want to write a policy that specifies that no egress is allowed,
  // you must specify a policyTypes value that include "Egress" (since such a policy would not include
  // an egress section and would otherwise default to just [ "Ingress" ]).
  // This field is beta-level in 1.8
  repeated PolicyType policy_types = 4 [(dev.f110.kubeproto.field) = { go_name: "PolicyTypes", api_field_name: "policyTypes", inline: false }];
}

message NetworkPolicyStatus {
  // conditions holds an array of metav1.Condition that describe the state of the NetworkPolicy.
  // Current service state
  repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 1 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
}

message ServiceBackendPort {
  // name is the name of the port on the Service.
  // This is a mutually exclusive setting with "Number".
  optional string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // number is the numerical port number (e.g. 80) on the Service.
  // This is a mutually exclusive setting with "Name".
  optional int32 number = 2 [(dev.f110.kubeproto.field) = { go_name: "Number", api_field_name: "number", inline: false }];
}
