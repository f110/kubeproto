// Generated by: gen-go-to-protobuf
syntax = "proto3";
package k8s.io.api.certificates.v1;
option  go_package              = "k8s.io/api/certificates/v1";
option (dev.f110.kubeproto.k8s) = {
  domain: "certificates.k8s.io",
  version: "v1",
};
option (dev.f110.kubeproto.kubeproto_go_package) = "go.f110.dev/kubeproto/go/apis/certificatesv1";

import "kube.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";

enum KeyUsage {
  KEY_USAGE_SIGNING            = 0 [(dev.f110.kubeproto.value) = { value: "signing" }];
  KEY_USAGE_DIGITAL_SIGNATURE  = 1 [(dev.f110.kubeproto.value) = { value: "digital signature" }];
  KEY_USAGE_CONTENT_COMMITMENT = 2 [(dev.f110.kubeproto.value) = { value: "content commitment" }];
  KEY_USAGE_KEY_ENCIPHERMENT   = 3 [(dev.f110.kubeproto.value) = { value: "key encipherment" }];
  KEY_USAGE_KEY_AGREEMENT      = 4 [(dev.f110.kubeproto.value) = { value: "key agreement" }];
  KEY_USAGE_DATA_ENCIPHERMENT  = 5 [(dev.f110.kubeproto.value) = { value: "data encipherment" }];
  KEY_USAGE_CERT_SIGN          = 6 [(dev.f110.kubeproto.value) = { value: "cert sign" }];
  KEY_USAGE_CRL_SIGN           = 7 [(dev.f110.kubeproto.value) = { value: "crl sign" }];
  KEY_USAGE_ENCIPHER_ONLY      = 8 [(dev.f110.kubeproto.value) = { value: "encipher only" }];
  KEY_USAGE_DECIPHER_ONLY      = 9 [(dev.f110.kubeproto.value) = { value: "decipher only" }];
  KEY_USAGE_ANY                = 10 [(dev.f110.kubeproto.value) = { value: "any" }];
  KEY_USAGE_SERVER_AUTH        = 11 [(dev.f110.kubeproto.value) = { value: "server auth" }];
  KEY_USAGE_CLIENT_AUTH        = 12 [(dev.f110.kubeproto.value) = { value: "client auth" }];
  KEY_USAGE_CODE_SIGNING       = 13 [(dev.f110.kubeproto.value) = { value: "code signing" }];
  KEY_USAGE_EMAIL_PROTECTION   = 14 [(dev.f110.kubeproto.value) = { value: "email protection" }];
  KEY_USAGE_S_MIME             = 15 [(dev.f110.kubeproto.value) = { value: "s/mime" }];
  KEY_USAGE_IPSEC_END_SYSTEM   = 16 [(dev.f110.kubeproto.value) = { value: "ipsec end system" }];
  KEY_USAGE_IPSEC_TUNNEL       = 17 [(dev.f110.kubeproto.value) = { value: "ipsec tunnel" }];
  KEY_USAGE_IPSEC_USER         = 18 [(dev.f110.kubeproto.value) = { value: "ipsec user" }];
  KEY_USAGE_TIMESTAMPING       = 19 [(dev.f110.kubeproto.value) = { value: "timestamping" }];
  KEY_USAGE_OCSP_SIGNING       = 20 [(dev.f110.kubeproto.value) = { value: "ocsp signing" }];
  KEY_USAGE_MICROSOFT_SGC      = 21 [(dev.f110.kubeproto.value) = { value: "microsoft sgc" }];
  KEY_USAGE_NETSCAPE_SGC       = 22 [(dev.f110.kubeproto.value) = { value: "netscape sgc" }];
}

enum RequestConditionType {
  REQUEST_CONDITION_TYPE_APPROVED = 0 [(dev.f110.kubeproto.value) = { value: "Approved" }];
  REQUEST_CONDITION_TYPE_DENIED   = 1 [(dev.f110.kubeproto.value) = { value: "Denied" }];
  REQUEST_CONDITION_TYPE_FAILED   = 2 [(dev.f110.kubeproto.value) = { value: "Failed" }];
}

message CertificateSigningRequest {
  // spec contains the certificate request, and is immutable after creation.
  // Only the request, signerName, expirationSeconds, and usages fields can be set on creation.
  // Other fields are derived by Kubernetes and cannot be modified by users.
  CertificateSigningRequestSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // status contains information about whether the request is approved or denied,
  // and the certificate issued by the signer, or the failure condition indicating signer failure.
  optional CertificateSigningRequestStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", sub_resource: true, inline: false }];

  option (dev.f110.kubeproto.kind) = {
    scope: SCOPE_CLUSTER
  };
}

message CertificateSigningRequestCondition {
  // type of the condition. Known conditions are "Approved", "Denied", and "Failed".
  // An "Approved" condition is added via the /approval subresource,
  // indicating the request was approved and should be issued by the signer.
  // A "Denied" condition is added via the /approval subresource,
  // indicating the request was denied and should not be issued by the signer.
  // A "Failed" condition is added via the /status subresource,
  // indicating the signer failed to issue the certificate.
  // Approved and Denied conditions are mutually exclusive.
  // Approved, Denied, and Failed conditions cannot be removed once added.
  // Only one condition of a given type is allowed.
  RequestConditionType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // status of the condition, one of True, False, Unknown.
  // Approved, Denied, and Failed conditions may not be "False" or "Unknown".
  .k8s.io.api.core.v1.ConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // reason indicates a brief reason for the request state
  optional string reason = 3 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // message contains a human readable message with details about the request state
  optional string message = 4 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
  // lastUpdateTime is the time of the last update to this condition
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_update_time = 5 [(dev.f110.kubeproto.field) = { go_name: "LastUpdateTime", api_field_name: "lastUpdateTime", inline: false }];
  // lastTransitionTime is the time the condition last transitioned from one status to another.
  // If unset, when a new condition type is added or an existing condition's status is changed,
  // the server defaults this to the current time.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 6 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
}

message CertificateSigningRequestList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta          type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is a collection of CertificateSigningRequest objects
  repeated CertificateSigningRequest items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message CertificateSigningRequestSpec {
  // request contains an x509 certificate signing request encoded in a "CERTIFICATE REQUEST" PEM block.
  // When serialized as JSON or YAML, the data is additionally base64-encoded.
  optional bytes request = 1 [(dev.f110.kubeproto.field) = { go_name: "Request", api_field_name: "request", inline: false }];
  // signerName indicates the requested signer, and is a qualified name.
  // List/watch requests for CertificateSigningRequests can filter on this field using a "spec.signerName=NAME" fieldSelector.
  // Well-known Kubernetes signers are:
  //  1. "kubernetes.io/kube-apiserver-client": issues client certificates that can be used to authenticate to kube-apiserver.
  //   Requests for this signer are never auto-approved by kube-controller-manager, can be issued by the "csrsigning" controller in kube-controller-manager.
  //  2. "kubernetes.io/kube-apiserver-client-kubelet": issues client certificates that kubelets use to authenticate to kube-apiserver.
  //   Requests for this signer can be auto-approved by the "csrapproving" controller in kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
  //  3. "kubernetes.io/kubelet-serving" issues serving certificates that kubelets use to serve TLS endpoints, which kube-apiserver can connect to securely.
  //   Requests for this signer are never auto-approved by kube-controller-manager, and can be issued by the "csrsigning" controller in kube-controller-manager.
  // More details are available at https://k8s.io/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers
  // Custom signerNames can also be specified. The signer defines:
  //  1. Trust distribution: how trust (CA bundles) are distributed.
  //  2. Permitted subjects: and behavior when a disallowed subject is requested.
  //  3. Required, permitted, or forbidden x509 extensions in the request (including whether subjectAltNames are allowed, which types, restrictions on allowed values) and behavior when a disallowed extension is requested.
  //  4. Required, permitted, or forbidden key usages / extended key usages.
  //  5. Expiration/certificate lifetime: whether it is fixed by the signer, configurable by the admin.
  //  6. Whether or not requests for CA certificates are allowed.
  string signer_name = 2 [(dev.f110.kubeproto.field) = { go_name: "SignerName", api_field_name: "signerName", inline: false }];
  // expirationSeconds is the requested duration of validity of the issued
  // certificate. The certificate signer may issue a certificate with a different
  // validity duration so a client must check the delta between the notBefore and
  // and notAfter fields in the issued certificate to determine the actual duration.
  // The v1.22+ in-tree implementations of the well-known Kubernetes signers will
  // honor this field as long as the requested duration is not greater than the
  // maximum duration they will honor per the --cluster-signing-duration CLI
  // flag to the Kubernetes controller manager.
  // Certificate signers may not honor this field for various reasons:
  //   1. Old signer that is unaware of the field (such as the in-tree
  //      implementations prior to v1.22)
  //   2. Signer whose configured maximum is shorter than the requested duration
  //   3. Signer whose configured minimum is longer than the requested duration
  // The minimum valid value for expirationSeconds is 600, i.e. 10 minutes.
  optional int32 expiration_seconds = 3 [(dev.f110.kubeproto.field) = { go_name: "ExpirationSeconds", api_field_name: "expirationSeconds", inline: false }];
  // usages specifies a set of key usages requested in the issued certificate.
  // Requests for TLS client certificates typically request: "digital signature", "key encipherment", "client auth".
  // Requests for TLS serving certificates typically request: "key encipherment", "digital signature", "server auth".
  // Valid values are:
  //  "signing", "digital signature", "content commitment",
  //  "key encipherment", "key agreement", "data encipherment",
  //  "cert sign", "crl sign", "encipher only", "decipher only", "any",
  //  "server auth", "client auth",
  //  "code signing", "email protection", "s/mime",
  //  "ipsec end system", "ipsec tunnel", "ipsec user",
  //  "timestamping", "ocsp signing", "microsoft sgc", "netscape sgc"
  repeated KeyUsage usages = 4 [(dev.f110.kubeproto.field) = { go_name: "Usages", api_field_name: "usages", inline: false }];
  // username contains the name of the user that created the CertificateSigningRequest.
  // Populated by the API server on creation and immutable.
  optional string username = 5 [(dev.f110.kubeproto.field) = { go_name: "Username", api_field_name: "username", inline: false }];
  // uid contains the uid of the user that created the CertificateSigningRequest.
  // Populated by the API server on creation and immutable.
  optional string uid = 6 [(dev.f110.kubeproto.field) = { go_name: "UID", api_field_name: "uid", inline: false }];
  // groups contains group membership of the user that created the CertificateSigningRequest.
  // Populated by the API server on creation and immutable.
  repeated string groups = 7 [(dev.f110.kubeproto.field) = { go_name: "Groups", api_field_name: "groups", inline: false }];
  // extra contains extra attributes of the user that created the CertificateSigningRequest.
  // Populated by the API server on creation and immutable.
  map<string, ExtraValue> extra = 8 [(dev.f110.kubeproto.field) = { go_name: "Extra", api_field_name: "extra", inline: false }];
}

message CertificateSigningRequestStatus {
  // conditions applied to the request. Known conditions are "Approved", "Denied", and "Failed".
  repeated CertificateSigningRequestCondition conditions = 1 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
  // certificate is populated with an issued certificate by the signer after an Approved condition is present.
  // This field is set via the /status subresource. Once populated, this field is immutable.
  // If the certificate signing request is denied, a condition of type "Denied" is added and this field remains empty.
  // If the signer cannot issue the certificate, a condition of type "Failed" is added and this field remains empty.
  // Validation requirements:
  //  1. certificate must contain one or more PEM blocks.
  //  2. All PEM blocks must have the "CERTIFICATE" label, contain no headers, and the encoded data
  //   must be a BER-encoded ASN.1 Certificate structure as described in section 4 of RFC5280.
  //  3. Non-PEM content may appear before or after the "CERTIFICATE" PEM blocks and is unvalidated,
  //   to allow for explanatory text as described in section 5.2 of RFC7468.
  // If more than one PEM block is present, and the definition of the requested spec.signerName
  // does not indicate otherwise, the first block is the issued certificate,
  // and subsequent blocks should be treated as intermediate certificates and presented in TLS handshakes.
  // The certificate is encoded in PEM format.
  // When serialized as JSON or YAML, the data is additionally base64-encoded, so it consists of:
  //     base64(
  //     -----BEGIN CERTIFICATE-----
  //     ...
  //     -----END CERTIFICATE-----
  //     )
  optional bytes certificate = 2 [(dev.f110.kubeproto.field) = { go_name: "Certificate", api_field_name: "certificate", inline: false }];
}

message ExtraValue {
  repeated string items = 1 [(dev.f110.kubeproto.field) = { go_name: "", inline: false }];
}
