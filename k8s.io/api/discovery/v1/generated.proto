// Generated by: gen-go-to-protobuf
syntax = "proto3";
package k8s.io.api.discovery.v1;
option  go_package              = "k8s.io/api/discovery/v1";
option (dev.f110.kubeproto.k8s) = {
  domain: "discovery.k8s.io",
  version: "v1",
};
option (dev.f110.kubeproto.kubeproto_go_package) = "go.f110.dev/kubeproto/go/apis/discoveryv1";

import "kube.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";

enum AddressType {
  ADDRESS_TYPE_IP_V4 = 0 [(dev.f110.kubeproto.value) = { value: "" }];
  ADDRESS_TYPE_IP_V6 = 1 [(dev.f110.kubeproto.value) = { value: "" }];
  ADDRESS_TYPE_FQDN  = 2;
}

message Endpoint {
  // addresses of this endpoint. The contents of this field are interpreted
  // according to the corresponding EndpointSlice addressType field. Consumers
  // must handle different types of addresses in the context of their own
  // capabilities. This must contain at least one address but no more than
  // 100. These are all assumed to be fungible and clients may choose to only
  // use the first element. Refer to: https://issue.k8s.io/106267
  repeated string addresses = 1 [(dev.f110.kubeproto.field) = { go_name: "Addresses", api_field_name: "addresses", inline: false }];
  // conditions contains information about the current status of the endpoint.
  optional EndpointConditions conditions = 2 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
  // hostname of this endpoint. This field may be used by consumers of
  // endpoints to distinguish endpoints from each other (e.g. in DNS names).
  // Multiple endpoints which use the same hostname should be considered
  // fungible (e.g. multiple A values in DNS). Must be lowercase and pass DNS
  // Label (RFC 1123) validation.
  optional string hostname = 3 [(dev.f110.kubeproto.field) = { go_name: "Hostname", api_field_name: "hostname", inline: false }];
  // targetRef is a reference to a Kubernetes object that represents this
  // endpoint.
  optional .k8s.io.api.core.v1.ObjectReference target_ref = 4 [(dev.f110.kubeproto.field) = { go_name: "TargetRef", api_field_name: "targetRef", inline: false }];
  // deprecatedTopology contains topology information part of the v1beta1
  // API. This field is deprecated, and will be removed when the v1beta1
  // API is removed (no sooner than kubernetes v1.24).  While this field can
  // hold values, it is not writable through the v1 API, and any attempts to
  // write to it will be silently ignored. Topology information can be found
  // in the zone and nodeName fields instead.
  map<string, string> deprecated_topology = 5 [(dev.f110.kubeproto.field) = { go_name: "DeprecatedTopology", api_field_name: "deprecatedTopology", inline: false }];
  // nodeName represents the name of the Node hosting this endpoint. This can
  // be used to determine endpoints local to a Node.
  optional string node_name = 6 [(dev.f110.kubeproto.field) = { go_name: "NodeName", api_field_name: "nodeName", inline: false }];
  // zone is the name of the Zone this endpoint exists in.
  optional string zone = 7 [(dev.f110.kubeproto.field) = { go_name: "Zone", api_field_name: "zone", inline: false }];
  // hints contains information associated with how an endpoint should be
  // consumed.
  optional EndpointHints hints = 8 [(dev.f110.kubeproto.field) = { go_name: "Hints", api_field_name: "hints", inline: false }];
}

message EndpointConditions {
  // ready indicates that this endpoint is prepared to receive traffic,
  // according to whatever system is managing the endpoint. A nil value
  // indicates an unknown state. In most cases consumers should interpret this
  // unknown state as ready. For compatibility reasons, ready should never be
  // "true" for terminating endpoints, except when the normal readiness
  // behavior is being explicitly overridden, for example when the associated
  // Service has set the publishNotReadyAddresses flag.
  optional bool ready = 1 [(dev.f110.kubeproto.field) = { go_name: "Ready", api_field_name: "ready", inline: false }];
  // serving is identical to ready except that it is set regardless of the
  // terminating state of endpoints. This condition should be set to true for
  // a ready endpoint that is terminating. If nil, consumers should defer to
  // the ready condition.
  optional bool serving = 2 [(dev.f110.kubeproto.field) = { go_name: "Serving", api_field_name: "serving", inline: false }];
  // terminating indicates that this endpoint is terminating. A nil value
  // indicates an unknown state. Consumers should interpret this unknown state
  // to mean that the endpoint is not terminating.
  optional bool terminating = 3 [(dev.f110.kubeproto.field) = { go_name: "Terminating", api_field_name: "terminating", inline: false }];
}

message EndpointHints {
  // forZones indicates the zone(s) this endpoint should be consumed by to
  // enable topology aware routing.
  repeated ForZone for_zones = 1 [(dev.f110.kubeproto.field) = { go_name: "ForZones", api_field_name: "forZones", inline: false }];
}

message EndpointPort {
  // name represents the name of this port. All ports in an EndpointSlice must have a unique name.
  // If the EndpointSlice is derived from a Kubernetes service, this corresponds to the Service.ports[].name.
  // Name must either be an empty string or pass DNS_LABEL validation:
  // * must be no more than 63 characters long.
  // * must consist of lower case alphanumeric characters or '-'.
  // * must start and end with an alphanumeric character.
  // Default is empty string.
  optional string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // protocol represents the IP protocol for this port.
  // Must be UDP, TCP, or SCTP.
  // Default is TCP.
  optional .k8s.io.api.core.v1.Protocol protocol = 2 [(dev.f110.kubeproto.field) = { go_name: "Protocol", api_field_name: "protocol", inline: false }];
  // port represents the port number of the endpoint.
  // If this is not specified, ports are not restricted and must be
  // interpreted in the context of the specific consumer.
  optional int32 port = 3 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // The application protocol for this port.
  // This is used as a hint for implementations to offer richer behavior for protocols that they understand.
  // This field follows standard Kubernetes label syntax.
  // Valid values are either:
  // * Un-prefixed protocol names - reserved for IANA standard service names (as per
  // RFC-6335 and https://www.iana.org/assignments/service-names).
  // * Kubernetes-defined prefixed names:
  //   * 'kubernetes.io/h2c' - HTTP/2 prior knowledge over cleartext as described in https://www.rfc-editor.org/rfc/rfc9113.html#name-starting-http-2-with-prior-
  //   * 'kubernetes.io/ws'  - WebSocket over cleartext as described in https://www.rfc-editor.org/rfc/rfc6455
  //   * 'kubernetes.io/wss' - WebSocket over TLS as described in https://www.rfc-editor.org/rfc/rfc6455
  // * Other protocols should use implementation-defined prefixed names such as
  // mycompany.com/my-custom-protocol.
  optional string app_protocol = 4 [(dev.f110.kubeproto.field) = { go_name: "AppProtocol", api_field_name: "appProtocol", inline: false }];
}

message EndpointSlice {
  // addressType specifies the type of address carried by this EndpointSlice.
  // All addresses in this slice must be the same type. This field is
  // immutable after creation. The following address types are currently
  // supported:
  // * IPv4: Represents an IPv4 Address.
  // * IPv6: Represents an IPv6 Address.
  // * FQDN: Represents a Fully Qualified Domain Name.
  AddressType address_type = 3 [(dev.f110.kubeproto.field) = { go_name: "AddressType", api_field_name: "addressType", inline: false }];
  // endpoints is a list of unique endpoints in this slice. Each slice may
  // include a maximum of 1000 endpoints.
  repeated Endpoint endpoints = 4 [(dev.f110.kubeproto.field) = { go_name: "Endpoints", api_field_name: "endpoints", inline: false }];
  // ports specifies the list of network ports exposed by each endpoint in
  // this slice. Each port must have a unique name. When ports is empty, it
  // indicates that there are no defined ports. When a port is defined with a
  // nil port value, it indicates "all ports". Each slice may include a
  // maximum of 100 ports.
  repeated EndpointPort ports = 5 [(dev.f110.kubeproto.field) = { go_name: "Ports", api_field_name: "ports", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message EndpointSliceList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is the list of endpoint slices
  repeated EndpointSlice items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ForZone {
  // name represents the name of the zone.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
}
