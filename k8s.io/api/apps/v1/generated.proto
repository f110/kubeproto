// Generated by: gen-go-to-protobuf
syntax = "proto3";
package k8s.io.api.apps.v1;
option  go_package = "k8s.io/api/apps/v1";

import "kube.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";
import "k8s.io/apimachinery/pkg/runtime/generated.proto";
import "k8s.io/apimachinery/pkg/util/intstr/generated.proto";

enum DaemonSetUpdateStrategyType {
  DAEMON_SET_UPDATE_STRATEGY_TYPE_ROLLING_UPDATE = 0;
  DAEMON_SET_UPDATE_STRATEGY_TYPE_ON_DELETE      = 1;
}

enum DeploymentConditionType {
  DEPLOYMENT_CONDITION_TYPE_AVAILABLE       = 0;
  DEPLOYMENT_CONDITION_TYPE_PROGRESSING     = 1;
  DEPLOYMENT_CONDITION_TYPE_REPLICA_FAILURE = 2;
}

enum DeploymentStrategyType {
  DEPLOYMENT_STRATEGY_TYPE_RECREATE       = 0;
  DEPLOYMENT_STRATEGY_TYPE_ROLLING_UPDATE = 1;
}

enum PersistentVolumeClaimRetentionPolicyType {
  PERSISTENT_VOLUME_CLAIM_RETENTION_POLICY_TYPE_RETAIN = 0;
  PERSISTENT_VOLUME_CLAIM_RETENTION_POLICY_TYPE_DELETE = 1;
}

enum PodManagementPolicyType {
  POD_MANAGEMENT_POLICY_TYPE_ORDERED_READY = 0;
  POD_MANAGEMENT_POLICY_TYPE_PARALLEL      = 1;
}

enum ReplicaSetConditionType {
  REPLICA_SET_CONDITION_TYPE_REPLICA_FAILURE = 0;
}

enum StatefulSetUpdateStrategyType {
  STATEFUL_SET_UPDATE_STRATEGY_TYPE_ROLLING_UPDATE = 0;
  STATEFUL_SET_UPDATE_STRATEGY_TYPE_ON_DELETE      = 1;
}

message ControllerRevision {
  // Data is the serialized representation of the state.
  k8s.io.apimachinery.pkg.runtime.RawExtension data = 3 [(dev.f110.kubeproto.field) = { go_name: "Data", api_field_name: "data", inline: false }];
  // Revision indicates the revision of the state represented by Data.
  int64 revision = 4 [(dev.f110.kubeproto.field) = { go_name: "Revision", api_field_name: "revision", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ControllerRevisionList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // Items is the list of ControllerRevisions
  repeated ControllerRevision items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message DaemonSet {
  // The desired behavior of this daemon set.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  DaemonSetSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // The current status of this daemon set. This data may be
  // out of date by some window of time.
  // Populated by the system.
  // Read-only.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  DaemonSetStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message DaemonSetCondition {
  // Type of DaemonSet condition.
  string type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Status of the condition, one of True, False, Unknown.
  k8s.io.api.core.v1.ConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // Last time the condition transitioned from one status to another.
  k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
  // The reason for the condition's last transition.
  string reason = 4 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // A human readable message indicating details about the transition.
  string message = 5 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message DaemonSetList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // A list of daemon sets.
  repeated DaemonSet items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message DaemonSetSpec {
  // A label query over pods that are managed by the daemon set.
  // Must match in order to be controlled.
  // It must match the pod template's labels.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // An object that describes the pod that will be created.
  // The DaemonSet will create exactly one copy of this pod on every node
  // that matches the template's node selector (or on every node if no node
  // selector is specified).
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
  k8s.io.api.core.v1.PodTemplateSpec template = 2 [(dev.f110.kubeproto.field) = { go_name: "Template", api_field_name: "template", inline: false }];
  // An update strategy to replace existing DaemonSet pods with new pods.
  DaemonSetUpdateStrategy update_strategy = 3 [(dev.f110.kubeproto.field) = { go_name: "UpdateStrategy", api_field_name: "updateStrategy", inline: false }];
  // The minimum number of seconds for which a newly created DaemonSet pod should
  // be ready without any of its container crashing, for it to be considered
  // available. Defaults to 0 (pod will be considered available as soon as it
  // is ready).
  int32 min_ready_seconds = 4 [(dev.f110.kubeproto.field) = { go_name: "MinReadySeconds", api_field_name: "minReadySeconds", inline: false }];
  // The number of old history to retain to allow rollback.
  // This is a pointer to distinguish between explicit zero and not specified.
  // Defaults to 10.
  optional int32 revision_history_limit = 5 [(dev.f110.kubeproto.field) = { go_name: "RevisionHistoryLimit", api_field_name: "revisionHistoryLimit", inline: false }];
}

message DaemonSetStatus {
  // The number of nodes that are running at least 1
  // daemon pod and are supposed to run the daemon pod.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
  int32 current_number_scheduled = 1 [(dev.f110.kubeproto.field) = { go_name: "CurrentNumberScheduled", api_field_name: "currentNumberScheduled", inline: false }];
  // The number of nodes that are running the daemon pod, but are
  // not supposed to run the daemon pod.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
  int32 number_misscheduled = 2 [(dev.f110.kubeproto.field) = { go_name: "NumberMisscheduled", api_field_name: "numberMisscheduled", inline: false }];
  // The total number of nodes that should be running the daemon
  // pod (including nodes correctly running the daemon pod).
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
  int32 desired_number_scheduled = 3 [(dev.f110.kubeproto.field) = { go_name: "DesiredNumberScheduled", api_field_name: "desiredNumberScheduled", inline: false }];
  // numberReady is the number of nodes that should be running the daemon pod and have one
  // or more of the daemon pod running with a Ready Condition.
  int32 number_ready = 4 [(dev.f110.kubeproto.field) = { go_name: "NumberReady", api_field_name: "numberReady", inline: false }];
  // The most recent generation observed by the daemon set controller.
  int64 observed_generation = 5 [(dev.f110.kubeproto.field) = { go_name: "ObservedGeneration", api_field_name: "observedGeneration", inline: false }];
  // The total number of nodes that are running updated daemon pod
  int32 updated_number_scheduled = 6 [(dev.f110.kubeproto.field) = { go_name: "UpdatedNumberScheduled", api_field_name: "updatedNumberScheduled", inline: false }];
  // The number of nodes that should be running the
  // daemon pod and have one or more of the daemon pod running and
  // available (ready for at least spec.minReadySeconds)
  int32 number_available = 7 [(dev.f110.kubeproto.field) = { go_name: "NumberAvailable", api_field_name: "numberAvailable", inline: false }];
  // The number of nodes that should be running the
  // daemon pod and have none of the daemon pod running and available
  // (ready for at least spec.minReadySeconds)
  int32 number_unavailable = 8 [(dev.f110.kubeproto.field) = { go_name: "NumberUnavailable", api_field_name: "numberUnavailable", inline: false }];
  // Count of hash collisions for the DaemonSet. The DaemonSet controller
  // uses this field as a collision avoidance mechanism when it needs to
  // create the name for the newest ControllerRevision.
  optional int32 collision_count = 9 [(dev.f110.kubeproto.field) = { go_name: "CollisionCount", api_field_name: "collisionCount", inline: false }];
  // Represents the latest available observations of a DaemonSet's current state.
  repeated DaemonSetCondition conditions = 10 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
}

message DaemonSetUpdateStrategy {
  // Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
  DaemonSetUpdateStrategyType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Rolling update config params. Present only if type = "RollingUpdate".
  // ---
  // to be. Same as Deployment `strategy.rollingUpdate`.
  // See https://github.com/kubernetes/kubernetes/issues/35345
  optional RollingUpdateDaemonSet rolling_update = 2 [(dev.f110.kubeproto.field) = { go_name: "RollingUpdate", api_field_name: "rollingUpdate", inline: false }];
}

message Deployment {
  // Specification of the desired behavior of the Deployment.
  DeploymentSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Most recently observed status of the Deployment.
  DeploymentStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message DeploymentCondition {
  // Type of deployment condition.
  DeploymentConditionType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Status of the condition, one of True, False, Unknown.
  k8s.io.api.core.v1.ConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // The last time this condition was updated.
  k8s.io.apimachinery.pkg.apis.meta.v1.Time last_update_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastUpdateTime", api_field_name: "lastUpdateTime", inline: false }];
  // Last time the condition transitioned from one status to another.
  k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 4 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
  // The reason for the condition's last transition.
  string reason = 5 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // A human readable message indicating details about the transition.
  string message = 6 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message DeploymentList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // Items is the list of Deployments.
  repeated Deployment items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message DeploymentSpec {
  // Number of desired pods. This is a pointer to distinguish between explicit
  // zero and not specified. Defaults to 1.
  optional int32 replicas = 1 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // Label selector for pods. Existing ReplicaSets whose pods are
  // selected by this will be the ones affected by this deployment.
  // It must match the pod template's labels.
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // Template describes the pods that will be created.
  k8s.io.api.core.v1.PodTemplateSpec template = 3 [(dev.f110.kubeproto.field) = { go_name: "Template", api_field_name: "template", inline: false }];
  // The deployment strategy to use to replace existing pods with new ones.
  DeploymentStrategy strategy = 4 [(dev.f110.kubeproto.field) = { go_name: "Strategy", api_field_name: "strategy", inline: false }];
  // Minimum number of seconds for which a newly created pod should be ready
  // without any of its container crashing, for it to be considered available.
  // Defaults to 0 (pod will be considered available as soon as it is ready)
  int32 min_ready_seconds = 5 [(dev.f110.kubeproto.field) = { go_name: "MinReadySeconds", api_field_name: "minReadySeconds", inline: false }];
  // The number of old ReplicaSets to retain to allow rollback.
  // This is a pointer to distinguish between explicit zero and not specified.
  // Defaults to 10.
  optional int32 revision_history_limit = 6 [(dev.f110.kubeproto.field) = { go_name: "RevisionHistoryLimit", api_field_name: "revisionHistoryLimit", inline: false }];
  // Indicates that the deployment is paused.
  bool paused = 7 [(dev.f110.kubeproto.field) = { go_name: "Paused", api_field_name: "paused", inline: false }];
  // The maximum time in seconds for a deployment to make progress before it
  // is considered to be failed. The deployment controller will continue to
  // process failed deployments and a condition with a ProgressDeadlineExceeded
  // reason will be surfaced in the deployment status. Note that progress will
  // not be estimated during the time a deployment is paused. Defaults to 600s.
  optional int32 progress_deadline_seconds = 8 [(dev.f110.kubeproto.field) = { go_name: "ProgressDeadlineSeconds", api_field_name: "progressDeadlineSeconds", inline: false }];
}

message DeploymentStatus {
  // The generation observed by the deployment controller.
  int64 observed_generation = 1 [(dev.f110.kubeproto.field) = { go_name: "ObservedGeneration", api_field_name: "observedGeneration", inline: false }];
  // Total number of non-terminated pods targeted by this deployment (their labels match the selector).
  int32 replicas = 2 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // Total number of non-terminated pods targeted by this deployment that have the desired template spec.
  int32 updated_replicas = 3 [(dev.f110.kubeproto.field) = { go_name: "UpdatedReplicas", api_field_name: "updatedReplicas", inline: false }];
  // readyReplicas is the number of pods targeted by this Deployment with a Ready Condition.
  int32 ready_replicas = 4 [(dev.f110.kubeproto.field) = { go_name: "ReadyReplicas", api_field_name: "readyReplicas", inline: false }];
  // Total number of available pods (ready for at least minReadySeconds) targeted by this deployment.
  int32 available_replicas = 5 [(dev.f110.kubeproto.field) = { go_name: "AvailableReplicas", api_field_name: "availableReplicas", inline: false }];
  // Total number of unavailable pods targeted by this deployment. This is the total number of
  // pods that are still required for the deployment to have 100% available capacity. They may
  // either be pods that are running but not yet available or pods that still have not been created.
  int32 unavailable_replicas = 6 [(dev.f110.kubeproto.field) = { go_name: "UnavailableReplicas", api_field_name: "unavailableReplicas", inline: false }];
  // Represents the latest available observations of a deployment's current state.
  repeated DeploymentCondition conditions = 7 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
  // Count of hash collisions for the Deployment. The Deployment controller uses this
  // field as a collision avoidance mechanism when it needs to create the name for the
  // newest ReplicaSet.
  optional int32 collision_count = 8 [(dev.f110.kubeproto.field) = { go_name: "CollisionCount", api_field_name: "collisionCount", inline: false }];
}

message DeploymentStrategy {
  // Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
  DeploymentStrategyType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Rolling update config params. Present only if DeploymentStrategyType =
  // RollingUpdate.
  // ---
  // to be.
  optional RollingUpdateDeployment rolling_update = 2 [(dev.f110.kubeproto.field) = { go_name: "RollingUpdate", api_field_name: "rollingUpdate", inline: false }];
}

message ReplicaSet {
  // Spec defines the specification of the desired behavior of the ReplicaSet.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  ReplicaSetSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status is the most recently observed status of the ReplicaSet.
  // This data may be out of date by some window of time.
  // Populated by the system.
  // Read-only.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  ReplicaSetStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ReplicaSetCondition {
  // Type of replica set condition.
  ReplicaSetConditionType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Status of the condition, one of True, False, Unknown.
  k8s.io.api.core.v1.ConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // The last time the condition transitioned from one status to another.
  k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
  // The reason for the condition's last transition.
  string reason = 4 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // A human readable message indicating details about the transition.
  string message = 5 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message ReplicaSetList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of ReplicaSets.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
  repeated ReplicaSet items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ReplicaSetSpec {
  // Replicas is the number of desired replicas.
  // This is a pointer to distinguish between explicit zero and unspecified.
  // Defaults to 1.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
  optional int32 replicas = 1 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // Minimum number of seconds for which a newly created pod should be ready
  // without any of its container crashing, for it to be considered available.
  // Defaults to 0 (pod will be considered available as soon as it is ready)
  int32 min_ready_seconds = 2 [(dev.f110.kubeproto.field) = { go_name: "MinReadySeconds", api_field_name: "minReadySeconds", inline: false }];
  // Selector is a label query over pods that should match the replica count.
  // Label keys and values that must match in order to be controlled by this replica set.
  // It must match the pod template's labels.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 3 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // Template is the object that describes the pod that will be created if
  // insufficient replicas are detected.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
  k8s.io.api.core.v1.PodTemplateSpec template = 4 [(dev.f110.kubeproto.field) = { go_name: "Template", api_field_name: "template", inline: false }];
}

message ReplicaSetStatus {
  // Replicas is the most recently oberved number of replicas.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
  int32 replicas = 1 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // The number of pods that have labels matching the labels of the pod template of the replicaset.
  int32 fully_labeled_replicas = 2 [(dev.f110.kubeproto.field) = { go_name: "FullyLabeledReplicas", api_field_name: "fullyLabeledReplicas", inline: false }];
  // readyReplicas is the number of pods targeted by this ReplicaSet with a Ready Condition.
  int32 ready_replicas = 3 [(dev.f110.kubeproto.field) = { go_name: "ReadyReplicas", api_field_name: "readyReplicas", inline: false }];
  // The number of available replicas (ready for at least minReadySeconds) for this replica set.
  int32 available_replicas = 4 [(dev.f110.kubeproto.field) = { go_name: "AvailableReplicas", api_field_name: "availableReplicas", inline: false }];
  // ObservedGeneration reflects the generation of the most recently observed ReplicaSet.
  int64 observed_generation = 5 [(dev.f110.kubeproto.field) = { go_name: "ObservedGeneration", api_field_name: "observedGeneration", inline: false }];
  // Represents the latest available observations of a replica set's current state.
  repeated ReplicaSetCondition conditions = 6 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
}

message RollingUpdateDaemonSet {
  // The maximum number of DaemonSet pods that can be unavailable during the
  // update. Value can be an absolute number (ex: 5) or a percentage of total
  // number of DaemonSet pods at the start of the update (ex: 10%). Absolute
  // number is calculated from percentage by rounding up.
  // This cannot be 0 if MaxSurge is 0
  // Default value is 1.
  // Example: when this is set to 30%, at most 30% of the total number of nodes
  // that should be running the daemon pod (i.e. status.desiredNumberScheduled)
  // can have their pods stopped for an update at any given time. The update
  // starts by stopping at most 30% of those DaemonSet pods and then brings
  // up new DaemonSet pods in their place. Once the new pods are available,
  // it then proceeds onto other DaemonSet pods, thus ensuring that at least
  // 70% of original number of DaemonSet pods are available at all times during
  // the update.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString max_unavailable = 1 [(dev.f110.kubeproto.field) = { go_name: "MaxUnavailable", api_field_name: "maxUnavailable", inline: false }];
  // The maximum number of nodes with an existing available DaemonSet pod that
  // can have an updated DaemonSet pod during during an update.
  // Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
  // This can not be 0 if MaxUnavailable is 0.
  // Absolute number is calculated from percentage by rounding up to a minimum of 1.
  // Default value is 0.
  // Example: when this is set to 30%, at most 30% of the total number of nodes
  // that should be running the daemon pod (i.e. status.desiredNumberScheduled)
  // can have their a new pod created before the old pod is marked as deleted.
  // The update starts by launching new pods on 30% of nodes. Once an updated
  // pod is available (Ready for at least minReadySeconds) the old DaemonSet pod
  // on that node is marked deleted. If the old pod becomes unavailable for any
  // reason (Ready transitions to false, is evicted, or is drained) an updated
  // pod is immediatedly created on that node without considering surge limits.
  // Allowing surge implies the possibility that the resources consumed by the
  // daemonset on any given node can double if the readiness check fails, and
  // so resource intensive daemonsets should take into account that they may
  // cause evictions during disruption.
  // This is beta field and enabled/disabled by DaemonSetUpdateSurge feature gate.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString max_surge = 2 [(dev.f110.kubeproto.field) = { go_name: "MaxSurge", api_field_name: "maxSurge", inline: false }];
}

message RollingUpdateDeployment {
  // The maximum number of pods that can be unavailable during the update.
  // Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
  // Absolute number is calculated from percentage by rounding down.
  // This can not be 0 if MaxSurge is 0.
  // Defaults to 25%.
  // Example: when this is set to 30%, the old ReplicaSet can be scaled down to 70% of desired pods
  // immediately when the rolling update starts. Once new pods are ready, old ReplicaSet
  // can be scaled down further, followed by scaling up the new ReplicaSet, ensuring
  // that the total number of pods available at all times during the update is at
  // least 70% of desired pods.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString max_unavailable = 1 [(dev.f110.kubeproto.field) = { go_name: "MaxUnavailable", api_field_name: "maxUnavailable", inline: false }];
  // The maximum number of pods that can be scheduled above the desired number of
  // pods.
  // Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%).
  // This can not be 0 if MaxUnavailable is 0.
  // Absolute number is calculated from percentage by rounding up.
  // Defaults to 25%.
  // Example: when this is set to 30%, the new ReplicaSet can be scaled up immediately when
  // the rolling update starts, such that the total number of old and new pods do not exceed
  // 130% of desired pods. Once old pods have been killed,
  // new ReplicaSet can be scaled up further, ensuring that total number of pods running
  // at any time during the update is at most 130% of desired pods.
  optional k8s.io.apimachinery.pkg.util.intstr.IntOrString max_surge = 2 [(dev.f110.kubeproto.field) = { go_name: "MaxSurge", api_field_name: "maxSurge", inline: false }];
}

message RollingUpdateStatefulSetStrategy {
  // Partition indicates the ordinal at which the StatefulSet should be
  // partitioned.
  // Default value is 0.
  optional int32 partition = 1 [(dev.f110.kubeproto.field) = { go_name: "Partition", api_field_name: "partition", inline: false }];
}

message StatefulSet {
  // Spec defines the desired identities of pods in this set.
  StatefulSetSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status is the current status of Pods in this StatefulSet. This data
  // may be out of date by some window of time.
  StatefulSetStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message StatefulSetCondition {
  // Type of statefulset condition.
  string type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Status of the condition, one of True, False, Unknown.
  k8s.io.api.core.v1.ConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // Last time the condition transitioned from one status to another.
  k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
  // The reason for the condition's last transition.
  string reason = 4 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // A human readable message indicating details about the transition.
  string message = 5 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message StatefulSetList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list's metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // Items is the list of stateful sets.
  repeated StatefulSet items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message StatefulSetPersistentVolumeClaimRetentionPolicy {
  // WhenDeleted specifies what happens to PVCs created from StatefulSet
  // VolumeClaimTemplates when the StatefulSet is deleted. The default policy
  // of `Retain` causes PVCs to not be affected by StatefulSet deletion. The
  // `Delete` policy causes those PVCs to be deleted.
  PersistentVolumeClaimRetentionPolicyType when_deleted = 1 [(dev.f110.kubeproto.field) = { go_name: "WhenDeleted", api_field_name: "whenDeleted", inline: false }];
  // WhenScaled specifies what happens to PVCs created from StatefulSet
  // VolumeClaimTemplates when the StatefulSet is scaled down. The default
  // policy of `Retain` causes PVCs to not be affected by a scaledown. The
  // `Delete` policy causes the associated PVCs for any excess pods above
  // the replica count to be deleted.
  PersistentVolumeClaimRetentionPolicyType when_scaled = 2 [(dev.f110.kubeproto.field) = { go_name: "WhenScaled", api_field_name: "whenScaled", inline: false }];
}

message StatefulSetSpec {
  // replicas is the desired number of replicas of the given Template.
  // These are replicas in the sense that they are instantiations of the
  // same Template, but individual replicas also have a consistent identity.
  // If unspecified, defaults to 1.
  optional int32 replicas = 1 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // selector is a label query over pods that should match the replica count.
  // It must match the pod template's labels.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // template is the object that describes the pod that will be created if
  // insufficient replicas are detected. Each pod stamped out by the StatefulSet
  // will fulfill this Template, but have a unique identity from the rest
  // of the StatefulSet.
  k8s.io.api.core.v1.PodTemplateSpec template = 3 [(dev.f110.kubeproto.field) = { go_name: "Template", api_field_name: "template", inline: false }];
  // volumeClaimTemplates is a list of claims that pods are allowed to reference.
  // The StatefulSet controller is responsible for mapping network identities to
  // claims in a way that maintains the identity of a pod. Every claim in
  // this list must have at least one matching (by name) volumeMount in one
  // container in the template. A claim in this list takes precedence over
  // any volumes in the template, with the same name.
  repeated k8s.io.api.core.v1.PersistentVolumeClaim volume_claim_templates = 4 [(dev.f110.kubeproto.field) = { go_name: "VolumeClaimTemplates", api_field_name: "volumeClaimTemplates", inline: false }];
  // serviceName is the name of the service that governs this StatefulSet.
  // This service must exist before the StatefulSet, and is responsible for
  // the network identity of the set. Pods get DNS/hostnames that follow the
  // pattern: pod-specific-string.serviceName.default.svc.cluster.local
  // where "pod-specific-string" is managed by the StatefulSet controller.
  string service_name = 5 [(dev.f110.kubeproto.field) = { go_name: "ServiceName", api_field_name: "serviceName", inline: false }];
  // podManagementPolicy controls how pods are created during initial scale up,
  // when replacing pods on nodes, or when scaling down. The default policy is
  // `OrderedReady`, where pods are created in increasing order (pod-0, then
  // pod-1, etc) and the controller will wait until each pod is ready before
  // continuing. When scaling down, the pods are removed in the opposite order.
  // The alternative policy is `Parallel` which will create pods in parallel
  // to match the desired scale without waiting, and on scale down will delete
  // all pods at once.
  PodManagementPolicyType pod_management_policy = 6 [(dev.f110.kubeproto.field) = { go_name: "PodManagementPolicy", api_field_name: "podManagementPolicy", inline: false }];
  // updateStrategy indicates the StatefulSetUpdateStrategy that will be
  // employed to update Pods in the StatefulSet when a revision is made to
  // Template.
  StatefulSetUpdateStrategy update_strategy = 7 [(dev.f110.kubeproto.field) = { go_name: "UpdateStrategy", api_field_name: "updateStrategy", inline: false }];
  // revisionHistoryLimit is the maximum number of revisions that will
  // be maintained in the StatefulSet's revision history. The revision history
  // consists of all revisions not represented by a currently applied
  // StatefulSetSpec version. The default value is 10.
  optional int32 revision_history_limit = 8 [(dev.f110.kubeproto.field) = { go_name: "RevisionHistoryLimit", api_field_name: "revisionHistoryLimit", inline: false }];
  // Minimum number of seconds for which a newly created pod should be ready
  // without any of its container crashing for it to be considered available.
  // Defaults to 0 (pod will be considered available as soon as it is ready)
  // This is an alpha field and requires enabling StatefulSetMinReadySeconds feature gate.
  int32 min_ready_seconds = 9 [(dev.f110.kubeproto.field) = { go_name: "MinReadySeconds", api_field_name: "minReadySeconds", inline: false }];
  // persistentVolumeClaimRetentionPolicy describes the lifecycle of persistent
  // volume claims created from volumeClaimTemplates. By default, all persistent
  // volume claims are created as needed and retained until manually deleted. This
  // policy allows the lifecycle to be altered, for example by deleting persistent
  // volume claims when their stateful set is deleted, or when their pod is scaled
  // down. This requires the StatefulSetAutoDeletePVC feature gate to be enabled,
  // which is alpha.  +optional
  optional StatefulSetPersistentVolumeClaimRetentionPolicy persistent_volume_claim_retention_policy = 10 [(dev.f110.kubeproto.field) = { go_name: "PersistentVolumeClaimRetentionPolicy", api_field_name: "persistentVolumeClaimRetentionPolicy", inline: false }];
}

message StatefulSetStatus {
  // observedGeneration is the most recent generation observed for this StatefulSet. It corresponds to the
  // StatefulSet's generation, which is updated on mutation by the API Server.
  int64 observed_generation = 1 [(dev.f110.kubeproto.field) = { go_name: "ObservedGeneration", api_field_name: "observedGeneration", inline: false }];
  // replicas is the number of Pods created by the StatefulSet controller.
  int32 replicas = 2 [(dev.f110.kubeproto.field) = { go_name: "Replicas", api_field_name: "replicas", inline: false }];
  // readyReplicas is the number of pods created for this StatefulSet with a Ready Condition.
  int32 ready_replicas = 3 [(dev.f110.kubeproto.field) = { go_name: "ReadyReplicas", api_field_name: "readyReplicas", inline: false }];
  // currentReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
  // indicated by currentRevision.
  int32 current_replicas = 4 [(dev.f110.kubeproto.field) = { go_name: "CurrentReplicas", api_field_name: "currentReplicas", inline: false }];
  // updatedReplicas is the number of Pods created by the StatefulSet controller from the StatefulSet version
  // indicated by updateRevision.
  int32 updated_replicas = 5 [(dev.f110.kubeproto.field) = { go_name: "UpdatedReplicas", api_field_name: "updatedReplicas", inline: false }];
  // currentRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the
  // sequence [0,currentReplicas).
  string current_revision = 6 [(dev.f110.kubeproto.field) = { go_name: "CurrentRevision", api_field_name: "currentRevision", inline: false }];
  // updateRevision, if not empty, indicates the version of the StatefulSet used to generate Pods in the sequence
  // [replicas-updatedReplicas,replicas)
  string update_revision = 7 [(dev.f110.kubeproto.field) = { go_name: "UpdateRevision", api_field_name: "updateRevision", inline: false }];
  // collisionCount is the count of hash collisions for the StatefulSet. The StatefulSet controller
  // uses this field as a collision avoidance mechanism when it needs to create the name for the
  // newest ControllerRevision.
  optional int32 collision_count = 8 [(dev.f110.kubeproto.field) = { go_name: "CollisionCount", api_field_name: "collisionCount", inline: false }];
  // Represents the latest available observations of a statefulset's current state.
  repeated StatefulSetCondition conditions = 9 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
  // Total number of available pods (ready for at least minReadySeconds) targeted by this statefulset.
  // This is a beta field and enabled/disabled by StatefulSetMinReadySeconds feature gate.
  int32 available_replicas = 10 [(dev.f110.kubeproto.field) = { go_name: "AvailableReplicas", api_field_name: "availableReplicas", inline: false }];
}

message StatefulSetUpdateStrategy {
  // Type indicates the type of the StatefulSetUpdateStrategy.
  // Default is RollingUpdate.
  StatefulSetUpdateStrategyType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // RollingUpdate is used to communicate parameters when Type is RollingUpdateStatefulSetStrategyType.
  optional RollingUpdateStatefulSetStrategy rolling_update = 2 [(dev.f110.kubeproto.field) = { go_name: "RollingUpdate", api_field_name: "rollingUpdate", inline: false }];
}
