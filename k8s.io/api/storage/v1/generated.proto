// Generated by: gen-go-to-protobuf
syntax = "proto3";
package k8s.io.api.storage.v1;
option  go_package              = "k8s.io/api/storage/v1";
option (dev.f110.kubeproto.k8s) = {
  domain: "storage.k8s.io",
  version: "v1",
};
option (dev.f110.kubeproto.kubeproto_go_package) = "go.f110.dev/kubeproto/go/apis/storagev1";

import "kube.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/api/resource/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";

enum FSGroupPolicy {
  FS_GROUP_POLICY_READ_WRITE_ONCE_WITH_FS_TYPE = 0 [(dev.f110.kubeproto.value) = { value: "ReadWriteOnceWithFSType" }];
  FS_GROUP_POLICY_FILE                         = 1 [(dev.f110.kubeproto.value) = { value: "File" }];
  FS_GROUP_POLICY_NONE                         = 2 [(dev.f110.kubeproto.value) = { value: "None" }];
}

enum VolumeBindingMode {
  VOLUME_BINDING_MODE_IMMEDIATE               = 0 [(dev.f110.kubeproto.value) = { value: "Immediate" }];
  VOLUME_BINDING_MODE_WAIT_FOR_FIRST_CONSUMER = 1;
}

enum VolumeLifecycleMode {
  VOLUME_LIFECYCLE_MODE_PERSISTENT = 0 [(dev.f110.kubeproto.value) = { value: "Persistent" }];
  VOLUME_LIFECYCLE_MODE_EPHEMERAL  = 1 [(dev.f110.kubeproto.value) = { value: "Ephemeral" }];
}

message CSIDriver {
  // spec represents the specification of the CSI Driver.
  CSIDriverSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];

  option (dev.f110.kubeproto.kind) = {
    scope: SCOPE_CLUSTER
  };
}

message CSIDriverList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is the list of CSIDriver
  repeated CSIDriver items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message CSIDriverSpec {
  // attachRequired indicates this CSI volume driver requires an attach
  // operation (because it implements the CSI ControllerPublishVolume()
  // method), and that the Kubernetes attach detach controller should call
  // the attach volume interface which checks the volumeattachment status
  // and waits until the volume is attached before proceeding to mounting.
  // The CSI external-attacher coordinates with CSI volume driver and updates
  // the volumeattachment status when the attach operation is complete.
  // If the CSIDriverRegistry feature gate is enabled and the value is
  // specified to false, the attach operation will be skipped.
  // Otherwise the attach operation will be called.
  // This field is immutable.
  optional bool attach_required = 1 [(dev.f110.kubeproto.field) = { go_name: "AttachRequired", api_field_name: "attachRequired", inline: false }];
  // podInfoOnMount indicates this CSI volume driver requires additional pod information (like podName, podUID, etc.)
  // during mount operations, if set to true.
  // If set to false, pod information will not be passed on mount.
  // Default is false.
  // The CSI driver specifies podInfoOnMount as part of driver deployment.
  // If true, Kubelet will pass pod information as VolumeContext in the CSI NodePublishVolume() calls.
  // The CSI driver is responsible for parsing and validating the information passed in as VolumeContext.
  // The following VolumeContext will be passed if podInfoOnMount is set to true.
  // This list might grow, but the prefix will be used.
  // "csi.storage.k8s.io/pod.name": pod.Name
  // "csi.storage.k8s.io/pod.namespace": pod.Namespace
  // "csi.storage.k8s.io/pod.uid": string(pod.UID)
  // "csi.storage.k8s.io/ephemeral": "true" if the volume is an ephemeral inline volume
  //                                 defined by a CSIVolumeSource, otherwise "false"
  // "csi.storage.k8s.io/ephemeral" is a new feature in Kubernetes 1.16. It is only
  // required for drivers which support both the "Persistent" and "Ephemeral" VolumeLifecycleMode.
  // Other drivers can leave pod info disabled and/or ignore this field.
  // As Kubernetes 1.15 doesn't support this field, drivers can only support one mode when
  // deployed on such a cluster and the deployment determines which mode that is, for example
  // via a command line parameter of the driver.
  // This field was immutable in Kubernetes < 1.29 and now is mutable.
  optional bool pod_info_on_mount = 2 [(dev.f110.kubeproto.field) = { go_name: "PodInfoOnMount", api_field_name: "podInfoOnMount", inline: false }];
  // volumeLifecycleModes defines what kind of volumes this CSI volume driver supports.
  // The default if the list is empty is "Persistent", which is the usage defined by the
  // CSI specification and implemented in Kubernetes via the usual PV/PVC mechanism.
  // The other mode is "Ephemeral". In this mode, volumes are defined inline inside the pod spec
  // with CSIVolumeSource and their lifecycle is tied to the lifecycle of that pod.
  // A driver has to be aware of this because it is only going to get a NodePublishVolume call for such a volume.
  // For more information about implementing this mode, see
  // https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html
  // A driver can support one or more of these modes and more modes may be added in the future.
  // This field is beta.
  // This field is immutable.
  repeated VolumeLifecycleMode volume_lifecycle_modes = 3 [(dev.f110.kubeproto.field) = { go_name: "VolumeLifecycleModes", api_field_name: "volumeLifecycleModes", inline: false }];
  // storageCapacity indicates that the CSI volume driver wants pod scheduling to consider the storage
  // capacity that the driver deployment will report by creating
  // CSIStorageCapacity objects with capacity information, if set to true.
  // The check can be enabled immediately when deploying a driver.
  // In that case, provisioning new volumes with late binding
  // will pause until the driver deployment has published
  // some suitable CSIStorageCapacity object.
  // Alternatively, the driver can be deployed with the field
  // unset or false and it can be flipped later when storage
  // capacity information has been published.
  // This field was immutable in Kubernetes <= 1.22 and now is mutable.
  optional bool storage_capacity = 4 [(dev.f110.kubeproto.field) = { go_name: "StorageCapacity", api_field_name: "storageCapacity", inline: false }];
  // fsGroupPolicy defines if the underlying volume supports changing ownership and
  // permission of the volume before being mounted.
  // Refer to the specific FSGroupPolicy values for additional details.
  // This field was immutable in Kubernetes < 1.29 and now is mutable.
  // Defaults to ReadWriteOnceWithFSType, which will examine each volume
  // to determine if Kubernetes should modify ownership and permissions of the volume.
  // With the default policy the defined fsGroup will only be applied
  // if a fstype is defined and the volume's access mode contains ReadWriteOnce.
  optional FSGroupPolicy fs_group_policy = 5 [(dev.f110.kubeproto.field) = { go_name: "FSGroupPolicy", api_field_name: "fsGroupPolicy", inline: false }];
  // tokenRequests indicates the CSI driver needs pods' service account
  // tokens it is mounting volume for to do necessary authentication. Kubelet
  // will pass the tokens in VolumeContext in the CSI NodePublishVolume calls.
  // The CSI driver should parse and validate the following VolumeContext:
  // "csi.storage.k8s.io/serviceAccount.tokens": {
  //   "<audience>": {
  //     "token": <token>,
  //     "expirationTimestamp": <expiration timestamp in RFC3339>,
  //   },
  //   ...
  // }
  // Note: Audience in each TokenRequest should be different and at
  // most one token is empty string. To receive a new token after expiry,
  // RequiresRepublish can be used to trigger NodePublishVolume periodically.
  repeated TokenRequest token_requests = 6 [(dev.f110.kubeproto.field) = { go_name: "TokenRequests", api_field_name: "tokenRequests", inline: false }];
  // requiresRepublish indicates the CSI driver wants `NodePublishVolume`
  // being periodically called to reflect any possible change in the mounted
  // volume. This field defaults to false.
  // Note: After a successful initial NodePublishVolume call, subsequent calls
  // to NodePublishVolume should only update the contents of the volume. New
  // mount points will not be seen by a running container.
  optional bool requires_republish = 7 [(dev.f110.kubeproto.field) = { go_name: "RequiresRepublish", api_field_name: "requiresRepublish", inline: false }];
  // seLinuxMount specifies if the CSI driver supports "-o context"
  // mount option.
  // When "true", the CSI driver must ensure that all volumes provided by this CSI
  // driver can be mounted separately with different `-o context` options. This is
  // typical for storage backends that provide volumes as filesystems on block
  // devices or as independent shared volumes.
  // Kubernetes will call NodeStage / NodePublish with "-o context=xyz" mount
  // option when mounting a ReadWriteOncePod volume used in Pod that has
  // explicitly set SELinux context. In the future, it may be expanded to other
  // volume AccessModes. In any case, Kubernetes will ensure that the volume is
  // mounted only with a single SELinux context.
  // When "false", Kubernetes won't pass any special SELinux mount options to the driver.
  // This is typical for volumes that represent subdirectories of a bigger shared filesystem.
  // Default is "false".
  optional bool selinux_mount = 8 [(dev.f110.kubeproto.field) = { go_name: "SELinuxMount", api_field_name: "seLinuxMount", inline: false }];
}

message CSINode {
  // spec is the specification of CSINode
  CSINodeSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];

  option (dev.f110.kubeproto.kind) = {
    scope: SCOPE_CLUSTER
  };
}

message CSINodeDriver {
  // name represents the name of the CSI driver that this object refers to.
  // This MUST be the same name returned by the CSI GetPluginName() call for
  // that driver.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // nodeID of the node from the driver point of view.
  // This field enables Kubernetes to communicate with storage systems that do
  // not share the same nomenclature for nodes. For example, Kubernetes may
  // refer to a given node as "node1", but the storage system may refer to
  // the same node as "nodeA". When Kubernetes issues a command to the storage
  // system to attach a volume to a specific node, it can use this field to
  // refer to the node name using the ID that the storage system will
  // understand, e.g. "nodeA" instead of "node1". This field is required.
  string node_id = 2 [(dev.f110.kubeproto.field) = { go_name: "NodeID", api_field_name: "nodeID", inline: false }];
  // topologyKeys is the list of keys supported by the driver.
  // When a driver is initialized on a cluster, it provides a set of topology
  // keys that it understands (e.g. "company.com/zone", "company.com/region").
  // When a driver is initialized on a node, it provides the same topology keys
  // along with values. Kubelet will expose these topology keys as labels
  // on its own node object.
  // When Kubernetes does topology aware provisioning, it can use this list to
  // determine which labels it should retrieve from the node object and pass
  // back to the driver.
  // It is possible for different nodes to use different topology keys.
  // This can be empty if driver does not support topology.
  repeated string topology_keys = 3 [(dev.f110.kubeproto.field) = { go_name: "TopologyKeys", api_field_name: "topologyKeys", inline: false }];
  // allocatable represents the volume resources of a node that are available for scheduling.
  // This field is beta.
  optional VolumeNodeResources allocatable = 4 [(dev.f110.kubeproto.field) = { go_name: "Allocatable", api_field_name: "allocatable", inline: false }];
}

message CSINodeList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is the list of CSINode
  repeated CSINode items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message CSINodeSpec {
  // drivers is a list of information of all CSI Drivers existing on a node.
  // If all drivers in the list are uninstalled, this can become empty.
  repeated CSINodeDriver drivers = 1 [(dev.f110.kubeproto.field) = { go_name: "Drivers", api_field_name: "drivers", inline: false }];
}

message CSIStorageCapacity {
  // nodeTopology defines which nodes have access to the storage
  // for which capacity was reported. If not set, the storage is
  // not accessible from any node in the cluster. If empty, the
  // storage is accessible from all nodes. This field is
  // immutable.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector node_topology = 3 [(dev.f110.kubeproto.field) = { go_name: "NodeTopology", api_field_name: "nodeTopology", inline: false }];
  // storageClassName represents the name of the StorageClass that the reported capacity applies to.
  // It must meet the same requirements as the name of a StorageClass
  // object (non-empty, DNS subdomain). If that object no longer exists,
  // the CSIStorageCapacity object is obsolete and should be removed by its
  // creator.
  // This field is immutable.
  string storage_class_name = 4 [(dev.f110.kubeproto.field) = { go_name: "StorageClassName", api_field_name: "storageClassName", inline: false }];
  // capacity is the value reported by the CSI driver in its GetCapacityResponse
  // for a GetCapacityRequest with topology and parameters that match the
  // previous fields.
  // The semantic is currently (CSI spec 1.2) defined as:
  // The available capacity, in bytes, of the storage that can be used
  // to provision volumes. If not set, that information is currently
  // unavailable.
  optional .k8s.io.apimachinery.pkg.api.resource.Quantity capacity = 5 [(dev.f110.kubeproto.field) = { go_name: "Capacity", api_field_name: "capacity", inline: false }];
  // maximumVolumeSize is the value reported by the CSI driver in its GetCapacityResponse
  // for a GetCapacityRequest with topology and parameters that match the
  // previous fields.
  // This is defined since CSI spec 1.4.0 as the largest size
  // that may be used in a
  // CreateVolumeRequest.capacity_range.required_bytes field to
  // create a volume with the same parameters as those in
  // GetCapacityRequest. The corresponding value in the Kubernetes
  // API is ResourceRequirements.Requests in a volume claim.
  optional .k8s.io.apimachinery.pkg.api.resource.Quantity maximum_volume_size = 6 [(dev.f110.kubeproto.field) = { go_name: "MaximumVolumeSize", api_field_name: "maximumVolumeSize", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message CSIStorageCapacityList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is the list of CSIStorageCapacity objects.
  repeated CSIStorageCapacity items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message StorageClass {
  // provisioner indicates the type of the provisioner.
  string provisioner = 3 [(dev.f110.kubeproto.field) = { go_name: "Provisioner", api_field_name: "provisioner", inline: false }];
  // parameters holds the parameters for the provisioner that should
  // create volumes of this storage class.
  map<string, string> parameters = 4 [(dev.f110.kubeproto.field) = { go_name: "Parameters", api_field_name: "parameters", inline: false }];
  // reclaimPolicy controls the reclaimPolicy for dynamically provisioned PersistentVolumes of this storage class.
  // Defaults to Delete.
  optional .k8s.io.api.core.v1.PersistentVolumeReclaimPolicy reclaim_policy = 5 [(dev.f110.kubeproto.field) = { go_name: "ReclaimPolicy", api_field_name: "reclaimPolicy", inline: false }];
  // mountOptions controls the mountOptions for dynamically provisioned PersistentVolumes of this storage class.
  // e.g. ["ro", "soft"]. Not validated -
  // mount of the PVs will simply fail if one is invalid.
  repeated string mount_options = 6 [(dev.f110.kubeproto.field) = { go_name: "MountOptions", api_field_name: "mountOptions", inline: false }];
  // allowVolumeExpansion shows whether the storage class allow volume expand.
  optional bool allow_volume_expansion = 7 [(dev.f110.kubeproto.field) = { go_name: "AllowVolumeExpansion", api_field_name: "allowVolumeExpansion", inline: false }];
  // volumeBindingMode indicates how PersistentVolumeClaims should be
  // provisioned and bound.  When unset, VolumeBindingImmediate is used.
  // This field is only honored by servers that enable the VolumeScheduling feature.
  optional VolumeBindingMode volume_binding_mode = 8 [(dev.f110.kubeproto.field) = { go_name: "VolumeBindingMode", api_field_name: "volumeBindingMode", inline: false }];
  // allowedTopologies restrict the node topologies where volumes can be dynamically provisioned.
  // Each volume plugin defines its own supported topology specifications.
  // An empty TopologySelectorTerm list means there is no topology restriction.
  // This field is only honored by servers that enable the VolumeScheduling feature.
  repeated .k8s.io.api.core.v1.TopologySelectorTerm allowed_topologies = 9 [(dev.f110.kubeproto.field) = { go_name: "AllowedTopologies", api_field_name: "allowedTopologies", inline: false }];

  option (dev.f110.kubeproto.kind) = {
    scope: SCOPE_CLUSTER
  };
}

message StorageClassList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is the list of StorageClasses
  repeated StorageClass items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message TokenRequest {
  // audience is the intended audience of the token in "TokenRequestSpec".
  // It will default to the audiences of kube apiserver.
  string audience = 1 [(dev.f110.kubeproto.field) = { go_name: "Audience", api_field_name: "audience", inline: false }];
  // expirationSeconds is the duration of validity of the token in "TokenRequestSpec".
  // It has the same default value of "ExpirationSeconds" in "TokenRequestSpec".
  optional int64 expiration_seconds = 2 [(dev.f110.kubeproto.field) = { go_name: "ExpirationSeconds", api_field_name: "expirationSeconds", inline: false }];
}

message VolumeAttachment {
  // spec represents specification of the desired attach/detach volume behavior.
  // Populated by the Kubernetes system.
  VolumeAttachmentSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // status represents status of the VolumeAttachment request.
  // Populated by the entity completing the attach or detach
  // operation, i.e. the external-attacher.
  optional VolumeAttachmentStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", sub_resource: true, inline: false }];

  option (dev.f110.kubeproto.kind) = {
    scope: SCOPE_CLUSTER
  };
}

message VolumeAttachmentList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is the list of VolumeAttachments
  repeated VolumeAttachment items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message VolumeAttachmentSource {
  // persistentVolumeName represents the name of the persistent volume to attach.
  optional string persistent_volume_name = 1 [(dev.f110.kubeproto.field) = { go_name: "PersistentVolumeName", api_field_name: "persistentVolumeName", inline: false }];
  // inlineVolumeSpec contains all the information necessary to attach
  // a persistent volume defined by a pod's inline VolumeSource. This field
  // is populated only for the CSIMigration feature. It contains
  // translated fields from a pod's inline VolumeSource to a
  // PersistentVolumeSpec. This field is beta-level and is only
  // honored by servers that enabled the CSIMigration feature.
  optional .k8s.io.api.core.v1.PersistentVolumeSpec inline_volume_spec = 2 [(dev.f110.kubeproto.field) = { go_name: "InlineVolumeSpec", api_field_name: "inlineVolumeSpec", inline: false }];
}

message VolumeAttachmentSpec {
  // attacher indicates the name of the volume driver that MUST handle this
  // request. This is the name returned by GetPluginName().
  string attacher = 1 [(dev.f110.kubeproto.field) = { go_name: "Attacher", api_field_name: "attacher", inline: false }];
  // source represents the volume that should be attached.
  VolumeAttachmentSource source = 2 [(dev.f110.kubeproto.field) = { go_name: "Source", api_field_name: "source", inline: false }];
  // nodeName represents the node that the volume should be attached to.
  string node_name = 3 [(dev.f110.kubeproto.field) = { go_name: "NodeName", api_field_name: "nodeName", inline: false }];
}

message VolumeAttachmentStatus {
  // attached indicates the volume is successfully attached.
  // This field must only be set by the entity completing the attach
  // operation, i.e. the external-attacher.
  bool attached = 1 [(dev.f110.kubeproto.field) = { go_name: "Attached", api_field_name: "attached", inline: false }];
  // attachmentMetadata is populated with any
  // information returned by the attach operation, upon successful attach, that must be passed
  // into subsequent WaitForAttach or Mount calls.
  // This field must only be set by the entity completing the attach
  // operation, i.e. the external-attacher.
  map<string, string> attachment_metadata = 2 [(dev.f110.kubeproto.field) = { go_name: "AttachmentMetadata", api_field_name: "attachmentMetadata", inline: false }];
  // attachError represents the last error encountered during attach operation, if any.
  // This field must only be set by the entity completing the attach
  // operation, i.e. the external-attacher.
  optional VolumeError attach_error = 3 [(dev.f110.kubeproto.field) = { go_name: "AttachError", api_field_name: "attachError", inline: false }];
  // detachError represents the last error encountered during detach operation, if any.
  // This field must only be set by the entity completing the detach
  // operation, i.e. the external-attacher.
  optional VolumeError detach_error = 4 [(dev.f110.kubeproto.field) = { go_name: "DetachError", api_field_name: "detachError", inline: false }];
}

message VolumeError {
  // time represents the time the error was encountered.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 1 [(dev.f110.kubeproto.field) = { go_name: "Time", api_field_name: "time", inline: false }];
  // message represents the error encountered during Attach or Detach operation.
  // This string may be logged, so it should not contain sensitive
  // information.
  optional string message = 2 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message VolumeNodeResources {
  // count indicates the maximum number of unique volumes managed by the CSI driver that can be used on a node.
  // A volume that is both attached and mounted on a node is considered to be used once, not twice.
  // The same rule applies for a unique volume that is shared among multiple pods on the same node.
  // If this field is not specified, then the supported number of volumes on this node is unbounded.
  optional int32 count = 1 [(dev.f110.kubeproto.field) = { go_name: "Count", api_field_name: "count", inline: false }];
}
