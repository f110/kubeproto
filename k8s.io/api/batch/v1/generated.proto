// Generated by: gen-go-to-protobuf
syntax = "proto3";
package k8s.io.api.batch.v1;
option  go_package              = "k8s.io/api/batch/v1";
option (dev.f110.kubeproto.k8s) = {
  domain: "apps",
  version: "v1",
};
option (dev.f110.kubeproto.kubeproto_go_package) = "go.f110.dev/kubeproto/go/apis/batchv1";

import "kube.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";

enum CompletionMode {
  COMPLETION_MODE_NON_INDEXED = 0;
  COMPLETION_MODE_INDEXED     = 1 [(dev.f110.kubeproto.value) = { value: "Indexed" }];
}

enum ConcurrencyPolicy {
  CONCURRENCY_POLICY_ALLOW   = 0 [(dev.f110.kubeproto.value) = { value: "Allow" }];
  CONCURRENCY_POLICY_FORBID  = 1 [(dev.f110.kubeproto.value) = { value: "Forbid" }];
  CONCURRENCY_POLICY_REPLACE = 2 [(dev.f110.kubeproto.value) = { value: "Replace" }];
}

enum JobConditionType {
  JOB_CONDITION_TYPE_SUSPENDED      = 0 [(dev.f110.kubeproto.value) = { value: "Suspended" }];
  JOB_CONDITION_TYPE_COMPLETE       = 1 [(dev.f110.kubeproto.value) = { value: "Complete" }];
  JOB_CONDITION_TYPE_FAILED         = 2 [(dev.f110.kubeproto.value) = { value: "Failed" }];
  JOB_CONDITION_TYPE_FAILURE_TARGET = 3;
}

enum PodFailurePolicyAction {
  POD_FAILURE_POLICY_ACTION_FAIL_JOB = 0;
  POD_FAILURE_POLICY_ACTION_IGNORE   = 1 [(dev.f110.kubeproto.value) = { value: "Ignore" }];
  POD_FAILURE_POLICY_ACTION_COUNT    = 2 [(dev.f110.kubeproto.value) = { value: "Count" }];
}

enum PodFailurePolicyOnExitCodesOperator {
  POD_FAILURE_POLICY_ON_EXIT_CODES_OPERATOR_IN     = 0 [(dev.f110.kubeproto.value) = { value: "In" }];
  POD_FAILURE_POLICY_ON_EXIT_CODES_OPERATOR_NOT_IN = 1;
}

message CronJob {
  // Specification of the desired behavior of a cron job, including the schedule.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional CronJobSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Current status of a cron job.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional CronJobStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", sub_resource: true, inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message CronJobList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is the list of CronJobs.
  repeated CronJob items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message CronJobSpec {
  // The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
  string schedule = 1 [(dev.f110.kubeproto.field) = { go_name: "Schedule", api_field_name: "schedule", inline: false }];
  // The time zone name for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
  // If not specified, this will default to the time zone of the kube-controller-manager process.
  // The set of valid time zone names and the time zone offset is loaded from the system-wide time zone
  // database by the API server during CronJob validation and the controller manager during execution.
  // If no system-wide time zone database can be found a bundled version of the database is used instead.
  // If the time zone name becomes invalid during the lifetime of a CronJob or due to a change in host
  // configuration, the controller will stop creating new new Jobs and will create a system event with the
  // reason UnknownTimeZone.
  // More information can be found in https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#time-zones
  optional string time_zone = 2 [(dev.f110.kubeproto.field) = { go_name: "TimeZone", api_field_name: "timeZone", inline: false }];
  // Optional deadline in seconds for starting the job if it misses scheduled
  // time for any reason.  Missed jobs executions will be counted as failed ones.
  optional int64 starting_deadline_seconds = 3 [(dev.f110.kubeproto.field) = { go_name: "StartingDeadlineSeconds", api_field_name: "startingDeadlineSeconds", inline: false }];
  // Specifies how to treat concurrent executions of a Job.
  // Valid values are:
  // - "Allow" (default): allows CronJobs to run concurrently;
  // - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
  // - "Replace": cancels currently running job and replaces it with a new one
  optional ConcurrencyPolicy concurrency_policy = 4 [(dev.f110.kubeproto.field) = { go_name: "ConcurrencyPolicy", api_field_name: "concurrencyPolicy", inline: false }];
  // This flag tells the controller to suspend subsequent executions, it does
  // not apply to already started executions.  Defaults to false.
  optional bool suspend = 5 [(dev.f110.kubeproto.field) = { go_name: "Suspend", api_field_name: "suspend", inline: false }];
  // Specifies the job that will be created when executing a CronJob.
  JobTemplateSpec job_template = 6 [(dev.f110.kubeproto.field) = { go_name: "JobTemplate", api_field_name: "jobTemplate", inline: false }];
  // The number of successful finished jobs to retain. Value must be non-negative integer.
  // Defaults to 3.
  optional int32 successful_jobs_history_limit = 7 [(dev.f110.kubeproto.field) = { go_name: "SuccessfulJobsHistoryLimit", api_field_name: "successfulJobsHistoryLimit", inline: false }];
  // The number of failed finished jobs to retain. Value must be non-negative integer.
  // Defaults to 1.
  optional int32 failed_jobs_history_limit = 8 [(dev.f110.kubeproto.field) = { go_name: "FailedJobsHistoryLimit", api_field_name: "failedJobsHistoryLimit", inline: false }];
}

message CronJobStatus {
  // A list of pointers to currently running jobs.
  repeated .k8s.io.api.core.v1.ObjectReference active = 1 [(dev.f110.kubeproto.field) = { go_name: "Active", api_field_name: "active", inline: false }];
  // Information when was the last time the job was successfully scheduled.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_schedule_time = 2 [(dev.f110.kubeproto.field) = { go_name: "LastScheduleTime", api_field_name: "lastScheduleTime", inline: false }];
  // Information when was the last time the job successfully completed.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_successful_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastSuccessfulTime", api_field_name: "lastSuccessfulTime", inline: false }];
}

message Job {
  // Specification of the desired behavior of a job.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional JobSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Current status of a job.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional JobStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", sub_resource: true, inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message JobCondition {
  // Type of job condition, Complete or Failed.
  JobConditionType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Status of the condition, one of True, False, Unknown.
  .k8s.io.api.core.v1.ConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // Last time the condition was checked.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_probe_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastProbeTime", api_field_name: "lastProbeTime", inline: false }];
  // Last time the condition transit from one status to another.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 4 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
  // (brief) reason for the condition's last transition.
  optional string reason = 5 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // Human readable message indicating details about last transition.
  optional string message = 6 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message JobList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is the list of Jobs.
  repeated Job items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message JobSpec {
  // Specifies the maximum desired number of pods the job should
  // run at any given time. The actual number of pods running in steady state will
  // be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism),
  // i.e. when the work left to do is less than max parallelism.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
  optional int32 parallelism = 1 [(dev.f110.kubeproto.field) = { go_name: "Parallelism", api_field_name: "parallelism", inline: false }];
  // Specifies the desired number of successfully finished pods the
  // job should be run with.  Setting to null means that the success of any
  // pod signals the success of all pods, and allows parallelism to have any positive
  // value.  Setting to 1 means that parallelism is limited to 1 and the success of that
  // pod signals the success of the job.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
  optional int32 completions = 2 [(dev.f110.kubeproto.field) = { go_name: "Completions", api_field_name: "completions", inline: false }];
  // Specifies the duration in seconds relative to the startTime that the job
  // may be continuously active before the system tries to terminate it; value
  // must be positive integer. If a Job is suspended (at creation or through an
  // update), this timer will effectively be stopped and reset when the Job is
  // resumed again.
  optional int64 active_deadline_seconds = 3 [(dev.f110.kubeproto.field) = { go_name: "ActiveDeadlineSeconds", api_field_name: "activeDeadlineSeconds", inline: false }];
  // Specifies the policy of handling failed pods. In particular, it allows to
  // specify the set of actions and conditions which need to be
  // satisfied to take the associated action.
  // If empty, the default behaviour applies - the counter of failed pods,
  // represented by the jobs's .status.failed field, is incremented and it is
  // checked against the backoffLimit. This field cannot be used in combination
  // with restartPolicy=OnFailure.
  // This field is alpha-level. To use this field, you must enable the
  // `JobPodFailurePolicy` feature gate (disabled by default).
  optional PodFailurePolicy pod_failure_policy = 4 [(dev.f110.kubeproto.field) = { go_name: "PodFailurePolicy", api_field_name: "podFailurePolicy", inline: false }];
  // Specifies the number of retries before marking this job failed.
  // Defaults to 6
  optional int32 backoff_limit = 5 [(dev.f110.kubeproto.field) = { go_name: "BackoffLimit", api_field_name: "backoffLimit", inline: false }];
  // A label query over pods that should match the pod count.
  // Normally, the system sets this field for you.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 6 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // manualSelector controls generation of pod labels and pod selectors.
  // Leave `manualSelector` unset unless you are certain what you are doing.
  // When false or unset, the system pick labels unique to this job
  // and appends those labels to the pod template.  When true,
  // the user is responsible for picking unique labels and specifying
  // the selector.  Failure to pick a unique label may cause this
  // and other jobs to not function correctly.  However, You may see
  // `manualSelector=true` in jobs that were created with the old `extensions/v1beta1`
  // API.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
  optional bool manual_selector = 7 [(dev.f110.kubeproto.field) = { go_name: "ManualSelector", api_field_name: "manualSelector", inline: false }];
  // Describes the pod that will be created when executing a job.
  // The only allowed template.spec.restartPolicy values are "Never" or "OnFailure".
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
  .k8s.io.api.core.v1.PodTemplateSpec template = 8 [(dev.f110.kubeproto.field) = { go_name: "Template", api_field_name: "template", inline: false }];
  // ttlSecondsAfterFinished limits the lifetime of a Job that has finished
  // execution (either Complete or Failed). If this field is set,
  // ttlSecondsAfterFinished after the Job finishes, it is eligible to be
  // automatically deleted. When the Job is being deleted, its lifecycle
  // guarantees (e.g. finalizers) will be honored. If this field is unset,
  // the Job won't be automatically deleted. If this field is set to zero,
  // the Job becomes eligible to be deleted immediately after it finishes.
  optional int32 t_tls_econds_after_finished = 9 [(dev.f110.kubeproto.field) = { go_name: "TTLSecondsAfterFinished", api_field_name: "ttlSecondsAfterFinished", inline: false }];
  // completionMode specifies how Pod completions are tracked. It can be
  // `NonIndexed` (default) or `Indexed`.
  // `NonIndexed` means that the Job is considered complete when there have
  // been .spec.completions successfully completed Pods. Each Pod completion is
  // homologous to each other.
  // `Indexed` means that the Pods of a
  // Job get an associated completion index from 0 to (.spec.completions - 1),
  // available in the annotation batch.kubernetes.io/job-completion-index.
  // The Job is considered complete when there is one successfully completed Pod
  // for each index.
  // When value is `Indexed`, .spec.completions must be specified and
  // `.spec.parallelism` must be less than or equal to 10^5.
  // In addition, The Pod name takes the form
  // `$(job-name)-$(index)-$(random-string)`,
  // the Pod hostname takes the form `$(job-name)-$(index)`.
  // More completion modes can be added in the future.
  // If the Job controller observes a mode that it doesn't recognize, which
  // is possible during upgrades due to version skew, the controller
  // skips updates for the Job.
  optional CompletionMode completion_mode = 10 [(dev.f110.kubeproto.field) = { go_name: "CompletionMode", api_field_name: "completionMode", inline: false }];
  // suspend specifies whether the Job controller should create Pods or not. If
  // a Job is created with suspend set to true, no Pods are created by the Job
  // controller. If a Job is suspended after creation (i.e. the flag goes from
  // false to true), the Job controller will delete all active Pods associated
  // with this Job. Users must design their workload to gracefully handle this.
  // Suspending a Job will reset the StartTime field of the Job, effectively
  // resetting the ActiveDeadlineSeconds timer too. Defaults to false.
  optional bool suspend = 11 [(dev.f110.kubeproto.field) = { go_name: "Suspend", api_field_name: "suspend", inline: false }];
}

message JobStatus {
  // The latest available observations of an object's current state. When a Job
  // fails, one of the conditions will have type "Failed" and status true. When
  // a Job is suspended, one of the conditions will have type "Suspended" and
  // status true; when the Job is resumed, the status of this condition will
  // become false. When a Job is completed, one of the conditions will have
  // type "Complete" and status true.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
  repeated JobCondition conditions = 1 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
  // Represents time when the job controller started processing a job. When a
  // Job is created in the suspended state, this field is not set until the
  // first time it is resumed. This field is reset every time a Job is resumed
  // from suspension. It is represented in RFC3339 form and is in UTC.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time start_time = 2 [(dev.f110.kubeproto.field) = { go_name: "StartTime", api_field_name: "startTime", inline: false }];
  // Represents time when the job was completed. It is not guaranteed to
  // be set in happens-before order across separate operations.
  // It is represented in RFC3339 form and is in UTC.
  // The completion time is only set when the job finishes successfully.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completion_time = 3 [(dev.f110.kubeproto.field) = { go_name: "CompletionTime", api_field_name: "completionTime", inline: false }];
  // The number of pending and running pods.
  optional int32 active = 4 [(dev.f110.kubeproto.field) = { go_name: "Active", api_field_name: "active", inline: false }];
  // The number of pods which reached phase Succeeded.
  optional int32 succeeded = 5 [(dev.f110.kubeproto.field) = { go_name: "Succeeded", api_field_name: "succeeded", inline: false }];
  // The number of pods which reached phase Failed.
  optional int32 failed = 6 [(dev.f110.kubeproto.field) = { go_name: "Failed", api_field_name: "failed", inline: false }];
  // completedIndexes holds the completed indexes when .spec.completionMode =
  // "Indexed" in a text format. The indexes are represented as decimal integers
  // separated by commas. The numbers are listed in increasing order. Three or
  // more consecutive numbers are compressed and represented by the first and
  // last element of the series, separated by a hyphen.
  // For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
  // represented as "1,3-5,7".
  optional string completed_indexes = 7 [(dev.f110.kubeproto.field) = { go_name: "CompletedIndexes", api_field_name: "completedIndexes", inline: false }];
  // uncountedTerminatedPods holds the UIDs of Pods that have terminated but
  // the job controller hasn't yet accounted for in the status counters.
  // The job controller creates pods with a finalizer. When a pod terminates
  // (succeeded or failed), the controller does three steps to account for it
  // in the job status:
  // 1. Add the pod UID to the arrays in this field.
  // 2. Remove the pod finalizer.
  // 3. Remove the pod UID from the arrays while increasing the corresponding
  //     counter.
  // Old jobs might not be tracked using this field, in which case the field
  // remains null.
  optional UncountedTerminatedPods uncounted_terminated_pods = 8 [(dev.f110.kubeproto.field) = { go_name: "UncountedTerminatedPods", api_field_name: "uncountedTerminatedPods", inline: false }];
  // The number of pods which have a Ready condition.
  // This field is beta-level. The job controller populates the field when
  // the feature gate JobReadyPods is enabled (enabled by default).
  optional int32 ready = 9 [(dev.f110.kubeproto.field) = { go_name: "Ready", api_field_name: "ready", inline: false }];
}

message JobTemplateSpec {
  // Standard object's metadata of the jobs created from this template.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta object_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "ObjectMeta", api_field_name: "metadata", inline: false }];
  // Specification of the desired behavior of the job.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional JobSpec spec = 2 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
}

message PodFailurePolicy {
  // A list of pod failure policy rules. The rules are evaluated in order.
  // Once a rule matches a Pod failure, the remaining of the rules are ignored.
  // When no rule matches the Pod failure, the default handling applies - the
  // counter of pod failures is incremented and it is checked against
  // the backoffLimit. At most 20 elements are allowed.
  repeated PodFailurePolicyRule rules = 1 [(dev.f110.kubeproto.field) = { go_name: "Rules", api_field_name: "rules", inline: false }];
}

message PodFailurePolicyOnExitCodesRequirement {
  // Restricts the check for exit codes to the container with the
  // specified name. When null, the rule applies to all containers.
  // When specified, it should match one the container or initContainer
  // names in the pod template.
  optional string container_name = 1 [(dev.f110.kubeproto.field) = { go_name: "ContainerName", api_field_name: "containerName", inline: false }];
  // Represents the relationship between the container exit code(s) and the
  // specified values. Containers completed with success (exit code 0) are
  // excluded from the requirement check. Possible values are:
  // - In: the requirement is satisfied if at least one container exit code
  //   (might be multiple if there are multiple containers not restricted
  //   by the 'containerName' field) is in the set of specified values.
  // - NotIn: the requirement is satisfied if at least one container exit code
  //   (might be multiple if there are multiple containers not restricted
  //   by the 'containerName' field) is not in the set of specified values.
  // Additional values are considered to be added in the future. Clients should
  // react to an unknown operator by assuming the requirement is not satisfied.
  PodFailurePolicyOnExitCodesOperator operator = 2 [(dev.f110.kubeproto.field) = { go_name: "Operator", api_field_name: "operator", inline: false }];
  // Specifies the set of values. Each returned container exit code (might be
  // multiple in case of multiple containers) is checked against this set of
  // values with respect to the operator. The list of values must be ordered
  // and must not contain duplicates. Value '0' cannot be used for the In operator.
  // At least one element is required. At most 255 elements are allowed.
  repeated int32 values = 3 [(dev.f110.kubeproto.field) = { go_name: "Values", api_field_name: "values", inline: false }];
}

message PodFailurePolicyOnPodConditionsPattern {
  // Specifies the required Pod condition type. To match a pod condition
  // it is required that specified type equals the pod condition type.
  .k8s.io.api.core.v1.PodConditionType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Specifies the required Pod condition status. To match a pod condition
  // it is required that the specified status equals the pod condition status.
  // Defaults to True.
  .k8s.io.api.core.v1.ConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
}

message PodFailurePolicyRule {
  // Specifies the action taken on a pod failure when the requirements are satisfied.
  // Possible values are:
  // - FailJob: indicates that the pod's job is marked as Failed and all
  //   running pods are terminated.
  // - Ignore: indicates that the counter towards the .backoffLimit is not
  //   incremented and a replacement pod is created.
  // - Count: indicates that the pod is handled in the default way - the
  //   counter towards the .backoffLimit is incremented.
  // Additional values are considered to be added in the future. Clients should
  // react to an unknown action by skipping the rule.
  PodFailurePolicyAction action = 1 [(dev.f110.kubeproto.field) = { go_name: "Action", api_field_name: "action", inline: false }];
  // Represents the requirement on the container exit codes.
  optional PodFailurePolicyOnExitCodesRequirement on_exit_codes = 2 [(dev.f110.kubeproto.field) = { go_name: "OnExitCodes", api_field_name: "onExitCodes", inline: false }];
  // Represents the requirement on the pod conditions. The requirement is represented
  // as a list of pod condition patterns. The requirement is satisfied if at
  // least one pattern matches an actual pod condition. At most 20 elements are allowed.
  repeated PodFailurePolicyOnPodConditionsPattern on_pod_conditions = 3 [(dev.f110.kubeproto.field) = { go_name: "OnPodConditions", api_field_name: "onPodConditions", inline: false }];
}

message UncountedTerminatedPods {
  // succeeded holds UIDs of succeeded Pods.
  repeated string succeeded = 1 [(dev.f110.kubeproto.field) = { go_name: "Succeeded", api_field_name: "succeeded", inline: false }];
  // failed holds UIDs of failed Pods.
  repeated string failed = 2 [(dev.f110.kubeproto.field) = { go_name: "Failed", api_field_name: "failed", inline: false }];
}
