// Generated by: gen-go-to-protobuf
syntax = "proto3";
package k8s.io.api.batch.v1;
option  go_package              = "k8s.io/api/batch/v1";
option (dev.f110.kubeproto.k8s) = {
  domain: "apps",
  version: "v1",
};
option (dev.f110.kubeproto.kubeproto_go_package) = "go.f110.dev/kubeproto/apis/batchv1";

import "kube.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";

enum CompletionMode {
  COMPLETION_MODE_NON_INDEXED = 0;
  COMPLETION_MODE_INDEXED     = 1 [(dev.f110.kubeproto.value) = { value: "Indexed" }];
}

enum ConcurrencyPolicy {
  CONCURRENCY_POLICY_ALLOW   = 0 [(dev.f110.kubeproto.value) = { value: "Allow" }];
  CONCURRENCY_POLICY_FORBID  = 1 [(dev.f110.kubeproto.value) = { value: "Forbid" }];
  CONCURRENCY_POLICY_REPLACE = 2 [(dev.f110.kubeproto.value) = { value: "Replace" }];
}

enum JobConditionType {
  JOB_CONDITION_TYPE_SUSPENDED = 0 [(dev.f110.kubeproto.value) = { value: "Suspended" }];
  JOB_CONDITION_TYPE_COMPLETE  = 1 [(dev.f110.kubeproto.value) = { value: "Complete" }];
  JOB_CONDITION_TYPE_FAILED    = 2 [(dev.f110.kubeproto.value) = { value: "Failed" }];
}

message CronJob {
  // Specification of the desired behavior of a cron job, including the schedule.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional CronJobSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Current status of a cron job.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional CronJobStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message CronJobList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is the list of CronJobs.
  repeated CronJob items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message CronJobSpec {
  // The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
  string schedule = 1 [(dev.f110.kubeproto.field) = { go_name: "Schedule", api_field_name: "schedule", inline: false }];
  // The time zone for the given schedule, see https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
  // If not specified, this will rely on the time zone of the kube-controller-manager process.
  // ALPHA: This field is in alpha and must be enabled via the `CronJobTimeZone` feature gate.
  optional string time_zone = 2 [(dev.f110.kubeproto.field) = { go_name: "TimeZone", api_field_name: "timeZone", inline: false }];
  // Optional deadline in seconds for starting the job if it misses scheduled
  // time for any reason.  Missed jobs executions will be counted as failed ones.
  optional int64 starting_deadline_seconds = 3 [(dev.f110.kubeproto.field) = { go_name: "StartingDeadlineSeconds", api_field_name: "startingDeadlineSeconds", inline: false }];
  // Specifies how to treat concurrent executions of a Job.
  // Valid values are:
  // - "Allow" (default): allows CronJobs to run concurrently;
  // - "Forbid": forbids concurrent runs, skipping next run if previous run hasn't finished yet;
  // - "Replace": cancels currently running job and replaces it with a new one
  optional ConcurrencyPolicy concurrency_policy = 4 [(dev.f110.kubeproto.field) = { go_name: "ConcurrencyPolicy", api_field_name: "concurrencyPolicy", inline: false }];
  // This flag tells the controller to suspend subsequent executions, it does
  // not apply to already started executions.  Defaults to false.
  optional bool suspend = 5 [(dev.f110.kubeproto.field) = { go_name: "Suspend", api_field_name: "suspend", inline: false }];
  // Specifies the job that will be created when executing a CronJob.
  JobTemplateSpec job_template = 6 [(dev.f110.kubeproto.field) = { go_name: "JobTemplate", api_field_name: "jobTemplate", inline: false }];
  // The number of successful finished jobs to retain. Value must be non-negative integer.
  // Defaults to 3.
  optional int32 successful_jobs_history_limit = 7 [(dev.f110.kubeproto.field) = { go_name: "SuccessfulJobsHistoryLimit", api_field_name: "successfulJobsHistoryLimit", inline: false }];
  // The number of failed finished jobs to retain. Value must be non-negative integer.
  // Defaults to 1.
  optional int32 failed_jobs_history_limit = 8 [(dev.f110.kubeproto.field) = { go_name: "FailedJobsHistoryLimit", api_field_name: "failedJobsHistoryLimit", inline: false }];
}

message CronJobStatus {
  // A list of pointers to currently running jobs.
  repeated .k8s.io.api.core.v1.ObjectReference active = 1 [(dev.f110.kubeproto.field) = { go_name: "Active", api_field_name: "active", inline: false }];
  // Information when was the last time the job was successfully scheduled.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_schedule_time = 2 [(dev.f110.kubeproto.field) = { go_name: "LastScheduleTime", api_field_name: "lastScheduleTime", inline: false }];
  // Information when was the last time the job successfully completed.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_successful_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastSuccessfulTime", api_field_name: "lastSuccessfulTime", inline: false }];
}

message Job {
  // Specification of the desired behavior of a job.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional JobSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Current status of a job.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional JobStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message JobCondition {
  // Type of job condition, Complete or Failed.
  JobConditionType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Status of the condition, one of True, False, Unknown.
  .k8s.io.api.core.v1.ConditionStatus status = 2 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];
  // Last time the condition was checked.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_probe_time = 3 [(dev.f110.kubeproto.field) = { go_name: "LastProbeTime", api_field_name: "lastProbeTime", inline: false }];
  // Last time the condition transit from one status to another.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time last_transition_time = 4 [(dev.f110.kubeproto.field) = { go_name: "LastTransitionTime", api_field_name: "lastTransitionTime", inline: false }];
  // (brief) reason for the condition's last transition.
  optional string reason = 5 [(dev.f110.kubeproto.field) = { go_name: "Reason", api_field_name: "reason", inline: false }];
  // Human readable message indicating details about last transition.
  optional string message = 6 [(dev.f110.kubeproto.field) = { go_name: "Message", api_field_name: "message", inline: false }];
}

message JobList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // items is the list of Jobs.
  repeated Job items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message JobSpec {
  // Specifies the maximum desired number of pods the job should
  // run at any given time. The actual number of pods running in steady state will
  // be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism),
  // i.e. when the work left to do is less than max parallelism.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
  optional int32 parallelism = 1 [(dev.f110.kubeproto.field) = { go_name: "Parallelism", api_field_name: "parallelism", inline: false }];
  // Specifies the desired number of successfully finished pods the
  // job should be run with.  Setting to nil means that the success of any
  // pod signals the success of all pods, and allows parallelism to have any positive
  // value.  Setting to 1 means that parallelism is limited to 1 and the success of that
  // pod signals the success of the job.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
  optional int32 completions = 2 [(dev.f110.kubeproto.field) = { go_name: "Completions", api_field_name: "completions", inline: false }];
  // Specifies the duration in seconds relative to the startTime that the job
  // may be continuously active before the system tries to terminate it; value
  // must be positive integer. If a Job is suspended (at creation or through an
  // update), this timer will effectively be stopped and reset when the Job is
  // resumed again.
  optional int64 active_deadline_seconds = 3 [(dev.f110.kubeproto.field) = { go_name: "ActiveDeadlineSeconds", api_field_name: "activeDeadlineSeconds", inline: false }];
  // Specifies the number of retries before marking this job failed.
  // Defaults to 6
  optional int32 backoff_limit = 4 [(dev.f110.kubeproto.field) = { go_name: "BackoffLimit", api_field_name: "backoffLimit", inline: false }];
  // A label query over pods that should match the pod count.
  // Normally, the system sets this field for you.
  // More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 5 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
  // manualSelector controls generation of pod labels and pod selectors.
  // Leave `manualSelector` unset unless you are certain what you are doing.
  // When false or unset, the system pick labels unique to this job
  // and appends those labels to the pod template.  When true,
  // the user is responsible for picking unique labels and specifying
  // the selector.  Failure to pick a unique label may cause this
  // and other jobs to not function correctly.  However, You may see
  // `manualSelector=true` in jobs that were created with the old `extensions/v1beta1`
  // API.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/#specifying-your-own-pod-selector
  optional bool manual_selector = 6 [(dev.f110.kubeproto.field) = { go_name: "ManualSelector", api_field_name: "manualSelector", inline: false }];
  // Describes the pod that will be created when executing a job.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
  .k8s.io.api.core.v1.PodTemplateSpec template = 7 [(dev.f110.kubeproto.field) = { go_name: "Template", api_field_name: "template", inline: false }];
  // ttlSecondsAfterFinished limits the lifetime of a Job that has finished
  // execution (either Complete or Failed). If this field is set,
  // ttlSecondsAfterFinished after the Job finishes, it is eligible to be
  // automatically deleted. When the Job is being deleted, its lifecycle
  // guarantees (e.g. finalizers) will be honored. If this field is unset,
  // the Job won't be automatically deleted. If this field is set to zero,
  // the Job becomes eligible to be deleted immediately after it finishes.
  optional int32 t_tls_econds_after_finished = 8 [(dev.f110.kubeproto.field) = { go_name: "TTLSecondsAfterFinished", api_field_name: "ttlSecondsAfterFinished", inline: false }];
  // CompletionMode specifies how Pod completions are tracked. It can be
  // `NonIndexed` (default) or `Indexed`.
  // `NonIndexed` means that the Job is considered complete when there have
  // been .spec.completions successfully completed Pods. Each Pod completion is
  // homologous to each other.
  // `Indexed` means that the Pods of a
  // Job get an associated completion index from 0 to (.spec.completions - 1),
  // available in the annotation batch.kubernetes.io/job-completion-index.
  // The Job is considered complete when there is one successfully completed Pod
  // for each index.
  // When value is `Indexed`, .spec.completions must be specified and
  // `.spec.parallelism` must be less than or equal to 10^5.
  // In addition, The Pod name takes the form
  // `$(job-name)-$(index)-$(random-string)`,
  // the Pod hostname takes the form `$(job-name)-$(index)`.
  // More completion modes can be added in the future.
  // If the Job controller observes a mode that it doesn't recognize, which
  // is possible during upgrades due to version skew, the controller
  // skips updates for the Job.
  optional CompletionMode completion_mode = 9 [(dev.f110.kubeproto.field) = { go_name: "CompletionMode", api_field_name: "completionMode", inline: false }];
  // Suspend specifies whether the Job controller should create Pods or not. If
  // a Job is created with suspend set to true, no Pods are created by the Job
  // controller. If a Job is suspended after creation (i.e. the flag goes from
  // false to true), the Job controller will delete all active Pods associated
  // with this Job. Users must design their workload to gracefully handle this.
  // Suspending a Job will reset the StartTime field of the Job, effectively
  // resetting the ActiveDeadlineSeconds timer too. Defaults to false.
  optional bool suspend = 10 [(dev.f110.kubeproto.field) = { go_name: "Suspend", api_field_name: "suspend", inline: false }];
}

message JobStatus {
  // The latest available observations of an object's current state. When a Job
  // fails, one of the conditions will have type "Failed" and status true. When
  // a Job is suspended, one of the conditions will have type "Suspended" and
  // status true; when the Job is resumed, the status of this condition will
  // become false. When a Job is completed, one of the conditions will have
  // type "Complete" and status true.
  // More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
  repeated JobCondition conditions = 1 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
  // Represents time when the job controller started processing a job. When a
  // Job is created in the suspended state, this field is not set until the
  // first time it is resumed. This field is reset every time a Job is resumed
  // from suspension. It is represented in RFC3339 form and is in UTC.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time start_time = 2 [(dev.f110.kubeproto.field) = { go_name: "StartTime", api_field_name: "startTime", inline: false }];
  // Represents time when the job was completed. It is not guaranteed to
  // be set in happens-before order across separate operations.
  // It is represented in RFC3339 form and is in UTC.
  // The completion time is only set when the job finishes successfully.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time completion_time = 3 [(dev.f110.kubeproto.field) = { go_name: "CompletionTime", api_field_name: "completionTime", inline: false }];
  // The number of pending and running pods.
  optional int32 active = 4 [(dev.f110.kubeproto.field) = { go_name: "Active", api_field_name: "active", inline: false }];
  // The number of pods which reached phase Succeeded.
  optional int32 succeeded = 5 [(dev.f110.kubeproto.field) = { go_name: "Succeeded", api_field_name: "succeeded", inline: false }];
  // The number of pods which reached phase Failed.
  optional int32 failed = 6 [(dev.f110.kubeproto.field) = { go_name: "Failed", api_field_name: "failed", inline: false }];
  // CompletedIndexes holds the completed indexes when .spec.completionMode =
  // "Indexed" in a text format. The indexes are represented as decimal integers
  // separated by commas. The numbers are listed in increasing order. Three or
  // more consecutive numbers are compressed and represented by the first and
  // last element of the series, separated by a hyphen.
  // For example, if the completed indexes are 1, 3, 4, 5 and 7, they are
  // represented as "1,3-5,7".
  optional string completed_indexes = 7 [(dev.f110.kubeproto.field) = { go_name: "CompletedIndexes", api_field_name: "completedIndexes", inline: false }];
  // UncountedTerminatedPods holds the UIDs of Pods that have terminated but
  // the job controller hasn't yet accounted for in the status counters.
  // The job controller creates pods with a finalizer. When a pod terminates
  // (succeeded or failed), the controller does three steps to account for it
  // in the job status:
  // (1) Add the pod UID to the arrays in this field.
  // (2) Remove the pod finalizer.
  // (3) Remove the pod UID from the arrays while increasing the corresponding
  //     counter.
  // This field is beta-level. The job controller only makes use of this field
  // when the feature gate JobTrackingWithFinalizers is enabled (enabled
  // by default).
  // Old jobs might not be tracked using this field, in which case the field
  // remains null.
  optional UncountedTerminatedPods uncounted_terminated_pods = 8 [(dev.f110.kubeproto.field) = { go_name: "UncountedTerminatedPods", api_field_name: "uncountedTerminatedPods", inline: false }];
  // The number of pods which have a Ready condition.
  // This field is beta-level. The job controller populates the field when
  // the feature gate JobReadyPods is enabled (enabled by default).
  optional int32 ready = 9 [(dev.f110.kubeproto.field) = { go_name: "Ready", api_field_name: "ready", inline: false }];
}

message JobTemplateSpec {
  // Standard object's metadata of the jobs created from this template.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta object_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "ObjectMeta", api_field_name: "metadata", inline: false }];
  // Specification of the desired behavior of the job.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
  optional JobSpec spec = 2 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
}

message UncountedTerminatedPods {
  // Succeeded holds UIDs of succeeded Pods.
  repeated string succeeded = 1 [(dev.f110.kubeproto.field) = { go_name: "Succeeded", api_field_name: "succeeded", inline: false }];
  // Failed holds UIDs of failed Pods.
  repeated string failed = 2 [(dev.f110.kubeproto.field) = { go_name: "Failed", api_field_name: "failed", inline: false }];
}
