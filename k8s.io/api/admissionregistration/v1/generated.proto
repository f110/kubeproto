// Generated by: gen-go-to-protobuf
syntax = "proto3";
package k8s.io.api.admissionregistration.v1;
option  go_package              = "k8s.io/api/admissionregistration/v1";
option (dev.f110.kubeproto.k8s) = {
  domain: "admissionregistration.k8s.io",
  version: "v1",
};
option (dev.f110.kubeproto.kubeproto_go_package) = "go.f110.dev/kubeproto/go/apis/admissionregistrationv1";

import "kube.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";

enum FailurePolicyType {
  FAILURE_POLICY_TYPE_IGNORE = 0 [(dev.f110.kubeproto.value) = { value: "Ignore" }];
  FAILURE_POLICY_TYPE_FAIL   = 1 [(dev.f110.kubeproto.value) = { value: "Fail" }];
}

enum MatchPolicyType {
  MATCH_POLICY_TYPE_EXACT      = 0 [(dev.f110.kubeproto.value) = { value: "Exact" }];
  MATCH_POLICY_TYPE_EQUIVALENT = 1 [(dev.f110.kubeproto.value) = { value: "Equivalent" }];
}

enum OperationType {
  OPERATION_TYPE_ASTERISK = 0 [(dev.f110.kubeproto.value) = { value: "*" }];
  OPERATION_TYPE_CREATE   = 1;
  OPERATION_TYPE_UPDATE   = 2;
  OPERATION_TYPE_DELETE   = 3;
  OPERATION_TYPE_CONNECT  = 4;
}

enum ReinvocationPolicyType {
  REINVOCATION_POLICY_TYPE_NEVER     = 0 [(dev.f110.kubeproto.value) = { value: "Never" }];
  REINVOCATION_POLICY_TYPE_IF_NEEDED = 1;
}

enum ScopeType {
  SCOPE_TYPE_CLUSTER    = 0 [(dev.f110.kubeproto.value) = { value: "Cluster" }];
  SCOPE_TYPE_NAMESPACED = 1 [(dev.f110.kubeproto.value) = { value: "Namespaced" }];
  SCOPE_TYPE_ASTERISK   = 2 [(dev.f110.kubeproto.value) = { value: "*" }];
}

enum SideEffectClass {
  SIDE_EFFECT_CLASS_UNKNOWN         = 0 [(dev.f110.kubeproto.value) = { value: "Unknown" }];
  SIDE_EFFECT_CLASS_NONE            = 1 [(dev.f110.kubeproto.value) = { value: "None" }];
  SIDE_EFFECT_CLASS_SOME            = 2 [(dev.f110.kubeproto.value) = { value: "Some" }];
  SIDE_EFFECT_CLASS_NONE_ON_DRY_RUN = 3;
}

message MatchCondition {
  // Name is an identifier for this match condition, used for strategic merging of MatchConditions,
  // as well as providing an identifier for logging purposes. A good name should be descriptive of
  // the associated expression.
  // Name must be a qualified name consisting of alphanumeric characters, '-', '_' or '.', and
  // must start and end with an alphanumeric character (e.g. 'MyName',  or 'my.name',  or
  // '123-abc', regex used for validation is '([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9]') with an
  // optional DNS subdomain prefix and '/' (e.g. 'example.com/MyName')
  // Required.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Expression represents the expression which will be evaluated by CEL. Must evaluate to bool.
  // CEL expressions have access to the contents of the AdmissionRequest and Authorizer, organized into CEL variables:
  // 'object' - The object from the incoming request. The value is null for DELETE requests.
  // 'oldObject' - The existing object. The value is null for CREATE requests.
  // 'request' - Attributes of the admission request(/pkg/apis/admission/types.go#AdmissionRequest).
  // 'authorizer' - A CEL Authorizer. May be used to perform authorization checks for the principal (user or service account) of the request.
  //   See https://pkg.go.dev/k8s.io/apiserver/pkg/cel/library#Authz
  // 'authorizer.requestResource' - A CEL ResourceCheck constructed from the 'authorizer' and configured with the
  //   request resource.
  // Documentation on CEL: https://kubernetes.io/docs/reference/using-api/cel/
  // Required.
  string expression = 2 [(dev.f110.kubeproto.field) = { go_name: "Expression", api_field_name: "expression", inline: false }];
}

message MutatingWebhook {
  // The name of the admission webhook.
  // Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
  // "imagepolicy" is the name of the webhook, and kubernetes.io is the name
  // of the organization.
  // Required.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // ClientConfig defines how to communicate with the hook.
  // Required
  WebhookClientConfig client_config = 2 [(dev.f110.kubeproto.field) = { go_name: "ClientConfig", api_field_name: "clientConfig", inline: false }];
  // Rules describes what operations on what resources/subresources the webhook cares about.
  // The webhook cares about an operation if it matches _any_ Rule.
  // However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
  // from putting the cluster in a state which cannot be recovered from without completely
  // disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
  // on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
  repeated RuleWithOperations rules = 3 [(dev.f110.kubeproto.field) = { go_name: "Rules", api_field_name: "rules", inline: false }];
  // FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
  // allowed values are Ignore or Fail. Defaults to Fail.
  optional FailurePolicyType failure_policy = 4 [(dev.f110.kubeproto.field) = { go_name: "FailurePolicy", api_field_name: "failurePolicy", inline: false }];
  // matchPolicy defines how the "rules" list is used to match incoming requests.
  // Allowed values are "Exact" or "Equivalent".
  // - Exact: match a request only if it exactly matches a specified rule.
  // For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
  // but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
  // a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
  // - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
  // For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
  // and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
  // a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
  // Defaults to "Equivalent"
  optional MatchPolicyType match_policy = 5 [(dev.f110.kubeproto.field) = { go_name: "MatchPolicy", api_field_name: "matchPolicy", inline: false }];
  // NamespaceSelector decides whether to run the webhook on an object based
  // on whether the namespace for that object matches the selector. If the
  // object itself is a namespace, the matching is performed on
  // object.metadata.labels. If the object is another cluster scoped resource,
  // it never skips the webhook.
  // For example, to run the webhook on any objects whose namespace is not
  // associated with "runlevel" of "0" or "1";  you will set the selector as
  // follows:
  // "namespaceSelector": {
  //   "matchExpressions": [
  //     {
  //       "key": "runlevel",
  //       "operator": "NotIn",
  //       "values": [
  //         "0",
  //         "1"
  //       ]
  //     }
  //   ]
  // }
  // If instead you want to only run the webhook on any objects whose
  // namespace is associated with the "environment" of "prod" or "staging";
  // you will set the selector as follows:
  // "namespaceSelector": {
  //   "matchExpressions": [
  //     {
  //       "key": "environment",
  //       "operator": "In",
  //       "values": [
  //         "prod",
  //         "staging"
  //       ]
  //     }
  //   ]
  // }
  // See
  // https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  // for more examples of label selectors.
  // Default to the empty LabelSelector, which matches everything.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespace_selector = 6 [(dev.f110.kubeproto.field) = { go_name: "NamespaceSelector", api_field_name: "namespaceSelector", inline: false }];
  // ObjectSelector decides whether to run the webhook based on if the
  // object has matching labels. objectSelector is evaluated against both
  // the oldObject and newObject that would be sent to the webhook, and
  // is considered to match if either object matches the selector. A null
  // object (oldObject in the case of create, or newObject in the case of
  // delete) or an object that cannot have labels (like a
  // DeploymentRollback or a PodProxyOptions object) is not considered to
  // match.
  // Use the object selector only if the webhook is opt-in, because end
  // users may skip the admission webhook by setting the labels.
  // Default to the empty LabelSelector, which matches everything.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector object_selector = 7 [(dev.f110.kubeproto.field) = { go_name: "ObjectSelector", api_field_name: "objectSelector", inline: false }];
  // SideEffects states whether this webhook has side effects.
  // Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
  // Webhooks with side effects MUST implement a reconciliation system, since a request may be
  // rejected by a future step in the admission chain and the side effects therefore need to be undone.
  // Requests with the dryRun attribute will be auto-rejected if they match a webhook with
  // sideEffects == Unknown or Some.
  optional SideEffectClass side_effects = 8 [(dev.f110.kubeproto.field) = { go_name: "SideEffects", api_field_name: "sideEffects", inline: false }];
  // TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
  // the webhook call will be ignored or the API call will fail based on the
  // failure policy.
  // The timeout value must be between 1 and 30 seconds.
  // Default to 10 seconds.
  optional int32 timeout_seconds = 9 [(dev.f110.kubeproto.field) = { go_name: "TimeoutSeconds", api_field_name: "timeoutSeconds", inline: false }];
  // AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
  // versions the Webhook expects. API server will try to use first version in
  // the list which it supports. If none of the versions specified in this list
  // supported by API server, validation will fail for this object.
  // If a persisted webhook configuration specifies allowed versions and does not
  // include any versions known to the API Server, calls to the webhook will fail
  // and be subject to the failure policy.
  repeated string admission_review_versions = 10 [(dev.f110.kubeproto.field) = { go_name: "AdmissionReviewVersions", api_field_name: "admissionReviewVersions", inline: false }];
  // reinvocationPolicy indicates whether this webhook should be called multiple times as part of a single admission evaluation.
  // Allowed values are "Never" and "IfNeeded".
  // Never: the webhook will not be called more than once in a single admission evaluation.
  // IfNeeded: the webhook will be called at least one additional time as part of the admission evaluation
  // if the object being admitted is modified by other admission plugins after the initial webhook call.
  // Webhooks that specify this option *must* be idempotent, able to process objects they previously admitted.
  // Note:
  // * the number of additional invocations is not guaranteed to be exactly one.
  // * if additional invocations result in further modifications to the object, webhooks are not guaranteed to be invoked again.
  // * webhooks that use this option may be reordered to minimize the number of additional invocations.
  // * to validate an object after all mutations are guaranteed complete, use a validating admission webhook instead.
  // Defaults to "Never".
  optional ReinvocationPolicyType reinvocation_policy = 11 [(dev.f110.kubeproto.field) = { go_name: "ReinvocationPolicy", api_field_name: "reinvocationPolicy", inline: false }];
  // MatchConditions is a list of conditions that must be met for a request to be sent to this
  // webhook. Match conditions filter requests that have already been matched by the rules,
  // namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
  // There are a maximum of 64 match conditions allowed.
  // The exact matching logic is (in order):
  //   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
  //   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
  //   3. If any matchCondition evaluates to an error (but none are FALSE):
  //      - If failurePolicy=Fail, reject the request
  //      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
  // This is an alpha feature and managed by the AdmissionWebhookMatchConditions feature gate.
  repeated MatchCondition match_conditions = 12 [(dev.f110.kubeproto.field) = { go_name: "MatchConditions", api_field_name: "matchConditions", inline: false }];
}

message MutatingWebhookConfiguration {
  // Webhooks is a list of webhooks and the affected resources and operations.
  repeated MutatingWebhook webhooks = 3 [(dev.f110.kubeproto.field) = { go_name: "Webhooks", api_field_name: "webhooks", inline: false }];

  option (dev.f110.kubeproto.kind) = {
    scope: SCOPE_CLUSTER
  };
}

message MutatingWebhookConfigurationList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of MutatingWebhookConfiguration.
  repeated MutatingWebhookConfiguration items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message Rule {
  // APIGroups is the API groups the resources belong to. '*' is all groups.
  // If '*' is present, the length of the slice must be one.
  // Required.
  repeated string api_groups = 1 [(dev.f110.kubeproto.field) = { go_name: "APIGroups", api_field_name: "apiGroups", inline: false }];
  // APIVersions is the API versions the resources belong to. '*' is all versions.
  // If '*' is present, the length of the slice must be one.
  // Required.
  repeated string api_versions = 2 [(dev.f110.kubeproto.field) = { go_name: "APIVersions", api_field_name: "apiVersions", inline: false }];
  // Resources is a list of resources this rule applies to.
  // For example:
  // 'pods' means pods.
  // 'pods/log' means the log subresource of pods.
  // '*' means all resources, but not subresources.
  // 'pods/*' means all subresources of pods.
  // '*/scale' means all scale subresources.
  // '*/*' means all resources and their subresources.
  // If wildcard is present, the validation rule will ensure resources do not
  // overlap with each other.
  // Depending on the enclosing object, subresources might not be allowed.
  // Required.
  repeated string resources = 3 [(dev.f110.kubeproto.field) = { go_name: "Resources", api_field_name: "resources", inline: false }];
  // scope specifies the scope of this rule.
  // Valid values are "Cluster", "Namespaced", and "*"
  // "Cluster" means that only cluster-scoped resources will match this rule.
  // Namespace API objects are cluster-scoped.
  // "Namespaced" means that only namespaced resources will match this rule.
  // "*" means that there are no scope restrictions.
  // Subresources match the scope of their parent resource.
  // Default is "*".
  optional ScopeType scope = 4 [(dev.f110.kubeproto.field) = { go_name: "Scope", api_field_name: "scope", inline: false }];
}

message RuleWithOperations {
  // Operations is the operations the admission hook cares about - CREATE, UPDATE, DELETE, CONNECT or *
  // for all of those operations and any future admission operations that are added.
  // If '*' is present, the length of the slice must be one.
  // Required.
  repeated OperationType operations = 1 [(dev.f110.kubeproto.field) = { go_name: "Operations", api_field_name: "operations", inline: false }];
  // Rule is embedded, it describes other criteria of the rule, like
  // APIGroups, APIVersions, Resources, etc.
  Rule rule = 2 [(dev.f110.kubeproto.field) = { go_name: "Rule", inline: true }];
}

message ServiceReference {
  // `namespace` is the namespace of the service.
  // Required
  string namespace = 1 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
  // `name` is the name of the service.
  // Required
  string name = 2 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // `path` is an optional URL path which will be sent in any request to
  // this service.
  optional string path = 3 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // If specified, the port on the service that hosting webhook.
  // Default to 443 for backward compatibility.
  // `port` should be a valid port number (1-65535, inclusive).
  optional int32 port = 4 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
}

message ValidatingWebhook {
  // The name of the admission webhook.
  // Name should be fully qualified, e.g., imagepolicy.kubernetes.io, where
  // "imagepolicy" is the name of the webhook, and kubernetes.io is the name
  // of the organization.
  // Required.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // ClientConfig defines how to communicate with the hook.
  // Required
  WebhookClientConfig client_config = 2 [(dev.f110.kubeproto.field) = { go_name: "ClientConfig", api_field_name: "clientConfig", inline: false }];
  // Rules describes what operations on what resources/subresources the webhook cares about.
  // The webhook cares about an operation if it matches _any_ Rule.
  // However, in order to prevent ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks
  // from putting the cluster in a state which cannot be recovered from without completely
  // disabling the plugin, ValidatingAdmissionWebhooks and MutatingAdmissionWebhooks are never called
  // on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration objects.
  repeated RuleWithOperations rules = 3 [(dev.f110.kubeproto.field) = { go_name: "Rules", api_field_name: "rules", inline: false }];
  // FailurePolicy defines how unrecognized errors from the admission endpoint are handled -
  // allowed values are Ignore or Fail. Defaults to Fail.
  optional FailurePolicyType failure_policy = 4 [(dev.f110.kubeproto.field) = { go_name: "FailurePolicy", api_field_name: "failurePolicy", inline: false }];
  // matchPolicy defines how the "rules" list is used to match incoming requests.
  // Allowed values are "Exact" or "Equivalent".
  // - Exact: match a request only if it exactly matches a specified rule.
  // For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
  // but "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
  // a request to apps/v1beta1 or extensions/v1beta1 would not be sent to the webhook.
  // - Equivalent: match a request if modifies a resource listed in rules, even via another API group or version.
  // For example, if deployments can be modified via apps/v1, apps/v1beta1, and extensions/v1beta1,
  // and "rules" only included `apiGroups:["apps"], apiVersions:["v1"], resources: ["deployments"]`,
  // a request to apps/v1beta1 or extensions/v1beta1 would be converted to apps/v1 and sent to the webhook.
  // Defaults to "Equivalent"
  optional MatchPolicyType match_policy = 5 [(dev.f110.kubeproto.field) = { go_name: "MatchPolicy", api_field_name: "matchPolicy", inline: false }];
  // NamespaceSelector decides whether to run the webhook on an object based
  // on whether the namespace for that object matches the selector. If the
  // object itself is a namespace, the matching is performed on
  // object.metadata.labels. If the object is another cluster scoped resource,
  // it never skips the webhook.
  // For example, to run the webhook on any objects whose namespace is not
  // associated with "runlevel" of "0" or "1";  you will set the selector as
  // follows:
  // "namespaceSelector": {
  //   "matchExpressions": [
  //     {
  //       "key": "runlevel",
  //       "operator": "NotIn",
  //       "values": [
  //         "0",
  //         "1"
  //       ]
  //     }
  //   ]
  // }
  // If instead you want to only run the webhook on any objects whose
  // namespace is associated with the "environment" of "prod" or "staging";
  // you will set the selector as follows:
  // "namespaceSelector": {
  //   "matchExpressions": [
  //     {
  //       "key": "environment",
  //       "operator": "In",
  //       "values": [
  //         "prod",
  //         "staging"
  //       ]
  //     }
  //   ]
  // }
  // See
  // https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
  // for more examples of label selectors.
  // Default to the empty LabelSelector, which matches everything.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespace_selector = 6 [(dev.f110.kubeproto.field) = { go_name: "NamespaceSelector", api_field_name: "namespaceSelector", inline: false }];
  // ObjectSelector decides whether to run the webhook based on if the
  // object has matching labels. objectSelector is evaluated against both
  // the oldObject and newObject that would be sent to the webhook, and
  // is considered to match if either object matches the selector. A null
  // object (oldObject in the case of create, or newObject in the case of
  // delete) or an object that cannot have labels (like a
  // DeploymentRollback or a PodProxyOptions object) is not considered to
  // match.
  // Use the object selector only if the webhook is opt-in, because end
  // users may skip the admission webhook by setting the labels.
  // Default to the empty LabelSelector, which matches everything.
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector object_selector = 7 [(dev.f110.kubeproto.field) = { go_name: "ObjectSelector", api_field_name: "objectSelector", inline: false }];
  // SideEffects states whether this webhook has side effects.
  // Acceptable values are: None, NoneOnDryRun (webhooks created via v1beta1 may also specify Some or Unknown).
  // Webhooks with side effects MUST implement a reconciliation system, since a request may be
  // rejected by a future step in the admission chain and the side effects therefore need to be undone.
  // Requests with the dryRun attribute will be auto-rejected if they match a webhook with
  // sideEffects == Unknown or Some.
  optional SideEffectClass side_effects = 8 [(dev.f110.kubeproto.field) = { go_name: "SideEffects", api_field_name: "sideEffects", inline: false }];
  // TimeoutSeconds specifies the timeout for this webhook. After the timeout passes,
  // the webhook call will be ignored or the API call will fail based on the
  // failure policy.
  // The timeout value must be between 1 and 30 seconds.
  // Default to 10 seconds.
  optional int32 timeout_seconds = 9 [(dev.f110.kubeproto.field) = { go_name: "TimeoutSeconds", api_field_name: "timeoutSeconds", inline: false }];
  // AdmissionReviewVersions is an ordered list of preferred `AdmissionReview`
  // versions the Webhook expects. API server will try to use first version in
  // the list which it supports. If none of the versions specified in this list
  // supported by API server, validation will fail for this object.
  // If a persisted webhook configuration specifies allowed versions and does not
  // include any versions known to the API Server, calls to the webhook will fail
  // and be subject to the failure policy.
  repeated string admission_review_versions = 10 [(dev.f110.kubeproto.field) = { go_name: "AdmissionReviewVersions", api_field_name: "admissionReviewVersions", inline: false }];
  // MatchConditions is a list of conditions that must be met for a request to be sent to this
  // webhook. Match conditions filter requests that have already been matched by the rules,
  // namespaceSelector, and objectSelector. An empty list of matchConditions matches all requests.
  // There are a maximum of 64 match conditions allowed.
  // The exact matching logic is (in order):
  //   1. If ANY matchCondition evaluates to FALSE, the webhook is skipped.
  //   2. If ALL matchConditions evaluate to TRUE, the webhook is called.
  //   3. If any matchCondition evaluates to an error (but none are FALSE):
  //      - If failurePolicy=Fail, reject the request
  //      - If failurePolicy=Ignore, the error is ignored and the webhook is skipped
  // This is an alpha feature and managed by the AdmissionWebhookMatchConditions feature gate.
  repeated MatchCondition match_conditions = 11 [(dev.f110.kubeproto.field) = { go_name: "MatchConditions", api_field_name: "matchConditions", inline: false }];
}

message ValidatingWebhookConfiguration {
  // Webhooks is a list of webhooks and the affected resources and operations.
  repeated ValidatingWebhook webhooks = 3 [(dev.f110.kubeproto.field) = { go_name: "Webhooks", api_field_name: "webhooks", inline: false }];

  option (dev.f110.kubeproto.kind) = {
    scope: SCOPE_CLUSTER
  };
}

message ValidatingWebhookConfigurationList {
  .k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  // Standard list metadata.
  // More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
  optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  // List of ValidatingWebhookConfiguration.
  repeated ValidatingWebhookConfiguration items = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message WebhookClientConfig {
  // `url` gives the location of the webhook, in standard URL form
  // (`scheme://host:port/path`). Exactly one of `url` or `service`
  // must be specified.
  // The `host` should not refer to a service running in the cluster; use
  // the `service` field instead. The host might be resolved via external
  // DNS in some apiservers (e.g., `kube-apiserver` cannot resolve
  // in-cluster DNS as that would be a layering violation). `host` may
  // also be an IP address.
  // Please note that using `localhost` or `127.0.0.1` as a `host` is
  // risky unless you take great care to run this webhook on all hosts
  // which run an apiserver which might need to make calls to this
  // webhook. Such installs are likely to be non-portable, i.e., not easy
  // to turn up in a new cluster.
  // The scheme must be "https"; the URL must begin with "https://".
  // A path is optional, and if present may be any string permissible in
  // a URL. You may use the path to pass an arbitrary string to the
  // webhook, for example, a cluster identifier.
  // Attempting to use a user or basic auth e.g. "user:password@" is not
  // allowed. Fragments ("#...") and query parameters ("?...") are not
  // allowed, either.
  optional string url = 1 [(dev.f110.kubeproto.field) = { go_name: "URL", api_field_name: "url", inline: false }];
  // `service` is a reference to the service for this webhook. Either
  // `service` or `url` must be specified.
  // If the webhook is running within the cluster, then you should use `service`.
  optional ServiceReference service = 2 [(dev.f110.kubeproto.field) = { go_name: "Service", api_field_name: "service", inline: false }];
  // `caBundle` is a PEM encoded CA bundle which will be used to validate the webhook's server certificate.
  // If unspecified, system trust roots on the apiserver are used.
  optional bytes c_a_bundle = 3 [(dev.f110.kubeproto.field) = { go_name: "CABundle", api_field_name: "caBundle", inline: false }];
}
