// Generated by: gen-go-to-protobuf
syntax = "proto3";
package sigs.k8s.io.gatway_api.apis.v1alpha2;
option  go_package              = "sigs.k8s.io/gateway-api/apis/v1alpha2";
option (dev.f110.kubeproto.k8s) = {
  domain: "gateway",
  sub_group: "networking.k8s.io",
  version: "v1alpha2",
};

import "kube.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";

enum AddressType {
  ADDRESS_TYPE_IP_ADDRESS    = 0 [(dev.f110.kubeproto.value) = { value: "IPAddress" }];
  ADDRESS_TYPE_HOSTNAME      = 1;
  ADDRESS_TYPE_NAMED_ADDRESS = 2;
}

enum FromNamespaces {
  FROM_NAMESPACES_ALL      = 0;
  FROM_NAMESPACES_SELECTOR = 1;
  FROM_NAMESPACES_SAME     = 2;
}

enum GatewayClassConditionReason {
  GATEWAY_CLASS_CONDITION_REASON_ACCEPTED           = 0;
  GATEWAY_CLASS_CONDITION_REASON_INVALID_PARAMETERS = 1;
  GATEWAY_CLASS_CONDITION_REASON_WAITING            = 2;
}

enum GatewayClassConditionType {
  GATEWAY_CLASS_CONDITION_TYPE_ACCEPTED = 0;
}

enum GatewayConditionReason {
  GATEWAY_CONDITION_REASON_SCHEDULED            = 0;
  GATEWAY_CONDITION_REASON_NOT_RECONCILED       = 1;
  GATEWAY_CONDITION_REASON_NO_RESOURCES         = 2;
  GATEWAY_CONDITION_REASON_READY                = 3;
  GATEWAY_CONDITION_REASON_LISTENERS_NOT_VALID  = 4;
  GATEWAY_CONDITION_REASON_LISTENERS_NOT_READY  = 5;
  GATEWAY_CONDITION_REASON_ADDRESS_NOT_ASSIGNED = 6;
}

enum GatewayConditionType {
  GATEWAY_CONDITION_TYPE_SCHEDULED = 0;
  GATEWAY_CONDITION_TYPE_READY     = 1;
}

enum HTTPMethod {
  HTTP_METHOD_G_E_T         = 0;
  HTTP_METHOD_H_E_A_D       = 1;
  HTTP_METHOD_P_OS_T        = 2 [(dev.f110.kubeproto.value) = { value: "POST" }];
  HTTP_METHOD_P_U_T         = 3;
  HTTP_METHOD_D_E_L_E_T_E   = 4;
  HTTP_METHOD_C_O_N_N_E_C_T = 5;
  HTTP_METHOD_O_P_T_IO_N_S  = 6 [(dev.f110.kubeproto.value) = { value: "OPTIONS" }];
  HTTP_METHOD_T_R_A_C_E     = 7;
  HTTP_METHOD_P_A_T_C_H     = 8;
}

enum HTTPPathModifierType {
  HTTP_PATH_MODIFIER_TYPE_REPLACE_FULL_PATH    = 0;
  HTTP_PATH_MODIFIER_TYPE_REPLACE_PREFIX_MATCH = 1;
}

enum HTTPRouteFilterType {
  HTTP_ROUTE_FILTER_TYPE_REQUEST_HEADER_MODIFIER = 0;
  HTTP_ROUTE_FILTER_TYPE_REQUEST_REDIRECT        = 1;
  HTTP_ROUTE_FILTER_TYPE_URL_REWRITE             = 2 [(dev.f110.kubeproto.value) = { value: "URLRewrite" }];
  HTTP_ROUTE_FILTER_TYPE_REQUEST_MIRROR          = 3;
  HTTP_ROUTE_FILTER_TYPE_EXTENSION_REF           = 4;
}

enum HeaderMatchType {
  HEADER_MATCH_TYPE_EXACT              = 0;
  HEADER_MATCH_TYPE_REGULAR_EXPRESSION = 1;
}

enum ListenerConditionReason {
  LISTENER_CONDITION_REASON_HOSTNAME_CONFLICT       = 0;
  LISTENER_CONDITION_REASON_PROTOCOL_CONFLICT       = 1;
  LISTENER_CONDITION_REASON_NO_CONFLICTS            = 2;
  LISTENER_CONDITION_REASON_PORT_UNAVAILABLE        = 3;
  LISTENER_CONDITION_REASON_UNSUPPORTED_PROTOCOL    = 4;
  LISTENER_CONDITION_REASON_UNSUPPORTED_ADDRESS     = 5;
  LISTENER_CONDITION_REASON_ATTACHED                = 6;
  LISTENER_CONDITION_REASON_RESOLVED_REFS           = 7;
  LISTENER_CONDITION_REASON_INVALID_CERTIFICATE_REF = 8;
  LISTENER_CONDITION_REASON_INVALID_ROUTE_KINDS     = 9;
  LISTENER_CONDITION_REASON_REF_NOT_PERMITTED       = 10;
  LISTENER_CONDITION_REASON_READY                   = 11;
  LISTENER_CONDITION_REASON_INVALID                 = 12;
  LISTENER_CONDITION_REASON_PENDING                 = 13;
}

enum ListenerConditionType {
  LISTENER_CONDITION_TYPE_CONFLICTED    = 0;
  LISTENER_CONDITION_TYPE_DETACHED      = 1;
  LISTENER_CONDITION_TYPE_RESOLVED_REFS = 2;
  LISTENER_CONDITION_TYPE_READY         = 3;
}

enum PathMatchType {
  PATH_MATCH_TYPE_EXACT              = 0;
  PATH_MATCH_TYPE_REGULAR_EXPRESSION = 1;
}

enum ProtocolType {
  PROTOCOL_TYPE_HTTP  = 0 [(dev.f110.kubeproto.value) = { value: "HTTP" }];
  PROTOCOL_TYPE_HTTPS = 1 [(dev.f110.kubeproto.value) = { value: "HTTPS" }];
  PROTOCOL_TYPE_TLS   = 2 [(dev.f110.kubeproto.value) = { value: "TLS" }];
  PROTOCOL_TYPE_TCP   = 3 [(dev.f110.kubeproto.value) = { value: "TCP" }];
  PROTOCOL_TYPE_UDP   = 4 [(dev.f110.kubeproto.value) = { value: "UDP" }];
}

enum QueryParamMatchType {
  QUERY_PARAM_MATCH_TYPE_EXACT              = 0;
  QUERY_PARAM_MATCH_TYPE_REGULAR_EXPRESSION = 1;
}

enum RouteConditionReason {
  ROUTE_CONDITION_REASON_ACCEPTED                      = 0;
  ROUTE_CONDITION_REASON_NOT_ALLOWED_BY_LISTENERS      = 1;
  ROUTE_CONDITION_REASON_NO_MATCHING_LISTENER_HOSTNAME = 2;
  ROUTE_CONDITION_REASON_UNSUPPORTED_VALUE             = 3;
  ROUTE_CONDITION_REASON_RESOLVED_REFS                 = 4;
  ROUTE_CONDITION_REASON_REF_NOT_PERMITTED             = 5;
  ROUTE_CONDITION_REASON_INVALID_KIND                  = 6;
  ROUTE_CONDITION_REASON_BACKEND_NOT_FOUND             = 7;
}

enum RouteConditionType {
  ROUTE_CONDITION_TYPE_ACCEPTED      = 0;
  ROUTE_CONDITION_TYPE_RESOLVED_REFS = 1;
}

enum TLSModeType {
  TLS_MODE_TYPE_TERMINATE   = 0;
  TLS_MODE_TYPE_PASSTHROUGH = 1;
}

message AllowedRoutes {
  // Namespaces indicates namespaces from which Routes may be attached to this
  // Listener. This is restricted to the namespace of this Gateway by default.
  // Support: Core
  optional RouteNamespaces namespaces = 1 [(dev.f110.kubeproto.field) = { go_name: "Namespaces", api_field_name: "namespaces", inline: false }];
  // Kinds specifies the groups and kinds of Routes that are allowed to bind
  // to this Gateway Listener. When unspecified or empty, the kinds of Routes
  // selected are determined using the Listener protocol.
  // A RouteGroupKind MUST correspond to kinds of Routes that are compatible
  // with the application protocol specified in the Listener's Protocol field.
  // If an implementation does not support or recognize this resource type, it
  // MUST set the "ResolvedRefs" condition to False for this Listener with the
  // "InvalidRouteKinds" reason.
  // Support: Core
  repeated RouteGroupKind kinds = 2 [(dev.f110.kubeproto.field) = { go_name: "Kinds", api_field_name: "kinds", inline: false }];
}

message BackendObjectReference {
  // Group is the group of the referent. For example, "networking.k8s.io".
  // When unspecified (empty string), core API group is inferred.
  string group = 1 [(dev.f110.kubeproto.field) = { go_name: "Group", api_field_name: "group", inline: false }];
  // Kind is kind of the referent. For example "HTTPRoute" or "Service".
  // Defaults to "Service" when not specified.
  string kind = 2 [(dev.f110.kubeproto.field) = { go_name: "Kind", api_field_name: "kind", inline: false }];
  // Name is the name of the referent.
  string name = 3 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Namespace is the namespace of the backend. When unspecified, the local
  // namespace is inferred.
  // Note that when a different namespace is specified, a ReferenceGrant
  // object with ReferenceGrantTo.Kind=Service is required in the referent
  // namespace to allow that namespace's owner to accept the reference.
  // See the ReferenceGrant documentation for details.
  // Support: Core
  string namespace = 4 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
  // Port specifies the destination port number to use for this resource.
  // Port is required when the referent is a Kubernetes Service.
  // For other resources, destination port might be derived from the referent
  // resource or this field.
  int32 port = 5 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
}

message BackendRef {
  // BackendObjectReference references a Kubernetes object.
  BackendObjectReference backend_object_reference = 1 [(dev.f110.kubeproto.field) = { go_name: "BackendObjectReference", inline: true }];
  // Weight specifies the proportion of requests forwarded to the referenced
  // backend. This is computed as weight/(sum of all weights in this
  // BackendRefs list). For non-zero values, there may be some epsilon from
  // the exact proportion defined here depending on the precision an
  // implementation supports. Weight is not a percentage and the sum of
  // weights does not need to equal 100.
  // If only one backend is specified and it has a weight greater than 0, 100%
  // of the traffic is forwarded to that backend. If weight is set to 0, no
  // traffic should be forwarded for this entry. If unspecified, weight
  // defaults to 1.
  // Support for this field varies based on the context where used.
  optional int32 weight = 2 [(dev.f110.kubeproto.field) = { go_name: "Weight", api_field_name: "weight", inline: false }];
}

message CommonRouteSpec {
  // ParentRefs references the resources (usually Gateways) that a Route wants
  // to be attached to. Note that the referenced parent resource needs to
  // allow this for the attachment to be complete. For Gateways, that means
  // the Gateway needs to allow attachment from Routes of this kind and
  // namespace.
  // The only kind of parent resource with "Core" support is Gateway. This API
  // may be extended in the future to support additional kinds of parent
  // resources such as one of the route kinds.
  // It is invalid to reference an identical parent more than once. It is
  // valid to reference multiple distinct sections within the same parent
  // resource, such as 2 Listeners within a Gateway.
  // It is possible to separately reference multiple distinct objects that may
  // be collapsed by an implementation. For example, some implementations may
  // choose to merge compatible Gateway Listeners together. If that is the
  // case, the list of routes attached to those resources should also be
  // merged.
  repeated ParentReference parent_refs = 1 [(dev.f110.kubeproto.field) = { go_name: "ParentRefs", api_field_name: "parentRefs", inline: false }];
}

message Gateway {
  // Spec defines the desired state of Gateway.
  GatewaySpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status defines the current state of Gateway.
  optional GatewayStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message GatewayAddress {
  // Type of the address.
  optional AddressType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Value of the address. The validity of the values will depend
  // on the type and support by the controller.
  // Examples: `1.2.3.4`, `128::1`, `my-ip-address`.
  string value = 2 [(dev.f110.kubeproto.field) = { go_name: "Value", api_field_name: "value", inline: false }];
}

message GatewayClass {
  // Spec defines the desired state of GatewayClass.
  GatewayClassSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status defines the current state of GatewayClass.
  optional GatewayClassStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message GatewayClassList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta          = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  repeated GatewayClass                                  items     = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message GatewayClassSpec {
  // ControllerName is the name of the controller that is managing Gateways of
  // this class. The value of this field MUST be a domain prefixed path.
  // Example: "example.net/gateway-controller".
  // This field is not mutable and cannot be empty.
  // Support: Core
  string controller_name = 1 [(dev.f110.kubeproto.field) = { go_name: "ControllerName", api_field_name: "controllerName", inline: false }];
  // ParametersRef is a reference to a resource that contains the configuration
  // parameters corresponding to the GatewayClass. This is optional if the
  // controller does not require any additional configuration.
  // ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap,
  // or an implementation-specific custom resource. The resource can be
  // cluster-scoped or namespace-scoped.
  // If the referent cannot be found, the GatewayClass's "InvalidParameters"
  // status condition will be true.
  // Support: Custom
  optional ParametersReference parameters_ref = 2 [(dev.f110.kubeproto.field) = { go_name: "ParametersRef", api_field_name: "parametersRef", inline: false }];
  // Description helps describe a GatewayClass with more details.
  optional string description = 3 [(dev.f110.kubeproto.field) = { go_name: "Description", api_field_name: "description", inline: false }];
}

message GatewayClassStatus {
  // Conditions is the current status from the controller for
  // this GatewayClass.
  // Controllers should prefer to publish conditions using values
  // of GatewayClassConditionType for the type of each Condition.
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 1 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
}

message GatewayList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta          = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  repeated Gateway                                       items     = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message GatewaySpec {
  // GatewayClassName used for this Gateway. This is the name of a
  // GatewayClass resource.
  string gateway_class_name = 1 [(dev.f110.kubeproto.field) = { go_name: "GatewayClassName", api_field_name: "gatewayClassName", inline: false }];
  // Listeners associated with this Gateway. Listeners define
  // logical endpoints that are bound on this Gateway's addresses.
  // At least one Listener MUST be specified.
  // Each listener in a Gateway must have a unique combination of Hostname,
  // Port, and Protocol.
  // An implementation MAY group Listeners by Port and then collapse each
  // group of Listeners into a single Listener if the implementation
  // determines that the Listeners in the group are "compatible". An
  // implementation MAY also group together and collapse compatible
  // Listeners belonging to different Gateways.
  // For example, an implementation might consider Listeners to be
  // compatible with each other if all of the following conditions are
  // met:
  // 1. Either each Listener within the group specifies the "HTTP"
  //    Protocol or each Listener within the group specifies either
  //    the "HTTPS" or "TLS" Protocol.
  // 2. Each Listener within the group specifies a Hostname that is unique
  //    within the group.
  // 3. As a special case, one Listener within a group may omit Hostname,
  //    in which case this Listener matches when no other Listener
  //    matches.
  // If the implementation does collapse compatible Listeners, the
  // hostname provided in the incoming client request MUST be
  // matched to a Listener to find the correct set of Routes.
  // The incoming hostname MUST be matched using the Hostname
  // field for each Listener in order of most to least specific.
  // That is, exact matches must be processed before wildcard
  // matches.
  // If this field specifies multiple Listeners that have the same
  // Port value but are not compatible, the implementation must raise
  // a "Conflicted" condition in the Listener status.
  // Support: Core
  repeated Listener listeners = 2 [(dev.f110.kubeproto.field) = { go_name: "Listeners", api_field_name: "listeners", inline: false }];
  // Addresses requested for this Gateway. This is optional and behavior can
  // depend on the implementation. If a value is set in the spec and the
  // requested address is invalid or unavailable, the implementation MUST
  // indicate this in the associated entry in GatewayStatus.Addresses.
  // The Addresses field represents a request for the address(es) on the
  // "outside of the Gateway", that traffic bound for this Gateway will use.
  // This could be the IP address or hostname of an external load balancer or
  // other networking infrastructure, or some other address that traffic will
  // be sent to.
  // The .listener.hostname field is used to route traffic that has already
  // arrived at the Gateway to the correct in-cluster destination.
  // If no Addresses are specified, the implementation MAY schedule the
  // Gateway in an implementation-specific manner, assigning an appropriate
  // set of Addresses.
  // The implementation MUST bind all Listeners to every GatewayAddress that
  // it assigns to the Gateway and add a corresponding entry in
  // GatewayStatus.Addresses.
  // Support: Extended
  repeated GatewayAddress addresses = 3 [(dev.f110.kubeproto.field) = { go_name: "Addresses", api_field_name: "addresses", inline: false }];
}

message GatewayStatus {
  // Addresses lists the IP addresses that have actually been
  // bound to the Gateway. These addresses may differ from the
  // addresses in the Spec, e.g. if the Gateway automatically
  // assigns an address from a reserved pool.
  repeated GatewayAddress addresses = 1 [(dev.f110.kubeproto.field) = { go_name: "Addresses", api_field_name: "addresses", inline: false }];
  // Conditions describe the current conditions of the Gateway.
  // Implementations should prefer to express Gateway conditions
  // using the `GatewayConditionType` and `GatewayConditionReason`
  // constants so that operators and tools can converge on a common
  // vocabulary to describe Gateway state.
  // Known condition types are:
  // * "Scheduled"
  // * "Ready"
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 2 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
  // Listeners provide status for each unique listener port defined in the Spec.
  repeated ListenerStatus listeners = 3 [(dev.f110.kubeproto.field) = { go_name: "Listeners", api_field_name: "listeners", inline: false }];
}

message GatewayTLSConfig {
  // Mode defines the TLS behavior for the TLS session initiated by the client.
  // There are two possible modes:
  // - Terminate: The TLS session between the downstream client
  //   and the Gateway is terminated at the Gateway. This mode requires
  //   certificateRefs to be set and contain at least one element.
  // - Passthrough: The TLS session is NOT terminated by the Gateway. This
  //   implies that the Gateway can't decipher the TLS stream except for
  //   the ClientHello message of the TLS protocol.
  //   CertificateRefs field is ignored in this mode.
  // Support: Core
  optional TLSModeType mode = 1 [(dev.f110.kubeproto.field) = { go_name: "Mode", api_field_name: "mode", inline: false }];
  // CertificateRefs contains a series of references to Kubernetes objects that
  // contains TLS certificates and private keys. These certificates are used to
  // establish a TLS handshake for requests that match the hostname of the
  // associated listener.
  // A single CertificateRef to a Kubernetes Secret has "Core" support.
  // Implementations MAY choose to support attaching multiple certificates to
  // a Listener, but this behavior is implementation-specific.
  // References to a resource in different namespace are invalid UNLESS there
  // is a ReferenceGrant in the target namespace that allows the certificate
  // to be attached. If a ReferenceGrant does not allow this reference, the
  // "ResolvedRefs" condition MUST be set to False for this listener with the
  // "InvalidCertificateRef" reason.
  // This field is required to have at least one element when the mode is set
  // to "Terminate" (default) and is optional otherwise.
  // CertificateRefs can reference to standard Kubernetes resources, i.e.
  // Secret, or implementation-specific custom resources.
  // Support: Core - A single reference to a Kubernetes Secret of type kubernetes.io/tls
  // Support: Implementation-specific (More than one reference or other resource types)
  repeated SecretObjectReference certificate_refs = 2 [(dev.f110.kubeproto.field) = { go_name: "CertificateRefs", api_field_name: "certificateRefs", inline: false }];
  // Options are a list of key/value pairs to enable extended TLS
  // configuration for each implementation. For example, configuring the
  // minimum TLS version or supported cipher suites.
  // A set of common keys MAY be defined by the API in the future. To avoid
  // any ambiguity, implementation-specific definitions MUST use
  // domain-prefixed names, such as `example.com/my-custom-option`.
  // Un-prefixed names are reserved for key names defined by Gateway API.
  // Support: Implementation-specific
  map<string, string> options = 3 [(dev.f110.kubeproto.field) = { go_name: "Options", api_field_name: "options", inline: false }];
}

message HTTPBackendRef {
  // BackendRef is a reference to a backend to forward matched requests to.
  // A BackendRef can be invalid for the following reasons. In all cases, the
  // implementation MUST ensure the `ResolvedRefs` Condition on the Route
  // is set to `status: False`, with a Reason and Message that indicate
  // what is the cause of the error.
  // A BackendRef is invalid if:
  // * It refers to an unknown or unsupported kind of resource. In this
  //   case, the Reason must be set to `InvalidKind` and Message of the
  //   Condition must explain which kind of resource is unknown or unsupported.
  // * It refers to a resource that does not exist. In this case, the Reason must
  //   be set to `BackendNotFound` and the Message of the Condition must explain
  //   which resource does not exist.
  // * It refers a resource in another namespace when the reference has not been
  //   explicitly allowed by a ReferenceGrant (or equivalent concept). In this
  //   case, the Reason must be set to `RefNotPermitted` and the Message of the
  //   Condition must explain which cross-namespace reference is not allowed.
  // Support: Core for Kubernetes Service
  // Support: Custom for any other resource
  // Support for weight: Core
  BackendRef backend_ref = 1 [(dev.f110.kubeproto.field) = { go_name: "BackendRef", inline: true }];
  // Filters defined at this level should be executed if and only if the
  // request is being forwarded to the backend defined here.
  // Support: Custom (For broader support of filters, use the Filters field
  // in HTTPRouteRule.)
  repeated HTTPRouteFilter filters = 2 [(dev.f110.kubeproto.field) = { go_name: "Filters", api_field_name: "filters", inline: false }];
}

message HTTPHeader {
  // Name is the name of the HTTP Header to be matched. Name matching MUST be
  // case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
  // If multiple entries specify equivalent header names, the first entry with
  // an equivalent name MUST be considered for a match. Subsequent entries
  // with an equivalent header name MUST be ignored. Due to the
  // case-insensitivity of header names, "foo" and "Foo" are considered
  // equivalent.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Value is the value of HTTP Header to be matched.
  string value = 2 [(dev.f110.kubeproto.field) = { go_name: "Value", api_field_name: "value", inline: false }];
}

message HTTPHeaderMatch {
  // Type specifies how to match against the value of the header.
  // Support: Core (Exact)
  // Support: Custom (RegularExpression)
  // Since RegularExpression HeaderMatchType has custom conformance,
  // implementations can support POSIX, PCRE or any other dialects of regular
  // expressions. Please read the implementation's documentation to determine
  // the supported dialect.
  optional HeaderMatchType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Name is the name of the HTTP Header to be matched. Name matching MUST be
  // case insensitive. (See https://tools.ietf.org/html/rfc7230#section-3.2).
  // If multiple entries specify equivalent header names, only the first
  // entry with an equivalent name MUST be considered for a match. Subsequent
  // entries with an equivalent header name MUST be ignored. Due to the
  // case-insensitivity of header names, "foo" and "Foo" are considered
  // equivalent.
  // When a header is repeated in an HTTP request, it is
  // implementation-specific behavior as to how this is represented.
  // Generally, proxies should follow the guidance from the RFC:
  // https://www.rfc-editor.org/rfc/rfc7230.html#section-3.2.2 regarding
  // processing a repeated header, with special handling for "Set-Cookie".
  string name = 2 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Value is the value of HTTP Header to be matched.
  string value = 3 [(dev.f110.kubeproto.field) = { go_name: "Value", api_field_name: "value", inline: false }];
}

message HTTPPathMatch {
  // Type specifies how to match against the path Value.
  // Support: Core (Exact, PathPrefix)
  // Support: Custom (RegularExpression)
  optional PathMatchType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Value of the HTTP path to match against.
  optional string value = 2 [(dev.f110.kubeproto.field) = { go_name: "Value", api_field_name: "value", inline: false }];
}

message HTTPPathModifier {
  // Type defines the type of path modifier. Additional types may be
  // added in a future release of the API.
  // Note that values may be added to this enum, implementations
  // must ensure that unknown values will not cause a crash.
  // Unknown values here must result in the implementation setting the
  // Attached Condition for the Route to `status: False`, with a
  // Reason of `UnsupportedValue`.
  // <gateway:experimental>
  HTTPPathModifierType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // ReplaceFullPath specifies the value with which to replace the full path
  // of a request during a rewrite or redirect.
  // <gateway:experimental>
  optional string replace_full_path = 2 [(dev.f110.kubeproto.field) = { go_name: "ReplaceFullPath", api_field_name: "replaceFullPath", inline: false }];
  // ReplacePrefixMatch specifies the value with which to replace the prefix
  // match of a request during a rewrite or redirect. For example, a request
  // to "/foo/bar" with a prefix match of "/foo" would be modified to "/bar".
  // Note that this matches the behavior of the PathPrefix match type. This
  // matches full path elements. A path element refers to the list of labels
  // in the path split by the `/` separator. When specified, a trailing `/` is
  // ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would all
  // match the prefix `/abc`, but the path `/abcd` would not.
  // <gateway:experimental>
  optional string replace_prefix_match = 3 [(dev.f110.kubeproto.field) = { go_name: "ReplacePrefixMatch", api_field_name: "replacePrefixMatch", inline: false }];
}

message HTTPQueryParamMatch {
  // Type specifies how to match against the value of the query parameter.
  // Support: Extended (Exact)
  // Support: Custom (RegularExpression)
  // Since RegularExpression QueryParamMatchType has custom conformance,
  // implementations can support POSIX, PCRE or any other dialects of regular
  // expressions. Please read the implementation's documentation to determine
  // the supported dialect.
  optional QueryParamMatchType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // Name is the name of the HTTP query param to be matched. This must be an
  // exact string match. (See
  // https://tools.ietf.org/html/rfc7230#section-2.7.3).
  // If multiple entries specify equivalent query param names, only the first
  // entry with an equivalent name MUST be considered for a match. Subsequent
  // entries with an equivalent query param name MUST be ignored.
  string name = 2 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Value is the value of HTTP query param to be matched.
  string value = 3 [(dev.f110.kubeproto.field) = { go_name: "Value", api_field_name: "value", inline: false }];
}

message HTTPRequestHeaderFilter {
  // Set overwrites the request with the given header (name, value)
  // before the action.
  // Input:
  //   GET /foo HTTP/1.1
  //   my-header: foo
  // Config:
  //   set:
  //   - name: "my-header"
  //     value: "bar"
  // Output:
  //   GET /foo HTTP/1.1
  //   my-header: bar
  repeated HTTPHeader set = 1 [(dev.f110.kubeproto.field) = { go_name: "Set", api_field_name: "set", inline: false }];
  // Add adds the given header(s) (name, value) to the request
  // before the action. It appends to any existing values associated
  // with the header name.
  // Input:
  //   GET /foo HTTP/1.1
  //   my-header: foo
  // Config:
  //   add:
  //   - name: "my-header"
  //     value: "bar"
  // Output:
  //   GET /foo HTTP/1.1
  //   my-header: foo
  //   my-header: bar
  repeated HTTPHeader add = 2 [(dev.f110.kubeproto.field) = { go_name: "Add", api_field_name: "add", inline: false }];
  // Remove the given header(s) from the HTTP request before the action. The
  // value of Remove is a list of HTTP header names. Note that the header
  // names are case-insensitive (see
  // https://datatracker.ietf.org/doc/html/rfc2616#section-4.2).
  // Input:
  //   GET /foo HTTP/1.1
  //   my-header1: foo
  //   my-header2: bar
  //   my-header3: baz
  // Config:
  //   remove: ["my-header1", "my-header3"]
  // Output:
  //   GET /foo HTTP/1.1
  //   my-header2: bar
  repeated string remove = 3 [(dev.f110.kubeproto.field) = { go_name: "Remove", api_field_name: "remove", inline: false }];
}

message HTTPRequestMirrorFilter {
  // BackendRef references a resource where mirrored requests are sent.
  // If the referent cannot be found, this BackendRef is invalid and must be
  // dropped from the Gateway. The controller must ensure the "ResolvedRefs"
  // condition on the Route status is set to `status: False` and not configure
  // this backend in the underlying implementation.
  // If there is a cross-namespace reference to an *existing* object
  // that is not allowed by a ReferenceGrant, the controller must ensure the
  // "ResolvedRefs"  condition on the Route is set to `status: False`,
  // with the "RefNotPermitted" reason and not configure this backend in the
  // underlying implementation.
  // In either error case, the Message of the `ResolvedRefs` Condition
  // should be used to provide more detail about the problem.
  // Support: Extended for Kubernetes Service
  // Support: Custom for any other resource
  BackendObjectReference backend_ref = 1 [(dev.f110.kubeproto.field) = { go_name: "BackendRef", api_field_name: "backendRef", inline: false }];
}

message HTTPRequestRedirectFilter {
  // Scheme is the scheme to be used in the value of the `Location`
  // header in the response.
  // When empty, the scheme of the request is used.
  // Support: Extended
  // Note that values may be added to this enum, implementations
  // must ensure that unknown values will not cause a crash.
  // Unknown values here must result in the implementation setting the
  // Attached Condition for the Route to `status: False`, with a
  // Reason of `UnsupportedValue`.
  optional string scheme = 1 [(dev.f110.kubeproto.field) = { go_name: "Scheme", api_field_name: "scheme", inline: false }];
  // Hostname is the hostname to be used in the value of the `Location`
  // header in the response.
  // When empty, the hostname of the request is used.
  // Support: Core
  string hostname = 2 [(dev.f110.kubeproto.field) = { go_name: "Hostname", api_field_name: "hostname", inline: false }];
  // Path defines parameters used to modify the path of the incoming request.
  // The modified path is then used to construct the `Location` header. When
  // empty, the request path is used as-is.
  // Support: Extended
  // <gateway:experimental>
  optional HTTPPathModifier path = 3 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // Port is the port to be used in the value of the `Location`
  // header in the response.
  // When empty, port (if specified) of the request is used.
  // Support: Extended
  int32 port = 4 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // StatusCode is the HTTP status code to be used in response.
  // Support: Core
  // Note that values may be added to this enum, implementations
  // must ensure that unknown values will not cause a crash.
  // Unknown values here must result in the implementation setting the
  // Attached Condition for the Route to `status: False`, with a
  // Reason of `UnsupportedValue`.
  optional int32 status_code = 5 [(dev.f110.kubeproto.field) = { go_name: "StatusCode", api_field_name: "statusCode", inline: false }];
}

message HTTPRoute {
  // Spec defines the desired state of HTTPRoute.
  HTTPRouteSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status defines the current state of HTTPRoute.
  optional HTTPRouteStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message HTTPRouteFilter {
  // Type identifies the type of filter to apply. As with other API fields,
  // types are classified into three conformance levels:
  // - Core: Filter types and their corresponding configuration defined by
  //   "Support: Core" in this package, e.g. "RequestHeaderModifier". All
  //   implementations must support core filters.
  // - Extended: Filter types and their corresponding configuration defined by
  //   "Support: Extended" in this package, e.g. "RequestMirror". Implementers
  //   are encouraged to support extended filters.
  // - Custom: Filters that are defined and supported by specific vendors.
  //   In the future, filters showing convergence in behavior across multiple
  //   implementations will be considered for inclusion in extended or core
  //   conformance levels. Filter-specific configuration for such filters
  //   is specified using the ExtensionRef field. `Type` should be set to
  //   "ExtensionRef" for custom filters.
  // Implementers are encouraged to define custom implementation types to
  // extend the core API with implementation-specific behavior.
  // If a reference to a custom filter type cannot be resolved, the filter
  // MUST NOT be skipped. Instead, requests that would have been processed by
  // that filter MUST receive a HTTP error response.
  // Note that values may be added to this enum, implementations
  // must ensure that unknown values will not cause a crash.
  // Unknown values here must result in the implementation setting the
  // Attached Condition for the Route to `status: False`, with a
  // Reason of `UnsupportedValue`.
  // <gateway:experimental:validation:Enum=RequestHeaderModifier;RequestMirror;RequestRedirect;URLRewrite;ExtensionRef>
  HTTPRouteFilterType type = 1 [(dev.f110.kubeproto.field) = { go_name: "Type", api_field_name: "type", inline: false }];
  // RequestHeaderModifier defines a schema for a filter that modifies request
  // headers.
  // Support: Core
  optional HTTPRequestHeaderFilter request_header_modifier = 2 [(dev.f110.kubeproto.field) = { go_name: "RequestHeaderModifier", api_field_name: "requestHeaderModifier", inline: false }];
  // RequestMirror defines a schema for a filter that mirrors requests.
  // Requests are sent to the specified destination, but responses from
  // that destination are ignored.
  // Support: Extended
  optional HTTPRequestMirrorFilter request_mirror = 3 [(dev.f110.kubeproto.field) = { go_name: "RequestMirror", api_field_name: "requestMirror", inline: false }];
  // RequestRedirect defines a schema for a filter that responds to the
  // request with an HTTP redirection.
  // Support: Core
  optional HTTPRequestRedirectFilter request_redirect = 4 [(dev.f110.kubeproto.field) = { go_name: "RequestRedirect", api_field_name: "requestRedirect", inline: false }];
  // URLRewrite defines a schema for a filter that modifies a request during forwarding.
  // Support: Extended
  // <gateway:experimental>
  optional HTTPURLRewriteFilter url_rewrite = 5 [(dev.f110.kubeproto.field) = { go_name: "URLRewrite", api_field_name: "urlRewrite", inline: false }];
  // ExtensionRef is an optional, implementation-specific extension to the
  // "filter" behavior.  For example, resource "myroutefilter" in group
  // "networking.example.net"). ExtensionRef MUST NOT be used for core and
  // extended filters.
  // Support: Implementation-specific
  optional LocalObjectReference extension_ref = 6 [(dev.f110.kubeproto.field) = { go_name: "ExtensionRef", api_field_name: "extensionRef", inline: false }];
}

message HTTPRouteList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta          = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  repeated HTTPRoute                                     items     = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message HTTPRouteMatch {
  // Path specifies a HTTP request path matcher. If this field is not
  // specified, a default prefix match on the "/" path is provided.
  optional HTTPPathMatch path = 1 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
  // Headers specifies HTTP request header matchers. Multiple match values are
  // ANDed together, meaning, a request must match all the specified headers
  // to select the route.
  repeated HTTPHeaderMatch headers = 2 [(dev.f110.kubeproto.field) = { go_name: "Headers", api_field_name: "headers", inline: false }];
  // QueryParams specifies HTTP query parameter matchers. Multiple match
  // values are ANDed together, meaning, a request must match all the
  // specified query parameters to select the route.
  repeated HTTPQueryParamMatch query_params = 3 [(dev.f110.kubeproto.field) = { go_name: "QueryParams", api_field_name: "queryParams", inline: false }];
  // Method specifies HTTP method matcher.
  // When specified, this route will be matched only if the request has the
  // specified method.
  // Support: Extended
  optional HTTPMethod method = 4 [(dev.f110.kubeproto.field) = { go_name: "Method", api_field_name: "method", inline: false }];
}

message HTTPRouteRule {
  // Matches define conditions used for matching the rule against incoming
  // HTTP requests. Each match is independent, i.e. this rule will be matched
  // if **any** one of the matches is satisfied.
  // For example, take the following matches configuration:
  // ```
  // matches:
  // - path:
  //     value: "/foo"
  //   headers:
  //   - name: "version"
  //     value: "v2"
  // - path:
  //     value: "/v2/foo"
  // ```
  // For a request to match against this rule, a request must satisfy
  // EITHER of the two conditions:
  // - path prefixed with `/foo` AND contains the header `version: v2`
  // - path prefix of `/v2/foo`
  // See the documentation for HTTPRouteMatch on how to specify multiple
  // match conditions that should be ANDed together.
  // If no matches are specified, the default is a prefix
  // path match on "/", which has the effect of matching every
  // HTTP request.
  // Proxy or Load Balancer routing configuration generated from HTTPRoutes
  // MUST prioritize rules based on the following criteria, continuing on
  // ties. Precedence must be given to the Rule with the largest number
  // of:
  // * Characters in a matching non-wildcard hostname.
  // * Characters in a matching hostname.
  // * Characters in a matching path.
  // * Header matches.
  // * Query param matches.
  // If ties still exist across multiple Routes, matching precedence MUST be
  // determined in order of the following criteria, continuing on ties:
  // * The oldest Route based on creation timestamp.
  // * The Route appearing first in alphabetical order by
  //   "{namespace}/{name}".
  // If ties still exist within the Route that has been given precedence,
  // matching precedence MUST be granted to the first matching rule meeting
  // the above criteria.
  // When no rules matching a request have been successfully attached to the
  // parent a request is coming from, a HTTP 404 status code MUST be returned.
  repeated HTTPRouteMatch matches = 1 [(dev.f110.kubeproto.field) = { go_name: "Matches", api_field_name: "matches", inline: false }];
  // Filters define the filters that are applied to requests that match
  // this rule.
  // The effects of ordering of multiple behaviors are currently unspecified.
  // This can change in the future based on feedback during the alpha stage.
  // Conformance-levels at this level are defined based on the type of filter:
  // - ALL core filters MUST be supported by all implementations.
  // - Implementers are encouraged to support extended filters.
  // - Implementation-specific custom filters have no API guarantees across
  //   implementations.
  // Specifying a core filter multiple times has unspecified or custom
  // conformance.
  // All filters are expected to be compatible with each other except for the
  // URLRewrite and RequestRedirect filters, which may not be combined. If an
  // implementation can not support other combinations of filters, they must clearly
  // document that limitation. In all cases where incompatible or unsupported
  // filters are specified, implementations MUST add a warning condition to status.
  // Support: Core
  repeated HTTPRouteFilter filters = 2 [(dev.f110.kubeproto.field) = { go_name: "Filters", api_field_name: "filters", inline: false }];
  // BackendRefs defines the backend(s) where matching requests should be
  // sent.
  // Failure behavior here depends on how many BackendRefs are specified and
  // how many are invalid.
  // If *all* entries in BackendRefs are invalid, and there are also no filters
  // specified in this route rule, *all* traffic which matches this rule MUST
  // receive a 500 status code.
  // See the HTTPBackendRef definition for the rules about what makes a single
  // HTTPBackendRef invalid.
  // When a HTTPBackendRef is invalid, 500 status codes MUST be returned for
  // requests that would have otherwise been routed to an invalid backend. If
  // multiple backends are specified, and some are invalid, the proportion of
  // requests that would otherwise have been routed to an invalid backend
  // MUST receive a 500 status code.
  // For example, if two backends are specified with equal weights, and one is
  // invalid, 50 percent of traffic must receive a 500. Implementations may
  // choose how that 50 percent is determined.
  // Support: Core for Kubernetes Service
  // Support: Custom for any other resource
  // Support for weight: Core
  repeated HTTPBackendRef backend_refs = 3 [(dev.f110.kubeproto.field) = { go_name: "BackendRefs", api_field_name: "backendRefs", inline: false }];
}

message HTTPRouteSpec {
  CommonRouteSpec common_route_spec = 1 [(dev.f110.kubeproto.field) = { go_name: "CommonRouteSpec", inline: true }];
  // Hostnames defines a set of hostname that should match against the HTTP
  // Host header to select a HTTPRoute to process the request. This matches
  // the RFC 1123 definition of a hostname with 2 notable exceptions:
  // 1. IPs are not allowed.
  // 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
  //    label must appear by itself as the first label.
  // If a hostname is specified by both the Listener and HTTPRoute, there
  // must be at least one intersecting hostname for the HTTPRoute to be
  // attached to the Listener. For example:
  // * A Listener with `test.example.com` as the hostname matches HTTPRoutes
  //   that have either not specified any hostnames, or have specified at
  //   least one of `test.example.com` or `*.example.com`.
  // * A Listener with `*.example.com` as the hostname matches HTTPRoutes
  //   that have either not specified any hostnames or have specified at least
  //   one hostname that matches the Listener hostname. For example,
  //   `*.example.com`, `test.example.com`, and `foo.test.example.com` would
  //   all match. On the other hand, `example.com` and `test.example.net` would
  //   not match.
  // Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
  // as a suffix match. That means that a match for `*.example.com` would match
  // both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
  // If both the Listener and HTTPRoute have specified hostnames, any
  // HTTPRoute hostnames that do not match the Listener hostname MUST be
  // ignored. For example, if a Listener specified `*.example.com`, and the
  // HTTPRoute specified `test.example.com` and `test.example.net`,
  // `test.example.net` must not be considered for a match.
  // If both the Listener and HTTPRoute have specified hostnames, and none
  // match with the criteria above, then the HTTPRoute is not accepted. The
  // implementation must raise an 'Accepted' Condition with a status of
  // `False` in the corresponding RouteParentStatus.
  // Support: Core
  repeated string hostnames = 2 [(dev.f110.kubeproto.field) = { go_name: "Hostnames", api_field_name: "hostnames", inline: false }];
  // Rules are a list of HTTP matchers, filters and actions.
  repeated HTTPRouteRule rules = 3 [(dev.f110.kubeproto.field) = { go_name: "Rules", api_field_name: "rules", inline: false }];
}

message HTTPRouteStatus {
  RouteStatus route_status = 1 [(dev.f110.kubeproto.field) = { go_name: "RouteStatus", inline: true }];
}

message HTTPURLRewriteFilter {
  // Hostname is the value to be used to replace the Host header value during
  // forwarding.
  // Support: Extended
  // <gateway:experimental>
  string hostname = 1 [(dev.f110.kubeproto.field) = { go_name: "Hostname", api_field_name: "hostname", inline: false }];
  // Path defines a path rewrite.
  // Support: Extended
  // <gateway:experimental>
  optional HTTPPathModifier path = 2 [(dev.f110.kubeproto.field) = { go_name: "Path", api_field_name: "path", inline: false }];
}

message Listener {
  // Name is the name of the Listener. This name MUST be unique within a
  // Gateway.
  // Support: Core
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Hostname specifies the virtual hostname to match for protocol types that
  // define this concept. When unspecified, all hostnames are matched. This
  // field is ignored for protocols that don't require hostname based
  // matching.
  // Implementations MUST apply Hostname matching appropriately for each of
  // the following protocols:
  // * TLS: The Listener Hostname MUST match the SNI.
  // * HTTP: The Listener Hostname MUST match the Host header of the request.
  // * HTTPS: The Listener Hostname SHOULD match at both the TLS and HTTP
  //   protocol layers as described above. If an implementation does not
  //   ensure that both the SNI and Host header match the Listener hostname,
  //   it MUST clearly document that.
  // For HTTPRoute and TLSRoute resources, there is an interaction with the
  // `spec.hostnames` array. When both listener and route specify hostnames,
  // there MUST be an intersection between the values for a Route to be
  // accepted. For more information, refer to the Route specific Hostnames
  // documentation.
  // Hostnames that are prefixed with a wildcard label (`*.`) are interpreted
  // as a suffix match. That means that a match for `*.example.com` would match
  // both `test.example.com`, and `foo.test.example.com`, but not `example.com`.
  // Support: Core
  string hostname = 2 [(dev.f110.kubeproto.field) = { go_name: "Hostname", api_field_name: "hostname", inline: false }];
  // Port is the network port. Multiple listeners may use the
  // same port, subject to the Listener compatibility rules.
  // Support: Core
  int32 port = 3 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
  // Protocol specifies the network protocol this listener expects to receive.
  // Support: Core
  ProtocolType protocol = 4 [(dev.f110.kubeproto.field) = { go_name: "Protocol", api_field_name: "protocol", inline: false }];
  // TLS is the TLS configuration for the Listener. This field is required if
  // the Protocol field is "HTTPS" or "TLS". It is invalid to set this field
  // if the Protocol field is "HTTP", "TCP", or "UDP".
  // The association of SNIs to Certificate defined in GatewayTLSConfig is
  // defined based on the Hostname field for this listener.
  // The GatewayClass MUST use the longest matching SNI out of all
  // available certificates for any TLS handshake.
  // Support: Core
  optional GatewayTLSConfig tls = 5 [(dev.f110.kubeproto.field) = { go_name: "TLS", api_field_name: "tls", inline: false }];
  // AllowedRoutes defines the types of routes that MAY be attached to a
  // Listener and the trusted namespaces where those Route resources MAY be
  // present.
  // Although a client request may match multiple route rules, only one rule
  // may ultimately receive the request. Matching precedence MUST be
  // determined in order of the following criteria:
  // * The most specific match as defined by the Route type.
  // * The oldest Route based on creation timestamp. For example, a Route with
  //   a creation timestamp of "2020-09-08 01:02:03" is given precedence over
  //   a Route with a creation timestamp of "2020-09-08 01:02:04".
  // * If everything else is equivalent, the Route appearing first in
  //   alphabetical order (namespace/name) should be given precedence. For
  //   example, foo/bar is given precedence over foo/baz.
  // All valid rules within a Route attached to this Listener should be
  // implemented. Invalid Route rules can be ignored (sometimes that will mean
  // the full Route). If a Route rule transitions from valid to invalid,
  // support for that Route rule should be dropped to ensure consistency. For
  // example, even if a filter specified by a Route rule is invalid, the rest
  // of the rules within that Route should still be supported.
  // Support: Core
  optional AllowedRoutes allowed_routes = 6 [(dev.f110.kubeproto.field) = { go_name: "AllowedRoutes", api_field_name: "allowedRoutes", inline: false }];
}

message ListenerStatus {
  // Name is the name of the Listener that this status corresponds to.
  string name = 1 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // SupportedKinds is the list indicating the Kinds supported by this
  // listener. This MUST represent the kinds an implementation supports for
  // that Listener configuration.
  // If kinds are specified in Spec that are not supported, they MUST NOT
  // appear in this list and an implementation MUST set the "ResolvedRefs"
  // condition to "False" with the "InvalidRouteKinds" reason. If both valid
  // and invalid Route kinds are specified, the implementation MUST
  // reference the valid Route kinds that have been specified.
  repeated RouteGroupKind supported_kinds = 2 [(dev.f110.kubeproto.field) = { go_name: "SupportedKinds", api_field_name: "supportedKinds", inline: false }];
  // AttachedRoutes represents the total number of Routes that have been
  // successfully attached to this Listener.
  int32 attached_routes = 3 [(dev.f110.kubeproto.field) = { go_name: "AttachedRoutes", api_field_name: "attachedRoutes", inline: false }];
  // Conditions describe the current condition of this listener.
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 4 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
}

message LocalObjectReference {
  // Group is the group of the referent. For example, "networking.k8s.io".
  // When unspecified (empty string), core API group is inferred.
  string group = 1 [(dev.f110.kubeproto.field) = { go_name: "Group", api_field_name: "group", inline: false }];
  // Kind is kind of the referent. For example "HTTPRoute" or "Service".
  string kind = 2 [(dev.f110.kubeproto.field) = { go_name: "Kind", api_field_name: "kind", inline: false }];
  // Name is the name of the referent.
  string name = 3 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
}

message ParametersReference {
  // Group is the group of the referent.
  string group = 1 [(dev.f110.kubeproto.field) = { go_name: "Group", api_field_name: "group", inline: false }];
  // Kind is kind of the referent.
  string kind = 2 [(dev.f110.kubeproto.field) = { go_name: "Kind", api_field_name: "kind", inline: false }];
  // Name is the name of the referent.
  string name = 3 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Namespace is the namespace of the referent.
  // This field is required when referring to a Namespace-scoped resource and
  // MUST be unset when referring to a Cluster-scoped resource.
  string namespace = 4 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
}

message ParentReference {
  // Group is the group of the referent.
  // Support: Core
  string group = 1 [(dev.f110.kubeproto.field) = { go_name: "Group", api_field_name: "group", inline: false }];
  // Kind is kind of the referent.
  // Support: Core (Gateway)
  // Support: Custom (Other Resources)
  string kind = 2 [(dev.f110.kubeproto.field) = { go_name: "Kind", api_field_name: "kind", inline: false }];
  // Namespace is the namespace of the referent. When unspecified (or empty
  // string), this refers to the local namespace of the Route.
  // Support: Core
  string namespace = 3 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
  // Name is the name of the referent.
  // Support: Core
  string name = 4 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // SectionName is the name of a section within the target resource. In the
  // following resources, SectionName is interpreted as the following:
  // * Gateway: Listener Name. When both Port (experimental) and SectionName
  // are specified, the name and port of the selected listener must match
  // both specified values.
  // Implementations MAY choose to support attaching Routes to other resources.
  // If that is the case, they MUST clearly document how SectionName is
  // interpreted.
  // When unspecified (empty string), this will reference the entire resource.
  // For the purpose of status, an attachment is considered successful if at
  // least one section in the parent resource accepts it. For example, Gateway
  // listeners can restrict which Routes can attach to them by Route kind,
  // namespace, or hostname. If 1 of 2 Gateway listeners accept attachment from
  // the referencing Route, the Route MUST be considered successfully
  // attached. If no Gateway listeners accept attachment from this Route, the
  // Route MUST be considered detached from the Gateway.
  // Support: Core
  string section_name = 5 [(dev.f110.kubeproto.field) = { go_name: "SectionName", api_field_name: "sectionName", inline: false }];
  // Port is the network port this Route targets. It can be interpreted
  // differently based on the type of parent resource.
  // When the parent resource is a Gateway, this targets all listeners
  // listening on the specified port that also support this kind of Route(and
  // select this Route). It's not recommended to set `Port` unless the
  // networking behaviors specified in a Route must apply to a specific port
  // as opposed to a listener(s) whose port(s) may be changed. When both Port
  // and SectionName are specified, the name and port of the selected listener
  // must match both specified values.
  // Implementations MAY choose to support other parent resources.
  // Implementations supporting other types of parent resources MUST clearly
  // document how/if Port is interpreted.
  // For the purpose of status, an attachment is considered successful as
  // long as the parent resource accepts it partially. For example, Gateway
  // listeners can restrict which Routes can attach to them by Route kind,
  // namespace, or hostname. If 1 of 2 Gateway listeners accept attachment
  // from the referencing Route, the Route MUST be considered successfully
  // attached. If no Gateway listeners accept attachment from this Route,
  // the Route MUST be considered detached from the Gateway.
  // Support: Extended
  // <gateway:experimental>
  int32 port = 6 [(dev.f110.kubeproto.field) = { go_name: "Port", api_field_name: "port", inline: false }];
}

message PolicyTargetReference {
  // Group is the group of the target resource.
  string group = 1 [(dev.f110.kubeproto.field) = { go_name: "Group", api_field_name: "group", inline: false }];
  // Kind is kind of the target resource.
  string kind = 2 [(dev.f110.kubeproto.field) = { go_name: "Kind", api_field_name: "kind", inline: false }];
  // Name is the name of the target resource.
  string name = 3 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Namespace is the namespace of the referent. When unspecified, the local
  // namespace is inferred. Even when policy targets a resource in a different
  // namespace, it MUST only apply to traffic originating from the same
  // namespace as the policy.
  string namespace = 4 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
}

message ReferenceGrant {
  // Spec defines the desired state of ReferenceGrant.
  optional ReferenceGrantSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ReferenceGrantFrom {
  // Group is the group of the referent.
  // When empty, the Kubernetes core API group is inferred.
  // Support: Core
  string group = 1 [(dev.f110.kubeproto.field) = { go_name: "Group", api_field_name: "group", inline: false }];
  // Kind is the kind of the referent. Although implementations may support
  // additional resources, the following types are part of the "Core"
  // support level for this field.
  // When used to permit a SecretObjectReference:
  // * Gateway
  // When used to permit a BackendObjectReference:
  // * HTTPRoute
  // * TCPRoute
  // * TLSRoute
  // * UDPRoute
  string kind = 2 [(dev.f110.kubeproto.field) = { go_name: "Kind", api_field_name: "kind", inline: false }];
  // Namespace is the namespace of the referent.
  // Support: Core
  string namespace = 3 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
}

message ReferenceGrantList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta          = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  repeated ReferenceGrant                                items     = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message ReferenceGrantSpec {
  // From describes the trusted namespaces and kinds that can reference the
  // resources described in "To". Each entry in this list must be considered
  // to be an additional place that references can be valid from, or to put
  // this another way, entries must be combined using OR.
  // Support: Core
  repeated ReferenceGrantFrom from = 1 [(dev.f110.kubeproto.field) = { go_name: "From", api_field_name: "from", inline: false }];
  // To describes the resources that may be referenced by the resources
  // described in "From". Each entry in this list must be considered to be an
  // additional place that references can be valid to, or to put this another
  // way, entries must be combined using OR.
  // Support: Core
  repeated ReferenceGrantTo to = 2 [(dev.f110.kubeproto.field) = { go_name: "To", api_field_name: "to", inline: false }];
}

message ReferenceGrantTo {
  // Group is the group of the referent.
  // When empty, the Kubernetes core API group is inferred.
  // Support: Core
  string group = 1 [(dev.f110.kubeproto.field) = { go_name: "Group", api_field_name: "group", inline: false }];
  // Kind is the kind of the referent. Although implementations may support
  // additional resources, the following types are part of the "Core"
  // support level for this field:
  // * Secret when used to permit a SecretObjectReference
  // * Service when used to permit a BackendObjectReference
  string kind = 2 [(dev.f110.kubeproto.field) = { go_name: "Kind", api_field_name: "kind", inline: false }];
  // Name is the name of the referent. When unspecified, this policy
  // refers to all resources of the specified Group and Kind in the local
  // namespace.
  string name = 3 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
}

message ReferencePolicy {
  // Spec defines the desired state of ReferencePolicy.
  optional ReferenceGrantSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message ReferencePolicyList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta          = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  repeated ReferencePolicy                               items     = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message RouteGroupKind {
  // Group is the group of the Route.
  string group = 1 [(dev.f110.kubeproto.field) = { go_name: "Group", api_field_name: "group", inline: false }];
  // Kind is the kind of the Route.
  string kind = 2 [(dev.f110.kubeproto.field) = { go_name: "Kind", api_field_name: "kind", inline: false }];
}

message RouteNamespaces {
  // From indicates where Routes will be selected for this Gateway. Possible
  // values are:
  // * All: Routes in all namespaces may be used by this Gateway.
  // * Selector: Routes in namespaces selected by the selector may be used by
  //   this Gateway.
  // * Same: Only Routes in the same namespace may be used by this Gateway.
  // Support: Core
  optional FromNamespaces from = 1 [(dev.f110.kubeproto.field) = { go_name: "From", api_field_name: "from", inline: false }];
  // Selector must be specified when From is set to "Selector". In that case,
  // only Routes in Namespaces matching this Selector will be selected by this
  // Gateway. This field is ignored for other values of "From".
  // Support: Core
  optional k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 2 [(dev.f110.kubeproto.field) = { go_name: "Selector", api_field_name: "selector", inline: false }];
}

message RouteParentStatus {
  // ParentRef corresponds with a ParentRef in the spec that this
  // RouteParentStatus struct describes the status of.
  ParentReference parent_ref = 1 [(dev.f110.kubeproto.field) = { go_name: "ParentRef", api_field_name: "parentRef", inline: false }];
  // ControllerName is a domain/path string that indicates the name of the
  // controller that wrote this status. This corresponds with the
  // controllerName field on GatewayClass.
  // Example: "example.net/gateway-controller".
  // The format of this field is DOMAIN "/" PATH, where DOMAIN and PATH are
  // valid Kubernetes names
  // (https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names).
  // Controllers MUST populate this field when writing status. Controllers should ensure that
  // entries to status populated with their ControllerName are cleaned up when they are no
  // longer necessary.
  string controller_name = 2 [(dev.f110.kubeproto.field) = { go_name: "ControllerName", api_field_name: "controllerName", inline: false }];
  // Conditions describes the status of the route with respect to the Gateway.
  // Note that the route's availability is also subject to the Gateway's own
  // status conditions and listener status.
  // If the Route's ParentRef specifies an existing Gateway that supports
  // Routes of this kind AND that Gateway's controller has sufficient access,
  // then that Gateway's controller MUST set the "Accepted" condition on the
  // Route, to indicate whether the route has been accepted or rejected by the
  // Gateway, and why.
  // A Route MUST be considered "Accepted" if at least one of the Route's
  // rules is implemented by the Gateway.
  // There are a number of cases where the "Accepted" condition may not be set
  // due to lack of controller visibility, that includes when:
  // * The Route refers to a non-existent parent.
  // * The Route is of a type that the controller does not support.
  // * The Route is in a namespace the controller does not have access to.
  repeated k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 3 [(dev.f110.kubeproto.field) = { go_name: "Conditions", api_field_name: "conditions", inline: false }];
}

message RouteStatus {
  // Parents is a list of parent resources (usually Gateways) that are
  // associated with the route, and the status of the route with respect to
  // each parent. When this route attaches to a parent, the controller that
  // manages the parent must add an entry to this list when the controller
  // first sees the route and should update the entry as appropriate when the
  // route or gateway is modified.
  // Note that parent references that cannot be resolved by an implementation
  // of this API will not be added to this list. Implementations of this API
  // can only populate Route status for the Gateways/parent resources they are
  // responsible for.
  // A maximum of 32 Gateways will be represented in this list. An empty list
  // means the route has not been attached to any Gateway.
  repeated RouteParentStatus parents = 1 [(dev.f110.kubeproto.field) = { go_name: "Parents", api_field_name: "parents", inline: false }];
}

message SecretObjectReference {
  // Group is the group of the referent. For example, "networking.k8s.io".
  // When unspecified (empty string), core API group is inferred.
  string group = 1 [(dev.f110.kubeproto.field) = { go_name: "Group", api_field_name: "group", inline: false }];
  // Kind is kind of the referent. For example "HTTPRoute" or "Service".
  string kind = 2 [(dev.f110.kubeproto.field) = { go_name: "Kind", api_field_name: "kind", inline: false }];
  // Name is the name of the referent.
  string name = 3 [(dev.f110.kubeproto.field) = { go_name: "Name", api_field_name: "name", inline: false }];
  // Namespace is the namespace of the backend. When unspecified, the local
  // namespace is inferred.
  // Note that when a different namespace is specified, a ReferenceGrant
  // object with ReferenceGrantTo.Kind=Secret is required in the referent
  // namespace to allow that namespace's owner to accept the reference.
  // See the ReferenceGrant documentation for details.
  // Support: Core
  string namespace = 4 [(dev.f110.kubeproto.field) = { go_name: "Namespace", api_field_name: "namespace", inline: false }];
}

message TCPRoute {
  // Spec defines the desired state of TCPRoute.
  TCPRouteSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status defines the current state of TCPRoute.
  optional TCPRouteStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message TCPRouteList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta          = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  repeated TCPRoute                                      items     = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message TCPRouteRule {
  // BackendRefs defines the backend(s) where matching requests should be
  // sent. If unspecified or invalid (refers to a non-existent resource or a
  // Service with no endpoints), the underlying implementation MUST actively
  // reject connection attempts to this backend. Connection rejections must
  // respect weight; if an invalid backend is requested to have 80% of
  // connections, then 80% of connections must be rejected instead.
  // Support: Core for Kubernetes Service
  // Support: Custom for any other resource
  // Support for weight: Extended
  repeated BackendRef backend_refs = 1 [(dev.f110.kubeproto.field) = { go_name: "BackendRefs", api_field_name: "backendRefs", inline: false }];
}

message TCPRouteSpec {
  CommonRouteSpec common_route_spec = 1 [(dev.f110.kubeproto.field) = { go_name: "CommonRouteSpec", inline: true }];
  // Rules are a list of TCP matchers and actions.
  repeated TCPRouteRule rules = 2 [(dev.f110.kubeproto.field) = { go_name: "Rules", api_field_name: "rules", inline: false }];
}

message TCPRouteStatus {
  RouteStatus route_status = 1 [(dev.f110.kubeproto.field) = { go_name: "RouteStatus", inline: true }];
}

message TLSRoute {
  // Spec defines the desired state of TLSRoute.
  TLSRouteSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status defines the current state of TLSRoute.
  optional TLSRouteStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message TLSRouteList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta          = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  repeated TLSRoute                                      items     = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message TLSRouteRule {
  // BackendRefs defines the backend(s) where matching requests should be
  // sent. If unspecified or invalid (refers to a non-existent resource or
  // a Service with no endpoints), the rule performs no forwarding; if no
  // filters are specified that would result in a response being sent, the
  // underlying implementation must actively reject request attempts to this
  // backend, by rejecting the connection or returning a 500 status code.
  // Request rejections must respect weight; if an invalid backend is
  // requested to have 80% of requests, then 80% of requests must be rejected
  // instead.
  // Support: Core for Kubernetes Service
  // Support: Custom for any other resource
  // Support for weight: Extended
  repeated BackendRef backend_refs = 1 [(dev.f110.kubeproto.field) = { go_name: "BackendRefs", api_field_name: "backendRefs", inline: false }];
}

message TLSRouteSpec {
  CommonRouteSpec common_route_spec = 1 [(dev.f110.kubeproto.field) = { go_name: "CommonRouteSpec", inline: true }];
  // Hostnames defines a set of SNI names that should match against the
  // SNI attribute of TLS ClientHello message in TLS handshake. This matches
  // the RFC 1123 definition of a hostname with 2 notable exceptions:
  // 1. IPs are not allowed in SNI names per RFC 6066.
  // 2. A hostname may be prefixed with a wildcard label (`*.`). The wildcard
  //    label must appear by itself as the first label.
  // If a hostname is specified by both the Listener and TLSRoute, there
  // must be at least one intersecting hostname for the TLSRoute to be
  // attached to the Listener. For example:
  // * A Listener with `test.example.com` as the hostname matches TLSRoutes
  //   that have either not specified any hostnames, or have specified at
  //   least one of `test.example.com` or `*.example.com`.
  // * A Listener with `*.example.com` as the hostname matches TLSRoutes
  //   that have either not specified any hostnames or have specified at least
  //   one hostname that matches the Listener hostname. For example,
  //   `test.example.com` and `*.example.com` would both match. On the other
  //   hand, `example.com` and `test.example.net` would not match.
  // If both the Listener and TLSRoute have specified hostnames, any
  // TLSRoute hostnames that do not match the Listener hostname MUST be
  // ignored. For example, if a Listener specified `*.example.com`, and the
  // TLSRoute specified `test.example.com` and `test.example.net`,
  // `test.example.net` must not be considered for a match.
  // If both the Listener and TLSRoute have specified hostnames, and none
  // match with the criteria above, then the TLSRoute is not accepted. The
  // implementation must raise an 'Accepted' Condition with a status of
  // `False` in the corresponding RouteParentStatus.
  // Support: Core
  repeated string hostnames = 2 [(dev.f110.kubeproto.field) = { go_name: "Hostnames", api_field_name: "hostnames", inline: false }];
  // Rules are a list of TLS matchers and actions.
  repeated TLSRouteRule rules = 3 [(dev.f110.kubeproto.field) = { go_name: "Rules", api_field_name: "rules", inline: false }];
}

message TLSRouteStatus {
  RouteStatus route_status = 1 [(dev.f110.kubeproto.field) = { go_name: "RouteStatus", inline: true }];
}

message UDPRoute {
  // Spec defines the desired state of UDPRoute.
  UDPRouteSpec spec = 3 [(dev.f110.kubeproto.field) = { go_name: "Spec", api_field_name: "spec", inline: false }];
  // Status defines the current state of UDPRoute.
  optional UDPRouteStatus status = 4 [(dev.f110.kubeproto.field) = { go_name: "Status", api_field_name: "status", inline: false }];

  option (dev.f110.kubeproto.kind) = {
  };
}

message UDPRouteList {
  k8s.io.apimachinery.pkg.apis.meta.v1.TypeMeta type_meta          = 1 [(dev.f110.kubeproto.field) = { go_name: "TypeMeta", inline: true }];
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta list_meta = 2 [(dev.f110.kubeproto.field) = { go_name: "ListMeta", api_field_name: "metadata", inline: false }];
  repeated UDPRoute                                      items     = 3 [(dev.f110.kubeproto.field) = { go_name: "Items", api_field_name: "items", inline: false }];
}

message UDPRouteRule {
  // BackendRefs defines the backend(s) where matching requests should be
  // sent. If unspecified or invalid (refers to a non-existent resource or a
  // Service with no endpoints), the underlying implementation MUST actively
  // reject connection attempts to this backend. Packet drops must
  // respect weight; if an invalid backend is requested to have 80% of
  // the packets, then 80% of packets must be dropped instead.
  // Support: Core for Kubernetes Service
  // Support: Custom for any other resource
  // Support for weight: Extended
  repeated BackendRef backend_refs = 1 [(dev.f110.kubeproto.field) = { go_name: "BackendRefs", api_field_name: "backendRefs", inline: false }];
}

message UDPRouteSpec {
  CommonRouteSpec common_route_spec = 1 [(dev.f110.kubeproto.field) = { go_name: "CommonRouteSpec", inline: true }];
  // Rules are a list of UDP matchers and actions.
  repeated UDPRouteRule rules = 2 [(dev.f110.kubeproto.field) = { go_name: "Rules", api_field_name: "rules", inline: false }];
}

message UDPRouteStatus {
  RouteStatus route_status = 1 [(dev.f110.kubeproto.field) = { go_name: "RouteStatus", inline: true }];
}
